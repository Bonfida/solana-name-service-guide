<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Solana Name Service Guide</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="deployment.html"><strong aria-hidden="true">2.</strong> Deployment</a></li><li class="chapter-item expanded "><a href="sns-ip/index.html"><strong aria-hidden="true">3.</strong> SNS IP</a></li><li class="chapter-item expanded "><a href="videos.html"><strong aria-hidden="true">4.</strong> Videos</a></li><li class="chapter-item expanded "><a href="installation.html"><strong aria-hidden="true">5.</strong> SNS Library</a></li><li class="chapter-item expanded "><a href="faq.html"><strong aria-hidden="true">6.</strong> FAQ</a></li><li class="chapter-item expanded "><a href="registry.html"><strong aria-hidden="true">7.</strong> Name Registry</a></li><li class="chapter-item expanded "><a href="domain-name/wallet-guide/index.html"><strong aria-hidden="true">8.</strong> Wallet Guide</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="domain-name/wallet-guide/resolving-domains.html"><strong aria-hidden="true">8.1.</strong> Resolving Domains</a></li><li class="chapter-item expanded "><a href="domain-name/wallet-guide/bridged-domains.html"><strong aria-hidden="true">8.2.</strong> Bridged Domains</a></li><li class="chapter-item expanded "><a href="domain-name/wallet-guide/twitter-handles.html"><strong aria-hidden="true">8.3.</strong> Twitter handles</a></li></ol></li><li class="chapter-item expanded "><a href="domain-name/index.html"><strong aria-hidden="true">9.</strong> Domain Name</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="domain-name/domain-tld.html"><strong aria-hidden="true">9.1.</strong> TLD</a></li><li class="chapter-item expanded "><a href="domain-name/web-resolution.html"><strong aria-hidden="true">9.2.</strong> Web resolution</a></li><li class="chapter-item expanded "><a href="domain-name/domain-direct-lookup.html"><strong aria-hidden="true">9.3.</strong> Direct look up</a></li><li class="chapter-item expanded "><a href="domain-name/domain-reverse-lookup.html"><strong aria-hidden="true">9.4.</strong> Reverse look up</a></li><li class="chapter-item expanded "><a href="domain-name/domain-find-for-owner.html"><strong aria-hidden="true">9.5.</strong> Get all domains of a user</a></li><li class="chapter-item expanded "><a href="domain-name/all-domains.html"><strong aria-hidden="true">9.6.</strong> Get all domains</a></li><li class="chapter-item expanded "><a href="domain-name/records.html"><strong aria-hidden="true">9.7.</strong> Records</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="domain-name/records/records.html"><strong aria-hidden="true">9.7.1.</strong> Records V1</a></li><li class="chapter-item expanded "><a href="domain-name/records/records-v2.html"><strong aria-hidden="true">9.7.2.</strong> Records V2</a></li></ol></li><li class="chapter-item expanded "><a href="domain-name/edit-domain-content.html"><strong aria-hidden="true">9.8.</strong> Edit domain content</a></li><li class="chapter-item expanded "><a href="domain-name/transfer.html"><strong aria-hidden="true">9.9.</strong> Transfer domains</a></li><li class="chapter-item expanded "><a href="domain-name/primary-domain.html"><strong aria-hidden="true">9.10.</strong> Primary domain</a></li><li class="chapter-item expanded "><a href="domain-name/react-hooks/index.html"><strong aria-hidden="true">9.11.</strong> React hooks</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="domain-name/react-hooks/use-domains.html"><strong aria-hidden="true">9.11.1.</strong> useDomains</a></li><li class="chapter-item expanded "><a href="domain-name/react-hooks/use-domain-records.html"><strong aria-hidden="true">9.11.2.</strong> useRecords</a></li><li class="chapter-item expanded "><a href="domain-name/react-hooks/use-records-V2.html"><strong aria-hidden="true">9.11.3.</strong> useRecordsV2</a></li><li class="chapter-item expanded "><a href="domain-name/react-hooks/use-domains-for-user.html"><strong aria-hidden="true">9.11.4.</strong> useDomainsForUser</a></li><li class="chapter-item expanded "><a href="domain-name/react-hooks/use-primary-domain.html"><strong aria-hidden="true">9.11.5.</strong> usePrimaryDomain</a></li><li class="chapter-item expanded "><a href="domain-name/react-hooks/use-profile-pic.html"><strong aria-hidden="true">9.11.6.</strong> useProfilePic</a></li></ol></li><li class="chapter-item expanded "><a href="domain-name/vue.html"><strong aria-hidden="true">9.12.</strong> Vue SDK</a></li><li class="chapter-item expanded "><a href="domain-name/tokenization.html"><strong aria-hidden="true">9.13.</strong> Tokenization</a></li><li class="chapter-item expanded "><a href="domain-name/registration.html"><strong aria-hidden="true">9.14.</strong> Registration</a></li><li class="chapter-item expanded "><a href="domain-name/media-kit.html"><strong aria-hidden="true">9.15.</strong> Media kit</a></li><li class="chapter-item expanded "><a href="domain-name/delete-domain.html"><strong aria-hidden="true">9.16.</strong> Delete domains</a></li><li class="chapter-item expanded "><a href="domain-name/subdomains/index.html"><strong aria-hidden="true">9.17.</strong> Subdomains</a></li><li class="chapter-item expanded "><a href="domain-name/devnet.html"><strong aria-hidden="true">9.18.</strong> Devnet</a></li><li class="chapter-item expanded "><a href="domain-name/sns-examples/index.html"><strong aria-hidden="true">9.19.</strong> Examples</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="domain-name/sns-examples/derivations.html"><strong aria-hidden="true">9.19.1.</strong> Key derivations</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="twitter/index.html"><strong aria-hidden="true">10.</strong> Twitter</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="twitter/twitter-tld.html"><strong aria-hidden="true">10.1.</strong> TLD</a></li><li class="chapter-item expanded "><a href="twitter/register.html"><strong aria-hidden="true">10.2.</strong> Registration</a></li><li class="chapter-item expanded "><a href="twitter/twitter-direct-lookup.html"><strong aria-hidden="true">10.3.</strong> Direct look up</a></li><li class="chapter-item expanded "><a href="twitter/twitter-reverse-lookup.html"><strong aria-hidden="true">10.4.</strong> Reverse look up</a></li></ol></li><li class="chapter-item expanded "><a href="sns-api/index.html"><strong aria-hidden="true">11.</strong> SNS API</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="sns-api/domains.html"><strong aria-hidden="true">11.1.</strong> Domains</a></li><li class="chapter-item expanded "><a href="sns-api/categories.html"><strong aria-hidden="true">11.2.</strong> Categories</a></li><li class="chapter-item expanded "><a href="sns-api/users.html"><strong aria-hidden="true">11.3.</strong> Users</a></li><li class="chapter-item expanded "><a href="sns-api/listings.html"><strong aria-hidden="true">11.4.</strong> Listings</a></li><li class="chapter-item expanded "><a href="sns-api/sales.html"><strong aria-hidden="true">11.5.</strong> Sales</a></li><li class="chapter-item expanded "><a href="sns-api/volumes.html"><strong aria-hidden="true">11.6.</strong> Volumes</a></li><li class="chapter-item expanded "><a href="sns-api/owners.html"><strong aria-hidden="true">11.7.</strong> Owners</a></li><li class="chapter-item expanded "><a href="sns-api/images.html"><strong aria-hidden="true">11.8.</strong> Images</a></li></ol></li><li class="chapter-item expanded "><a href="marketplace.html"><strong aria-hidden="true">12.</strong> Marketplace</a></li><li class="chapter-item expanded "><a href="sns-suggest/index.html"><strong aria-hidden="true">13.</strong> SNS Suggest API - Alpha</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="sns-suggest/current-owner.html"><strong aria-hidden="true">13.1.</strong> Current Owner</a></li></ol></li><li class="chapter-item expanded "><a href="sns-quicknode/index.html"><strong aria-hidden="true">14.</strong> SNS Quicknode API</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="sns-quicknode/sns_getAllDomainsForOwner.html"><strong aria-hidden="true">14.1.</strong> sns_getAllDomainsForOwner</a></li><li class="chapter-item expanded "><a href="sns-quicknode/sns_getDomainData.html"><strong aria-hidden="true">14.2.</strong> sns_getDomainData</a></li><li class="chapter-item expanded "><a href="sns-quicknode/sns_getDomainKey.html"><strong aria-hidden="true">14.3.</strong> sns_getDomainKey</a></li><li class="chapter-item expanded "><a href="sns-quicknode/sns_getDomainRecordKey.html"><strong aria-hidden="true">14.4.</strong> sns_getDomainRecordKey</a></li><li class="chapter-item expanded "><a href="sns-quicknode/sns_getFavouriteDomain.html"><strong aria-hidden="true">14.5.</strong> sns_getFavouriteDomain</a></li><li class="chapter-item expanded "><a href="sns-quicknode/sns_getRegistrationTransaction.html"><strong aria-hidden="true">14.6.</strong> sns_getRegistrationTransaction</a></li><li class="chapter-item expanded "><a href="sns-quicknode/sns_getSubdomains.html"><strong aria-hidden="true">14.7.</strong> sns_getSubdomains</a></li><li class="chapter-item expanded "><a href="sns-quicknode/sns_getSupportedRecords.html"><strong aria-hidden="true">14.8.</strong> sns_getSupportedRecords</a></li><li class="chapter-item expanded "><a href="sns-quicknode/sns_resolveDomain.html"><strong aria-hidden="true">14.9.</strong> sns_resolveDomain</a></li><li class="chapter-item expanded "><a href="sns-quicknode/sns_reverseLookup.html"><strong aria-hidden="true">14.10.</strong> sns_reverseLookup</a></li><li class="chapter-item expanded "><a href="sns-quicknode/sns_getDomainReverseKey.html"><strong aria-hidden="true">14.11.</strong> sns_getDomainReverseKey</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Solana Name Service Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p><img src="./assets/introduction.gif" alt="introduction" /></p>
<h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Welcome to the Solana Name Service (SNS). SNS has a simple mission of providing a decentralized and yet affordable way to map domain names (represented as .sol) to on-chain data. Where on-chain data can be anything from a Solana (SOL) address to IPFS CID, images, text, and more.
One of the clear benefits of the name service is a human-readable name that maps to a SOL address. Essentially, creating an identity for users in the metaverse.
Why does this matter you may ask? Well, wallet address formats can be a barrier to entry, and therefore having an identifiable address can facilitate payments and its efficiency.
Nonetheless, Solana domain names can have much broader applications than just payments. Most decentralized apps (dApps) have a single point of failure which is their centralized and censorable domain name. However, on-chain domain names cannot be censored or taken away! Thus a website hosted on IPFS (or Arweave) using a Solana domain name would be completely decentralized and very difficult to censor.</p>
<h2 id="twitter-handles--sol-domain-names"><a class="header" href="#twitter-handles--sol-domain-names">Twitter handles &amp; .sol domain names</a></h2>
<p>Both Twitter handles and .sol domain names are a part of SNS, yet are slightly different. A Twitter handle can only be claimed by the owner of the Twitter account. In order to guarantee this, the user needs to tweet the wallet address they want to associate with the account and then sign a transaction using the same wallet address. An oracle then verifies that the public key contained in the tweet matches with the signer. In practice, this means that Twitter names are already reserved. Twitter users just need to claim their public key by tweeting it.
Still, this has privacy implications that require you to have an identifiable Twitter account. This is where .sol domain names are useful. The domain names serve the same purpose as Twitter handles except they do not require you to reveal any personal information or a Twitter account.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deployment"><a class="header" href="#deployment">Deployment</a></h1>
<p>The Solana Name Service program is deployed on <a href="https://explorer.solana.com/address/namesLPneVptA9Z5rqUDD9tMTWEJwofgaYwp8cawRkX">Mainnet</a>, <a href="https://explorer.solana.com/address/namesLPneVptA9Z5rqUDD9tMTWEJwofgaYwp8cawRkX?cluster=devnet">Devnet</a> and <a href="https://explorer.solana.com/address/namesLPneVptA9Z5rqUDD9tMTWEJwofgaYwp8cawRkX?cluster=testnet">Testnet</a> at the following address:</p>
<pre><code>namesLPneVptA9Z5rqUDD9tMTWEJwofgaYwp8cawRkX
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sns-improvement-proposal-sns-ip"><a class="header" href="#sns-improvement-proposal-sns-ip">SNS Improvement Proposal (SNS-IP)</a></h1>
<p>The Solana Name Service Improvement Protocol (SNS-IP) allows all community members to participate in the building process of SNS &amp; makes it much more transparent.</p>
<p>SNS-IPs can be found on Github: <a href="https://github.com/SolanaNameService/sns-ip">https://github.com/SolanaNameService/sns-ip</a></p>
<h2 id="accepted"><a class="header" href="#accepted">Accepted</a></h2>
<ul>
<li>
<p><a href="https://github.com/SolanaNameService/sns-ip/blob/master/proposals/sns-ip-1.md">SNS-IP-1</a>: Proposal to standardize data encoding in SNS records</p>
</li>
<li>
<p><a href="https://github.com/SolanaNameService/sns-ip/blob/master/proposals/sns-ip-3.md">SNS-IP-3</a>: Amends SNS-IP-2, proposes a new specification for on-chain records which can address concerns related to the staleness of records, as well as right of association to the linked ressource when relevant</p>
</li>
</ul>
<h2 id="draft"><a class="header" href="#draft">Draft</a></h2>
<ul>
<li>No proposals currently in draft</li>
</ul>
<h2 id="rejected"><a class="header" href="#rejected">Rejected</a></h2>
<ul>
<li><a href="https://github.com/SolanaNameService/sns-ip/blob/master/proposals/sns-ip-2.md">SNS-IP-2</a>: Proposal to improve the handling of staleness and authenticy of records</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="video-tutorials"><a class="header" href="#video-tutorials">Video Tutorials</a></h1>
<p>The following is a curated list of video tutorials that provide comprehensive guidance on using SNS and developing small-scale applications:</p>
<ul>
<li><strong>Frontend Development (React):</strong>
<ul>
<li><strong>Domain Resolution:</strong> Learn how to resolve domains with this tutorial <a href="https://www.youtube.com/watch?v=1URvs0Pdcb4">Watch Video</a></li>
<li><strong>Reverse Lookup:</strong> Understand the process of reverse lookup <a href="https://www.youtube.com/watch?v=MWz-Vt1SoFE">Watch Video</a></li>
<li><strong>Picture Record</strong>: Learn how to use the profile record of SNS users <a href="https://youtu.be/Gj1eLIY3uRk">Watch Video</a></li>
<li><strong>Records V2</strong>: Integrate V2 records into your applications <a href="https://www.youtube.com/watch?v=hmAaAiZJVJs">Watch Video</a></li>
<li><strong>SNS Widget</strong>: Learn about our SNS Widget React component <a href="https://www.youtube.com/watch?v=ZlBZjNUvuxc">Watch Video</a></li>
<li><strong>ETH Record V2</strong>: Fetch verified ETH records with Records V2 <a href="https://www.youtube.com/watch?v=PpuxPMsyTTY">Watch Video</a></li>
<li><strong>URL/CNAME Records V2</strong>: Set up verified URL and CNAME records as a domain owner <a href="https://youtu.be/_Ca0uOj_M3g">Watch Video</a></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sns-sdk"><a class="header" href="#sns-sdk">SNS SDK</a></h1>
<p>The SNS SDK monorepo can be found <a href="https://github.com/SolanaNameService/sns-sdk">here</a>. It contains SDK for:</p>
<ul>
<li><a href="https://crates.io/crates/sns-sdk">A Rust SDK</a></li>
<li><a href="https://github.com/SolanaNameService/sns-sdk#javascript">A Javascript SDK</a></li>
<li><a href="https://github.com/SolanaNameService/sns-sdk#react">A React hooks library</a></li>
<li><a href="https://github.com/SolanaNameService/sns-sdk/tree/main#vue">A Vue SDK</a></li>
<li><a href="https://github.com/SolanaNameService/sns-sdk#cli">A CLI</a></li>
</ul>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<h3 id="rust-sdk"><a class="header" href="#rust-sdk">Rust SDK</a></h3>
<pre><code>cargo add sns-sdk
</code></pre>
<p>or</p>
<pre><code>sns-sdk = "0.1.0"
</code></pre>
<h3 id="js-library"><a class="header" href="#js-library">JS Library</a></h3>
<p>To install the <a href="https://www.npmjs.com/package/@bonfida/spl-name-service">JS library</a></p>
<pre><code class="language-js">npm i @bonfida/spl-name-service
</code></pre>
<p>or</p>
<pre><code class="language-js">yarn add @bonfida/spl-name-service
</code></pre>
<p>To install the React</p>
<h3 id="react-hooks"><a class="header" href="#react-hooks">React hooks</a></h3>
<p>To install the <a href="https://www.npmjs.com/package/@bonfida/sns-react">React hooks library</a></p>
<pre><code>npm i @bonfida/sns-react
</code></pre>
<p>or</p>
<pre><code>yarn add @bonfida/sns-react
</code></pre>
<h3 id="vue-sdk"><a class="header" href="#vue-sdk">Vue SDK</a></h3>
<p>To install the <a href="https://www.npmjs.com/package/@bonfida/sns-vue">Vue SDK</a></p>
<pre><code>npm i @bonfida/sns-vue
</code></pre>
<p>or</p>
<pre><code>yarn add @bonfida/sns-vue
</code></pre>
<h3 id="cli"><a class="header" href="#cli">CLI</a></h3>
<pre><code>cargo install --git https://github.com/SolanaNameService/sns-sdk.git sns
</code></pre>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<p>The following examples show how to resolve the domain <code>bonfida.sol</code>:</p>
<ol>
<li>With the JS SDK</li>
</ol>
<pre><code class="language-js">const connection = new Connection(clusterApiUrl("mainnet-beta"));
const owner = await resolve(connection, "bonfida");
expect(owner.toBase58()).toBe("HKKp49qGWXd639QsuH7JiLijfVW5UtCVY4s1n2HANwEA");
</code></pre>
<ol start="2">
<li>With the Rust SDK</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let client = RpcClient::new(std::env::var("RPC_URL").unwrap());
let res = resolve_owner(&amp;client, "bonfida").await.unwrap();
assert_eq!(res, pubkey!("HKKp49qGWXd639QsuH7JiLijfVW5UtCVY4s1n2HANwEA"));
<span class="boring">}</span></code></pre></pre>
<ol start="3">
<li>With the CLI</li>
</ol>
<pre><code class="language-bash">$ sns resolve bonfida

+---------+----------------------------------------------+----------------------------------------------------------------------------------+
| Domain  | Owner                                        | Explorer                                                                         |
+---------+----------------------------------------------+----------------------------------------------------------------------------------+
| bonfida | HKKp49qGWXd639QsuH7JiLijfVW5UtCVY4s1n2HANwEA | https://explorer.solana.com/address/HKKp49qGWXd639QsuH7JiLijfVW5UtCVY4s1n2HANwEA |
+---------+----------------------------------------------+----------------------------------------------------------------------------------+
</code></pre>
<ol start="5">
<li>With the React SDK</li>
</ol>
<pre><code class="language-ts">import { useConnection, useWallet } from "@solana/wallet-adapter-react";
import { useDomainOwner, useDomainsForOwner } from "@bonfida/sns-react";

export const Example = () =&gt; {
  const { connection } = useConnection();
  const { publicKey, connected } = useWallet();
  const { result } = useDomainOwner(connection, "bonfida");
  // ...
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="faq"><a class="header" href="#faq">FAQ</a></h1>
<h2 id="where-can-i-buy-a-domain"><a class="header" href="#where-can-i-buy-a-domain">Where can I buy a domain?</a></h2>
<p>You can buy a domain on the <a href="https://sns.id">Solana Name Service website</a></p>
<h2 id="how-do-i-find-a-domain-if-i-only-know-its-public-key"><a class="header" href="#how-do-i-find-a-domain-if-i-only-know-its-public-key">How do I find a domain if I only know its public key?</a></h2>
<p>If you only know the public key of a domain you can do a reverse look up to find the associated domain. For example:</p>
<pre><code class="language-js">import { reverseLookup } from "@bonfida/spl-name-service";

// Public key of bonfida.sol
const domainKey = new PublicKey("Crf8hzfthWGbGbLTVCiqRqV5MVnbpHB1L9KQMd6gsinb");

const domainName = await reverseLookup(connection, domainKey); // bonfida
</code></pre>
<h2 id="how-do-i-find-the-public-key-of-a-domain"><a class="header" href="#how-do-i-find-the-public-key-of-a-domain">How do I find the public key of a domain?</a></h2>
<p>If you want to find the public key of a domain you need to derive it:</p>
<pre><code class="language-js">import { getDomainKeySync } from "@bonfida/spl-name-service";

const domain = "bonfida"; // With or without the .sol

// Step 2
const { pubkey } = getDomainKeySync(domain);
</code></pre>
<h2 id="how-can-i-find-the-content-of-a-domain"><a class="header" href="#how-can-i-find-the-content-of-a-domain">How can I find the content of a domain?</a></h2>
<p>You can access the content of a domain by retrieving its registry:</p>
<pre><code class="language-js">const { registry } = await NameRegistryState.retrieve(connection, domainKey);
const { parentName, owner, class, data } = registry;
</code></pre>
<h2 id="how-do-i-find-the-twitter-handle-of-a-public-key"><a class="header" href="#how-do-i-find-the-twitter-handle-of-a-public-key">How do I find the twitter handle of a public key?</a></h2>
<p>To find the twitter handle of a public key</p>
<pre><code class="language-js">import { getHandleAndRegistryKey } from "@bonfida/spl-name-service";

const pubkey = new PublicKey("FidaeBkZkvDqi1GXNEwB8uWmj9Ngx2HXSS5nyGRuVFcZ");

const [handle] = await getHandleAndRegistryKey(connection, pubkey);
</code></pre>
<h2 id="how-do-i-find-the-public-key-of-a-twitter-handle"><a class="header" href="#how-do-i-find-the-public-key-of-a-twitter-handle">How do I find the public key of a twitter handle?</a></h2>
<p>To find the public key of a twitter handle</p>
<pre><code class="language-js">import { getTwitterRegistry } from "@bonfida/spl-name-service";

const handle = "bonfida";

const registry = await getTwitterRegistry(connection, handle);
</code></pre>
<h2 id="how-do-i-find-all-the-subdomains-of-a-domain"><a class="header" href="#how-do-i-find-all-the-subdomains-of-a-domain">How do I find all the subdomains of a domain?</a></h2>
<p>You can find all the subdomains using the following RPC filter:</p>
<pre><code class="language-js">const filters = [
  {
    memcmp: {
      offset: 32,
      bytes: userAccount.toBase58(),
    },
  },
  {
    memcmp: {
      offset: 0,
      bytes: parent_key.toBase58(),
    },
  },
];
</code></pre>
<h2 id="how-do-i-find-all-the-subdomains-of-a-user"><a class="header" href="#how-do-i-find-all-the-subdomains-of-a-user">How do I find all the subdomains of a user?</a></h2>
<p>You can find all the subdomains of a user by doing the following</p>
<ol>
<li>Retrieve all the domains of the user</li>
<li>Iterate over the domains and retrieve the subdomains for each</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="name-registry-understanding-domains-on-solana"><a class="header" href="#name-registry-understanding-domains-on-solana">Name Registry: Understanding Domains on Solana</a></h1>
<p>Solana can be viewed as a key-value database, where everything, including domains, is uniquely identifiable by a public key. The data inside a domain account contains an object called the Name Registry. The Name Registry is made of a header and payload.</p>
<h2 id="name-registry-explained"><a class="header" href="#name-registry-explained">Name Registry Explained</a></h2>
<center>
<img src="assets/registry.png" alt="name-registry" />
</center>
<h3 id="name-registry-header"><a class="header" href="#name-registry-header">Name Registry Header</a></h3>
<p>The header contains three public keys that define the domain's properties:</p>
<ul>
<li><code>Parent</code>: Represents the parent domain in the hierarchy.</li>
<li><code>Owner</code>: Indicates the entity that has control over the domain.</li>
<li><code>Class</code>: A special key that enables advanced use-cases, such as third-party verification in a badge system.</li>
</ul>
<p>Below is the structure of the header in Rust:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// The layout of the remaining bytes in the account data are determined by the record `class`
#[derive(Clone, Debug, BorshSerialize, BorshDeserialize, PartialEq)]
pub struct NameRecordHeader {
    // Names are hierarchical.  `parent_name` contains the account address of the parent
    // name, or `Pubkey::default()` if no parent exists.
    pub parent_name: Pubkey,

    // The owner of this name
    pub owner: Pubkey,

    // The class of data this account represents (DNS record, twitter handle, SPL Token name/symbol, etc)
    //
    // If `Pubkey::default()` the data is unspecified.
    pub class: Pubkey,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="data-flexible-data-storage"><a class="header" href="#data-flexible-data-storage">Data: Flexible Data Storage</a></h3>
<p>The data section can hold arbitrary binary data. Its length is set during domain registration, and the domain owner can decide what to store in this part of the Name Registry.</p>
<p>In simple terms, the Name Registry data structure provides a way to organize and store information about a domain on Solana, including its relationships, ownership, and any additional data the owner wishes to include.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wallet-guide"><a class="header" href="#wallet-guide">Wallet Guide</a></h1>
<p>This is the step-by-step guide to help wallet providers integrate .sol domain names and Twitter handles as a way to use them to send and receive funds instead of a pubkey.</p>
<p>The guide lays out the process of integrating domains to both Solana and the other blockchains SNS has been bridged to. Specifically, it‚Äôll aid you in understanding the nuanced aspects of resolving tokenized domains, those with record sections and subdomains.</p>
<p>The instructions are structured in a three-part layout:</p>
<p>7.1 <a href="domain-name/wallet-guide//domain-name/wallet-guide/resolving-domains.html">Resolving domains</a>: describes how to integrate domains on Solana</p>
<p>7.2 <a href="domain-name/wallet-guide//domain-name/wallet-guide/bridged-domains.html">Resolving bridged domains</a>: describes how to integrate domains on other chains</p>
<p>7.3 <a href="domain-name/wallet-guide//domain-name/wallet-guide/twitter-handles.html">Resolving Twitter handles</a>: describes how to integrate Twitter handles linked to a pubkey</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-resolve-a-sol-domain-name"><a class="header" href="#how-to-resolve-a-sol-domain-name">How to resolve a .sol domain name?</a></h1>
<blockquote>
<p>üí° To resolve a domain name you can use the <code>resolve</code> function from the SNS SDK</p>
</blockquote>
<p>Below is the correct methodology to resolve <code>.sol</code> domain names. It's <strong>strongly recommended</strong> to use the <code>resolve</code> function from the SNS SDK. If you wish to reimplement the resolution logic on your end please make sure to follow these guidelines to avoid loss of funds.</p>
<p><img src="domain-name/wallet-guide/../../assets/wallet-guide.png" alt="wallet-guide" /></p>
<ol>
<li>
<p>Check if the domain name is tokenized</p>
<ul>
<li><strong>Yes:</strong> The correct destination of funds is the token holder</li>
<li><strong>No:</strong> Go to step 2</li>
</ul>
</li>
<li>
<p>Check the SOL record</p>
<ul>
<li><strong>If</strong> The SOL record V2 is set and the staleness &amp; RoA ID are verified, the public key specified in the record is the correct destination</li>
<li><strong>Else if</strong> the SOL record V1 is set and the signature is valid, the public key specified in the record is the correct destination. If the signature is invalid go to step 3</li>
<li><strong>Else</strong> go to step 3</li>
</ul>
</li>
<li>
<p>The correct destination of funds is the domain owner</p>
</li>
</ol>
<p>A JS implementation can be found on the <a href="https://github.com/SolanaNameService/sns-sdk/blob/3098c811e77e3aae1ad390b5f6bea57b1cfc78c0/js/src/resolve.ts">SDK repository</a></p>
<blockquote>
<p>Not resolving domains properly might lead to loss of funds ‚ö†Ô∏è</p>
</blockquote>
<h2 id="faq-1"><a class="header" href="#faq-1">FAQ</a></h2>
<ol>
<li>What happens if funds are sent to the <code>NameRegistry</code> owner when the domain is tokenized?</li>
</ol>
<p>As long as the user owns the tokenized domains (i.e the NFT) they will be able to withdraw from the PDA escrow that received the funds. However, if for some reason the user does not own the NFT they won't be able to withdraw the funds.</p>
<ol start="2">
<li>Why is there a signature in the SOL record V1?</li>
</ol>
<p>The SOL record V1 data contains a 96-byte array that is the concatenation of a public key (32 bytes) and signature (64 bytes). The first 32 bytes represent the public key (<code>pubkey</code>) to which funds should be sent and the next 64 bytes are the signature of <code>pubkey_as_bytes + record_key_as_bytes</code> signed by the owner of the domain. If the signature is invalid funds <strong>must not</strong> be transferred to the SOL record address.</p>
<p>The signature is required to prevent funds being sent to a stale SOL record after a domain has been transferred or sold to a new owner.</p>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<p>This section provides examples to assist you in testing your implementation. However, they are not exhaustive, therefore, ensure to carry out comprehensive tests beyond these examples. Use them as guidelines and adapt them to suit your specific needs.</p>
<div class="table-wrapper"><table><thead><tr><th>domain</th><th>owner</th></tr></thead><tbody>
<tr><td>wallet-guide-5.sol</td><td>Fxuoy3gFjfJALhwkRcuKjRdechcgffUApeYAfMWck6w8</td></tr>
<tr><td>wallet-guide-4.sol</td><td>Hf4daCT4tC2Vy9RCe9q8avT68yAsNJ1dQe6xiQqyGuqZ</td></tr>
<tr><td>wallet-guide-3.sol</td><td>Fxuoy3gFjfJALhwkRcuKjRdechcgffUApeYAfMWck6w8</td></tr>
<tr><td>wallet-guide-2.sol</td><td>36Dn3RWhB8x4c83W6ebQ2C2eH9sh5bQX2nMdkP2cWaA4</td></tr>
<tr><td>wallet-guide-1.sol</td><td>36Dn3RWhB8x4c83W6ebQ2C2eH9sh5bQX2nMdkP2cWaA4</td></tr>
<tr><td>wallet-guide-0.sol</td><td>Fxuoy3gFjfJALhwkRcuKjRdechcgffUApeYAfMWck6w8</td></tr>
<tr><td>sub-0.wallet-guide-3.sol</td><td>Fxuoy3gFjfJALhwkRcuKjRdechcgffUApeYAfMWck6w8</td></tr>
<tr><td>sub-1.wallet-guide-3.sol</td><td>Hf4daCT4tC2Vy9RCe9q8avT68yAsNJ1dQe6xiQqyGuqZ</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-resolve-a-sol-domain-cross-chain"><a class="header" href="#how-to-resolve-a-sol-domain-cross-chain">How to resolve a .sol domain cross-chain?</a></h1>
<p>The Solana Name Service (SNS) going cross-chain means that it is expanding its functionality beyond the Solana ecosystem, enabling users to export their domain names to alternative blockchains using the <a href="https://wormhole.com/">Wormhole bridge</a>. This move aims to increase the utility and adoption of SNS, while also fostering collaboration and interoperability between different blockchain networks. By allowing SNS domains to be resolved on supported chains like EVM-based chains and Injective, SNS becomes more accessible to a wider range of developers and users, promoting the growth of the Solana ecosystem and showcasing its capabilities beyond its native environment.</p>
<h2 id="evm-chains"><a class="header" href="#evm-chains">EVM Chains</a></h2>
<p>The Solana Name Service has been bridged to the following EVM chains:</p>
<ul>
<li>
<p>BNB Testnet (deployed at <code>0x4d50e149bb3d8c889f4ccdfffba0ef8016168d92</code>)</p>
</li>
<li>
<p>BNB Mainnet (deployed at <code>0xd1Ae42Ce34E6b7ab5B41dcc851424F3cF410BF16</code>)</p>
</li>
<li>
<p>BASESepolia (deployed at <code>0xc0B286f45d2D5D825aD42DcF49CB9eA39899E2c3</code>)</p>
</li>
<li>
<p>BASE (deployed at <code>0x63E2FADb57BEd8A4c9c3C5a4937e7611ec88421F</code>)</p>
</li>
</ul>
<p>Solana domain names bridged on EVM chains can be resolved using the NPM package <a href="https://www.npmjs.com/package/@bonfida/sns-warp-evm">@bonfida/sns-warp-evm</a>.</p>
<h3 id="installation-1"><a class="header" href="#installation-1">Installation</a></h3>
<p>With Yarn:</p>
<pre><code>yarn add @bonfida/sns-warp-evm
</code></pre>
<p>With NPM</p>
<pre><code>npm i @bonfida/sns-warp-evm
</code></pre>
<h3 id="resolving-a-sol-domain"><a class="header" href="#resolving-a-sol-domain">Resolving a .sol domain</a></h3>
<p>The following code can be used to resolve .sol domains on EVM chains</p>
<pre><code class="language-js">import { SupportedChains, SNS } from "@bonfida/sns-warp-evm";

/**
 *
 * BNB Example
 *
 **/

// The domain name to resolve
const domain = "mock3.sol";
// The chain on which to resolve the domain
const targetChain = SupportedChains.BNBMainnet;

const sns = new SNS(SupportedChains.BNBMainnet);
const resolved = await sns.resolveName(domain);

console.log(resolved); // &lt;- 0x1D719d2dB763f905b1924F46a5185e001Dd93786

/**
 *
 * BASE Example
 *
 **/

const sns = new SNS(SupportedChains.BASESepolia);
const resolved = await sns.resolveName("12c8566b3e8ab8b9edac2ceab89be3bd.sol");

console.log(resolved); // &lt;- 0x5f8901Aa3a42BCB53792CfCeDa66a7cf735Af6Db
</code></pre>
<h3 id="reverse-look-up"><a class="header" href="#reverse-look-up">Reverse look up</a></h3>
<pre><code class="language-js">import { SupportedChains, SNS } from "@bonfida/sns-warp-evm";
import { namehash } from "@ethersproject/hash";

// The chain on which to perform the reverse lookup
const targetChain = SupportedChains.BNBMainnet;

const sns = new SNS(targetChain);
const nameHash = namehash("mock3.sol");

const resolved = await sns.resolveReverse(nameHash);
console.log(resolved); // &lt;- mock3
</code></pre>
<h2 id="injective"><a class="header" href="#injective">Injective</a></h2>
<p>The Solana Name Service has also been bridged to Injective.</p>
<ul>
<li>Injective Testnet (deployed at <code>inj1q79ujqyh72p43mhr2ldaly3x6d50rzp3354at3</code>)</li>
<li>Injective Mainnet (deployed at <code>inj1v7chmgm7vmuwldjt80utmw9c95jkrch979ps8z</code>)</li>
</ul>
<p>Solana domain names bridged to Injective can be resolved using the NPM package <a href="https://www.npmjs.com/package/@bonfida/sns-warp-injective">@bonfida/sns-warp-injective</a>.</p>
<p>SNS is also supported by the <a href="https://github.com/leapwallet/name-matcha">Leap Wallet Name Match package</a>.</p>
<h3 id="installation-2"><a class="header" href="#installation-2">Installation</a></h3>
<p>With Yarn:</p>
<pre><code>yarn add @bonfida/sns-warp-injective
</code></pre>
<p>With NPM</p>
<pre><code>npm i @bonfida/sns-warp-injective
</code></pre>
<h3 id="resolving-a-sol-domain-1"><a class="header" href="#resolving-a-sol-domain-1">Resolving a .sol domain</a></h3>
<p>The following code can be used to resolve .sol domains on Injective</p>
<pre><code class="language-js">import { resolveName } from "@bonfida/sns-warp-injective";
import { Network } from "@injectivelabs/networks";

// The domain name to resolve
const domain = "bonfida.sol";
// The network on which to resolve the domain
const network = Network.Mainnet;

const resolved = await resolveName(domain, network);

console.log(resolved); // &lt;- inj1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqe2hm49
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="resolving-twitter-handles"><a class="header" href="#resolving-twitter-handles">Resolving Twitter handles</a></h1>
<p>The Solana name service supports the registration of Twitter handles, allowing users to connect their Twitter profile to their wallet.</p>
<h2 id="direct-look-up"><a class="header" href="#direct-look-up">Direct look up</a></h2>
<p>To find the Twitter handle associated to a public key</p>
<pre><code class="language-js">import { getHandleAndRegistryKey } from "@bonfida/spl-name-service";

const pubkey = new PublicKey("FidaeBkZkvDqi1GXNEwB8uWmj9Ngx2HXSS5nyGRuVFcZ");

const [handle] = await getHandleAndRegistryKey(connection, pubkey);
</code></pre>
<h2 id="reverse-look-up-1"><a class="header" href="#reverse-look-up-1">Reverse look up</a></h2>
<p>To find the public key associated to a Twitter handle</p>
<pre><code class="language-js">import { getTwitterRegistry } from "@bonfida/spl-name-service";

const handle = "bonfida";

const registry = await getTwitterRegistry(connection, handle);
const owner = registry.owner.toBase58();
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="domain-names"><a class="header" href="#domain-names">Domain names</a></h1>
<p>This following sections provide information on the following:</p>
<ul>
<li><a href="domain-name/domain-tld.html">The domain names TLD</a></li>
<li><a href="domain-name/domain-direct-lookup.html">Direct look up</a></li>
<li><a href="domain-name/domain-reverse-lookup.html">Reverse look up</a></li>
<li><a href="domain-name/subdomain-lookup.html">Subdomain look up</a></li>
<li><a href="domain-name/domain-find-for-owner.html">Get all domains of a user</a></li>
<li><a href="domain-name/all-domains.html">Get all domains</a></li>
<li><a href="domain-name/records.html">Records</a></li>
<li><a href="domain-name/transfer.html">Transfer domains</a></li>
<li><a href="domain-name/edit-domain-content.html">Edit domain content</a></li>
<li><a href="domain-name/primary-domains.html">Primary domain</a></li>
<li><a href="domain-name/react-hooks">React hooks</a></li>
<li><a href="domain-name/tokenization.html">Domain name tokenization</a></li>
<li><a href="domain-name/registration.html">Domain registration</a></li>
<li><a href="domain-name/media-kit.html">Media kit</a></li>
<li><a href="domain-name/delete-domain.html">Deleting domains</a></li>
<li><a href="domain-name/create-subdomain.html">Creating subdomains</a></li>
<li><a href="domain-name/sns-examples">Examples</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tld"><a class="header" href="#tld">TLD</a></h1>
<p><img src="domain-name/../assets/hierarchy.png" alt="root-tld" /></p>
<p>In Solana, the hierarchy of domain names and the TLD system is organized similarly to the traditional internet domain structure. The top of the hierarchy is the Root domain, which holds the Top Level Domains (TLDs) like <code>.sol</code>.</p>
<p>Under the Root domain, you have the TLDs, such as <code>.sol</code>. All the domain names registered with the .sol extension are considered children (or subdomains) of the <code>.sol</code> TLD. For example, bonfida.sol is a child of the <code>.sol</code> TLD.</p>
<p>Further down the hierarchy, you can have subdomains of the registered domain names. For instance, <code>dex.bonfida.sol</code> is a child of <code>bonfida.sol</code>.</p>
<p>In simple terms, the hierarchy of Solana domain names starts with the Root domain, followed by TLDs (e.g., <code>.sol</code>), then the registered domain names (e.g., <code>bonfida.sol</code>), and finally any subdomains (e.g., <code>dex.bonfida.sol</code>). This hierarchical structure allows for an organized way to manage and identify domain names on the Solana network.</p>
<h2 id="tld-list"><a class="header" href="#tld-list">TLD list</a></h2>
<ul>
<li>Root TLD: <code>ZoAhWEqTVqHVqupYmEanDobY7dee5YKbQox9BNASZzU</code></li>
<li>.sol TLD: <code>58PwtjSDuFHuUkYjH9BYnnQKHfwo9reZhC2zMJv9JPkx</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="web-resolution"><a class="header" href="#web-resolution">Web resolution</a></h1>
<h2 id="web-resolvers"><a class="header" href="#web-resolvers">Web resolvers</a></h2>
<p>While SNS offers numerous benefits, its separation from the traditional Domain Name System (DNS) can present challenges for adoption and accessibility. To address these challenges, we are building the necessary infrastructure to bridge the gap between SNS and DNS, making it easier for users to interact with SNS through familiar methods.</p>
<p>Below are three such methods for resolving .sol domain names:</p>
<ul>
<li>Natively in the <a href="https://brave.com">Brave browser</a></li>
</ul>
<!-- - Via the [Backpack](https://www.backpack.app) wallet extension -->
<ul>
<li>Through a proxy service called <a href="https://github.com/SolanaNameService/name-resolver">sol-domain.org</a></li>
</ul>
<h3 id="brave-browser"><a class="header" href="#brave-browser">Brave browser</a></h3>
<p>The <a href="https://brave.com">Brave browser</a> supports native resolution of .sol domain names, allowing users to access Solana Name Service domains directly from the URL bar. To resolve an SNS domain in the Brave browser, simply type the domain followed by <code>.sol</code> in the URL bar, and press Enter. For instance, to access the <a href="https://pyth.network/">Pyth network website</a>, you would enter <code>pyth.sol</code> in the URL bar.</p>
<!-- ## Backpack

[Backpack](https://www.backpack.app) is a wallet extension that supports SNS domain resolution. By using Backpack, users can resolve .sol domain names directly from their browser. To resolve a .sol domain with Backpack, simply

- Install the wallet extension
- Enable `Solana` in the `Domain Website Resolver` settings
- Enter the .sol domain you want to resolve directly in the browser's search bar (e.g., `pyth.sol`)
- The Backpack extension will automatically detect the .sol domain and redirect you -->
<h3 id="resolution-via-sol-domainorg-proxy-service"><a class="header" href="#resolution-via-sol-domainorg-proxy-service">Resolution via sol-domain.org Proxy Service</a></h3>
<p>The <a href="https://github.com/SolanaNameService/name-resolver">sol-domain.org</a> service is a proxy that enables users to access SNS domains via the traditional DNS system. To resolve a .sol domain using sol-domain.org, append the domain name to the beginning of the sol-domain.org URL. For example, to resolve the <code>pyth.sol</code> domain, you would enter <a href="https://pyth.sol-domain.org/">https://pyth.sol-domain.org</a> in the URL bar of your browser.</p>
<h2 id="resolving-sol-domain-names-in-practice"><a class="header" href="#resolving-sol-domain-names-in-practice">Resolving .sol domain names in practice</a></h2>
<p>The process for resolving <code>.sol</code> domain names follows a defined set of rules based on different types of records: URL, IPFS, Arweave, and Shadow Drive. The resolution process checks for these records in the specified order until it finds a valid record.</p>
<h3 id="step-by-step-process"><a class="header" href="#step-by-step-process">Step-by-step process</a></h3>
<h4 id="step-1-url-record"><a class="header" href="#step-1-url-record">Step 1: URL Record</a></h4>
<p>First, check if the URL record exists and is valid. If so, this is the website to resolve to. The URL record typically contains the HTTP or HTTPS link to the website hosted on the domain.</p>
<h4 id="step-2-ipfs-record"><a class="header" href="#step-2-ipfs-record">Step 2: IPFS Record</a></h4>
<p>If there is no valid URL record, proceed to check for an IPFS record.</p>
<p>If the IPFS record exists and is valid, the user should be redirected to the corresponding IPFS content via an IPFS gateway. An IPFS gateway acts as a bridge between the traditional web and the IPFS network, allowing browsers that don't natively support IPFS to access IPFS content.</p>
<h4 id="step-3-arweave-record"><a class="header" href="#step-3-arweave-record">Step 3: Arweave Record</a></h4>
<p>If neither a URL nor an IPFS record is found or valid, check for an Arweave record.</p>
<p>If the Arweave record exists and is valid, the user should be redirected to the Arweave content via an Arweave gateway. Similar to the IPFS gateway, an Arweave gateway allows users to access Arweave-hosted content through traditional web browsers.</p>
<h4 id="step-4-shadow-drive-record"><a class="header" href="#step-4-shadow-drive-record">Step 4: Shadow Drive Record</a></h4>
<p>Lastly, if no URL, IPFS, or Arweave records are found or valid, check for a Shadow Drive record.</p>
<p>If the Shadow Drive record exists and is valid, the user should be redirected to the content via a Shadow Drive gateway. Like IPFS and Arweave gateways, a Shadow Drive gateway provides access to Shadow Drive-hosted content for traditional web browsers.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="direct-look-up-1"><a class="header" href="#direct-look-up-1">Direct look up</a></h1>
<p><img src="domain-name/../assets/direct-reverse.png" alt="direct-reverse" /></p>
<p>In order to get the information of a domain name you need to:</p>
<ol>
<li>Get the domain name public key</li>
<li>Retrieve the account info</li>
</ol>
<pre><code class="language-js">import { getDomainKeySync, NameRegistryState } from "@bonfida/spl-name-service";

const domainName = "bonfida"; // With or without the .sol at the end

// Step 1
const { pubkey } = getDomainKeySync(domainName);

// Step 2
// The registry object contains all the info about the domain name
// The NFT owner is of type PublicKey | undefined
const { registry, nftOwner } = await NameRegistryState.retrieve(
  connection,
  pubkey
);

// Subdomain derivation
const subDomain = "dex.bonfida"; // With or without the .sol at the end
const { pubkey: subKey } = getDomainKeySync(subDomain);

// Record derivation (e.g IPFS record)
const record = "IPFS.bonfida"; // With or without the .sol at the end
const { pubkey: recordKey } = getDomainKeySync(record, true);
</code></pre>
<p>The <code>retrieve</code> method returns an object made of two fields:</p>
<ul>
<li><code>registry</code> is of type <code>NameRegistryState</code></li>
<li><code>nftOwner</code> is of type <code>PublicKey | undefined</code>
<ul>
<li>When <code>nftOwner</code> is of type <code>PublicKey</code> it means that the domain is tokenized and the current NFT holder is <code>nftOwner</code>. When a domain is tokenized <code>registry.owner</code> is an escrow account that is program owner. Funds should be sent to <code>nftOwner</code></li>
<li>When <code>nftOwner</code> is of type <code>undefined</code> it means that the domain is not tokenized and funds should be sent to <code>registry.owner</code></li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>Note:</strong> <code>NameRegistryState.retrieveBatch</code> can be used to retrieve multiple name registries at once. Pass the connection, and an array of domain name public keys as arguments to the function.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reverse-look-up-2"><a class="header" href="#reverse-look-up-2">Reverse look up</a></h1>
<p><img src="domain-name/../assets/direct-reverse.png" alt="direct-reverse" /></p>
<p>If you know the public key of a domain name registry and want to get the human readable name, you need to perform a <strong>reverse lookup</strong>.</p>
<p>The following code can be used to resolve the domain name from its public key:</p>
<pre><code class="language-js">import { reverseLookup } from "@bonfida/spl-name-service";

// Public key of bonfida.sol
const domainKey = new PublicKey("Crf8hzfthWGbGbLTVCiqRqV5MVnbpHB1L9KQMd6gsinb");

const domainName = await reverseLookup(connection, domainKey); // bonfida
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="get-all-domains-of-a-user"><a class="header" href="#get-all-domains-of-a-user">Get all domains of a user</a></h1>
<p>If you are using <code>@bonfida/spl-name-service</code> you can use the following code:</p>
<pre><code class="language-js">import { getAllDomains } from "@bonfida/spl-name-service";

// ...

const domains = await getAllDomains(connection, user);
</code></pre>
<p>The function above will return an array of public keys. Use the toBase58() method to convert the public keys into base 58 encoded strings.</p>
<pre><code class="language-js">domains.map((domain) =&gt; domain.toBase58());
</code></pre>
<p>Another option to retrieve public keys, as well as their corresponding domain names in a string format is to use the function below from the spl-name-service library. The function will return an array of objects including public keys, and their corresponding strings.</p>
<pre><code class="language-js">const domainsWithReverses = await getDomainKeysWithReverses(connection, user);
</code></pre>
<p>If you opt not to use the spl-name-service library, you can manually retrieve all the domain names of a user with the following <code>MemcmpFilter</code> while querying the Solana blockchain.</p>
<pre><code class="language-js">const filters = [
  {
    memcmp: {
      offset: 32,
      bytes: user.toBase58(),
    },
  },
  {
    memcmp: {
      offset: 0,
      bytes: ROOT_DOMAIN_ACCOUNT.toBase58(),
    },
  },
];
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="get-all-domain-names"><a class="header" href="#get-all-domain-names">Get all domain names</a></h1>
<p>You can retrieve all the registered domain names using a <code>getProgramAccounts</code> request with the following RPC filter</p>
<pre><code class="language-js">const filters = [
  {
    memcmp: {
      offset: 0,
      bytes: ROOT_DOMAIN_ACCOUNT.toBase58(),
    },
  },
];
</code></pre>
<p>If you are using <code>@bonfida/spl-name-service</code> you can use the following code:</p>
<pre><code class="language-js">import { getAllRegisteredDomains } from "@bonfida/spl-name-service";

// ...

const registeredDomains = await getAllRegisteredDomains(connection);
</code></pre>
<p>To avoid enormous payload response, <code>getAllRegisteredDomains</code> slices the data to only return the owner of the domain (i.e <code>dataSlice = { offset: 32, length: 32 }</code>)</p>
<pre><code class="language-js">/**
 * This function can be used to retrieve all the registered `.sol` domains.
 * The account data is sliced to avoid enormous payload and only the owner is returned
 * @param connection The Solana RPC connection object
 * @returns
 */
export const getAllRegisteredDomains = async (connection: Connection) =&gt; {
  const filters = [
    {
      memcmp: {
        offset: 0,
        bytes: ROOT_DOMAIN_ACCOUNT.toBase58(),
      },
    },
  ];
  const dataSlice = { offset: 32, length: 32 };

  const accounts = await connection.getProgramAccounts(NAME_PROGRAM_ID, {
    dataSlice,
    filters,
  });
  return accounts;
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="records"><a class="header" href="#records">Records</a></h1>
<p>In addition to typical DNS records (A, AAAA, TXT, MX, etc.), the Solana Name Service introduces brand new web3-specific types. The following table will be updated as new protocols are integrated.</p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Value</th></tr></thead><tbody>
<tr><td>IPFS</td><td>An IPFS CID</td></tr>
<tr><td>ARWV</td><td>An Arweave address</td></tr>
<tr><td>SOL</td><td>A concatenation of a public key and a signature</td></tr>
<tr><td>ETH</td><td>An ETH public key</td></tr>
<tr><td>BTC</td><td>A BTC public key</td></tr>
<tr><td>LTC</td><td>An LTC public key</td></tr>
<tr><td>DOGE</td><td>A DOGE public key</td></tr>
<tr><td>email</td><td>An email address</td></tr>
<tr><td>url</td><td>A website URL</td></tr>
<tr><td>discord</td><td>A discord username</td></tr>
<tr><td>github</td><td>A github username</td></tr>
<tr><td>reddit</td><td>A reddit username</td></tr>
<tr><td>twitter</td><td>A twitter username</td></tr>
<tr><td>telegram</td><td>A telegram username</td></tr>
<tr><td>pic</td><td>A profile picture</td></tr>
<tr><td>SHDW</td><td>A Shadow drive address</td></tr>
<tr><td>POINT</td><td>A Point network record</td></tr>
<tr><td>BSC</td><td>A BSC public key</td></tr>
<tr><td>INJ</td><td>A Cosmos (Injective) public key</td></tr>
<tr><td>backpack</td><td>A Backpack username</td></tr>
</tbody></table>
</div>
<h2 id="record-enum"><a class="header" href="#record-enum">Record enum</a></h2>
<p>The following <code>enum</code> is exported from <code>@bonfida/spl-name-service</code></p>
<pre><code class="language-js">export enum Record {
  IPFS = "IPFS",
  ARWV = "ARWV",
  SOL = "SOL",
  ETH = "ETH",
  BTC = "BTC",
  LTC = "LTC",
  DOGE = "DOGE",
  Email = "email",
  Url = "url",
  Discord = "discord",
  Github = "github",
  Reddit = "reddit",
  Twitter = "twitter",
  Telegram = "telegram",
  Pic = "pic",
  SHDW = "SHDW",
  POINT = "POINT",
  BSC = "BSC",
  Injective = "INJ",
  Backpack = "backpack",
}
</code></pre>
<h2 id="gateway"><a class="header" href="#gateway">Gateway</a></h2>
<p>The following records can be resolved in browser using <a href="https://sol-domain.org">https://sol-domain.org</a>:</p>
<ul>
<li><code>Url</code></li>
<li><code>IPFS</code></li>
<li><code>ARWV</code></li>
<li><code>SHDW</code></li>
</ul>
<p>The implementation of this resolver can be found <a href="https://github.com/SolanaNameService/name-resolver">on Github</a></p>
<blockquote>
<p>For example <a href="https://bonfida.sol-domain.org">https://bonfida.sol-domain.org</a></p>
</blockquote>
<h2 id="records-v1--v2"><a class="header" href="#records-v1--v2">Records V1 &amp; V2</a></h2>
<p>There are notable differences between Records V1 and V2. Records V1 use a derivation prefix of <code>0x01</code> and encode their content based on the <a href="https://github.com/SolanaNameService/sns-ip/blob/master/proposals/sns-ip-1.md">SNS-IP-1 guidelines</a>. In response to challenges related to data authenticity and staleness issues prevalent in V1, Records V2 was introduced. V2 employs a class in the derivation and a distinct encoding schema detailed in <a href="https://github.com/SolanaNameService/sns-ip/blob/master/proposals/sns-ip-3.md">SNS-IP-3</a>. Records V2 incorporates a validation ID system to ensure data integrity and freshness. Importantly, due to the distinct derivation, Records V1 and V2 can co-exist without collisions. However, the goal of the ecosystem is a complete migration to Records V2.</p>
<h2 id="difference-between-records-and-subdomains"><a class="header" href="#difference-between-records-and-subdomains">Difference between records and subdomains</a></h2>
<p>In practice, let us consider the name <code>foo.sol</code> . If we want to find the domain's A record, containing an associated IPv4 address, then we can find it by querying <code>\1A.foo.sol</code>, with \1 the character of code value 1. The specification makes use of this prefix in order to differentiate between actual domains and records, which means that it is still possible to use the <code>A.foo.sol</code> subdomain with no collision.</p>
<blockquote>
<p><strong>Note:</strong> <code>\0</code> and <code>\1</code> are convenient notations for:</p>
<ul>
<li><code>\0 = \x00</code>.</li>
<li><code>\1 = \x01</code>.</li>
</ul>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="records-v1"><a class="header" href="#records-v1">Records V1</a></h1>
<p><strong>V1 records are deprecated. For current V2 records please see <a href="domain-name/records/./records-v2.html">Records V2</a>.</strong></p>
<h2 id="record-v1-derivation"><a class="header" href="#record-v1-derivation">Record V1 derivation</a></h2>
<p>Record keys can be derived with the <code>getDomainKey</code> function and the <code>record</code> flag set to <code>true</code></p>
<pre><code class="language-js">const record = Record.IPFS + "." + "bonfida"; // With or without the .sol at the end
const { pubkey: recordKey } = await getDomainKey(record, true);
</code></pre>
<blockquote>
<p>If the <code>record</code> flag is set to <code>false</code>, the <code>getDomainKey</code> function will derive the key of the subdomain</p>
</blockquote>
<h2 id="resolving-records-v1"><a class="header" href="#resolving-records-v1">Resolving records V1</a></h2>
<p>The following resolving functions are exported:</p>
<ul>
<li><code>getIpfsRecord</code>: This function can be used to retrieve the IPFS record of a domain name</li>
<li><code>getArweaveRecord</code>: This function can be used to retrieve the Arweave record of a domain name</li>
<li><code>getSolRecord</code>: This function can be used to retrieve the SOL record of a domain name</li>
<li><code>getEthRecord</code>: This function can be used to retrieve the ETH record of a domain name</li>
<li><code>getBtcRecord</code>: This function can be used to retrieve the BTC record of a domain name</li>
<li><code>getLtcRecord</code>: This function can be used to retrieve the LTC record of a domain name</li>
<li><code>getDogeRecord</code>: This function can be used to retrieve the DOGE record of a domain name</li>
<li><code>getEmailRecord</code>: This function can be used to retrieve the email record of a domain name</li>
<li><code>getUrlRecord</code>: This function can be used to retrieve the URL record of a domain name</li>
<li><code>getDiscordRecord</code>: This function can be used to retrieve the Discord record of a domain name</li>
<li><code>getGithubRecord</code>: This function can be used to retrieve the Github record of a domain name</li>
<li><code>getRedditRecord</code>: This function can be used to retrieve the Reddit record of a domain name</li>
<li><code>getTwitterRecord</code>: This function can be used to retrieve the Twitter record of a domain name</li>
<li><code>getTelegramRecord</code>: This function can be used to retrieve the Telegram record of a domain name</li>
<li><code>getShdwRecord</code>: This function can be used to retrieve the SHDW record of a domain name</li>
<li><code>getBscRecord</code>: This function can be used to retrieve the BSC record of a domain name</li>
<li><code>getInjectiveRecord</code>: This function can be used to retrieve the Cosmos Injective record of a domain name</li>
<li><code>getBackpackRecord</code>: This function can be used to retrieve the Backpack record of a domain name</li>
</ul>
<p>All functions have the following signature</p>
<pre><code class="language-js">(connection: Connection, domain: string) =&gt; Promise&lt;NameRegistryState&gt;
</code></pre>
<p>A more generic resolving function <code>getRecord</code> is also exported with the following signature</p>
<pre><code class="language-js">(connection: Connection, domain: string, record: Record) =&gt; Promise&lt;NameRegistryState&gt;
</code></pre>
<h2 id="editing-records-v1"><a class="header" href="#editing-records-v1">Editing records V1</a></h2>
<p>Below is a NodeJS example of how to create and edit a record</p>
<pre><code class="language-js">import {
  Connection,
  TransactionInstruction,
  Keypair,
  clusterApiUrl,
} from "@solana/web3.js";
import {
  Record,
  getDomainKey,
  createNameRegistry,
  NameRegistryState,
  updateInstruction,
  NAME_PROGRAM_ID,
  Numberu32,
} from "@bonfida/spl-name-service";
import { signAndSendInstructions } from "@bonfida/utils";

const connection = new Connection(clusterApiUrl("mainnet-beta"), "processed");
const wallet = Keypair.fromSecretKey(...);

// bonfida.sol
const domain = "bonfida"; // With or without the .sol at the end

// The IPFS record of bonfida.sol
const record = Record.IPFS;

const update = async () =&gt; {
  const ixs: TransactionInstruction[] = [];
  const { pubkey: domainKey } = await getDomainKey(domain);
  const { pubkey: recordKey } = await getDomainKey(record + "." + domain, true);

  const recordAccInfo = await connection.getAccountInfo(recordKey);

  if (!recordAccInfo?.data) {
    // The record does not exist so create it first
    const space = 2_000;
    const lamports = await connection.getMinimumBalanceForRentExemption(
      space + NameRegistryState.HEADER_LEN
    );
    const ix = await createNameRegistry(
      connection,
      Buffer.from([1]).toString() + record,
      space,
      wallet.publicKey,
      wallet.publicKey,
      lamports,
      undefined,
      domainKey
    );
    ixs.push(ix);
  }

  const ix = updateInstruction(
    NAME_PROGRAM_ID,
    recordKey,
    new Numberu32(0),
    Buffer.from("Some IPFS CID"),
    wallet.publicKey
  );

  ixs.push(ix);

  const tx = await signAndSendInstructions(connection, [], wallet, ixs);
  console.log(`Updated record ${tx}`);
};

update();
</code></pre>
<h2 id="deleting-a-record-v1"><a class="header" href="#deleting-a-record-v1">Deleting a record V1</a></h2>
<p>Records can be deleted using the <code>deleteInstruction</code> function, below is a NodeJS example</p>
<pre><code class="language-js">import { Connection, Keypair, clusterApiUrl } from "@solana/web3.js";
import {
  Record,
  getDomainKey,
  NAME_PROGRAM_ID,
  deleteInstruction,
} from "@bonfida/spl-name-service";
import { signAndSendInstructions } from "@bonfida/utils";

const domain = "bonfida.sol"; // With or without .sol

const record = Record.IPFS;

const connection = new Connection(clusterApiUrl("mainnet-beta"), "processed");

const wallet = Keypair.fromSecretKey(...) // Your wallet owning the domain

const deleteRecord = async () =&gt; {
  const { pubkey: recordKey } = await getDomainKey(record + "." + domain, true);

  const ix = deleteInstruction(
    NAME_PROGRAM_ID,
    recordKey,
    wallet.publicKey,
    wallet.publicKey
  );

  const tx = await signAndSendInstructions(connection, [], wallet, [ix]);

  console.log(`Deleted record ${tx}`);
};

deleteRecord();
</code></pre>
<h2 id="the-sol-record-v1"><a class="header" href="#the-sol-record-v1">The SOL record V1</a></h2>
<p>The SOL record can be used to receive funds to a different address than the one owning the domain. This allows people to hold the domain on a cold wallet while being able to receive funds on a hot wallet.</p>
<p>The SOL record data contains a 96-byte array that is the concatenation of a public key (32 bytes) and signature (64 bytes). The first 32 bytes represent the public key (<code>pubkey</code>) to which funds should be sent and the next 64 bytes are the signature of <code>pubkey_as_bytes + record_key_as_bytes</code> by the owner of the domain. If the signature is invalid funds <strong>must not</strong> be transferred.</p>
<p>The signature is required to prevent funds being sent to a stale SOL record after a domain has been transferred or sold.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="records-v2"><a class="header" href="#records-v2">Records V2</a></h1>
<p>Records V2 improves on-chain trust by introducing the <code>verifyStaleness</code> method to ensure records are not stale, and the <code>verifyRightOfAssociation</code> to ensure records are authentic. These functions are described in detail below.</p>
<ul>
<li>Related to <a href="https://github.com/SolanaNameService/sns-ip/blob/master/proposals/sns-ip-2.md">SNS-IP-2</a> and <a href="https://github.com/SolanaNameService/sns-ip/blob/master/proposals/sns-ip-3.md">SNS-IP-3</a></li>
</ul>
<h2 id="record-v2-derivation"><a class="header" href="#record-v2-derivation">Record V2 derivation</a></h2>
<p>V2 Record keys can be derived with the <code>getRecordV2Key</code> function.</p>
<pre><code class="language-js">const domain = "bonfida"; // With or without the .sol at the end
const record = Record.IPFS; // Import the Record enum from the spl-name-service library

const recordV2Key = getRecordV2Key(domain, record);
</code></pre>
<h2 id="verify-staleness"><a class="header" href="#verify-staleness">Verify Staleness</a></h2>
<p>You're able to verify the staleness of a record with Records V2. A record is stale when it was set up by a previous domain owner, and is no longer relevant to the current owner. The function returns a boolean indicating if the record is fresh or not.</p>
<pre><code class="language-js">const freshRecord = await verifyStaleness(connection, record, domain);
</code></pre>
<h2 id="verify-right-of-association"><a class="header" href="#verify-right-of-association">Verify Right of Association</a></h2>
<p>You're also able to verify the authenticity of a record with Records V2 using the <code>verifyRightOfAssociation</code> function. The function returns a boolean indicating if the record is authentic or not. Unique to this function is the verifier parameter, which is the known public key of the on-chain/off-chain oracle used to verify authenticity of a record. This is currently supported for SOL, ETH, INJ, BNB, URL, and CNAME records with support for further records on the way.</p>
<pre><code class="language-js">const verifier = GUARDIANS.get(Record.URL); // Import GUARDIANS from the spl-name-service library

const ROA = await verifyRightOfAssociation(
  connection,
  record,
  domain,
  verifier.toBuffer()
);
</code></pre>
<p>ETH, SOL, BNB, and INJ records are unique because they are self signing. To verify the authenticity of these records, we must pass the content of the record itself as the verifier agrument to the <code>verifyRightOfAssociation</code> function.</p>
<pre><code class="language-js">const { retrievedRecord } = await getRecordV2(connection, domain, record); // Import getRecordV2 from the spl-name-service library

const ROA = await verifyRightOfAssociation(
  connection,
  record,
  domain,
  retrievedRecord.getContent()
);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="edit-domain-content"><a class="header" href="#edit-domain-content">Edit domain content</a></h1>
<p>To write data in a domain registry you can use the following code:</p>
<pre><code class="language-js">import {
  updateNameRegistryData,
  ROOT_DOMAIN_ACCOUNT,
} from "@bonfida/spl-name-service";

const data = Buffer.from("Hello, world!");

// The offset to which the data should be written into the registry, usually 0
const offset = 0;

const ix = await updateNameRegistryData(
  connection,
  name,
  offset,
  data,
  undefined,
  ROOT_DOMAIN_ACCOUNT
);

// sign and send instruction
</code></pre>
<p>If the data is too large to fit in a single transaction, you will have to update the domain in several transaction by slicing the buffer and increasing the offset accordingly.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="transfer-domain"><a class="header" href="#transfer-domain">Transfer domain</a></h1>
<p>Domain names can be transferred using the <code>transferNameOwnership</code> instruction:</p>
<pre><code class="language-js">import {
  transferNameOwnership,
  NameRegistryState,
  ROOT_DOMAIN_ACCOUNT,
} from "@bonfida/spl-name-service";

// ..

// Domain name to transfer
const domain = "bonfida";

// New owner of the domain
const newOwner = new PublicKey("...");

const ix = await transferNameOwnership(
  connection,
  domain,
  newOwner,
  undefined,
  ROOT_DOMAIN_ACCOUNT
);

// sign and send instruction
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="primary-domain"><a class="header" href="#primary-domain">Primary domain</a></h1>
<blockquote>
<p>üí° Primary domains used to be called favorite domains. The change was made in version 3.0.0 of the SDK</p>
</blockquote>
<p>Users have the possibility to select a domain name as their primary one. If you are a developer and want to integrate SNS to your DApp it's recommended to always use the primary domain name to replace the user's public key.</p>
<h2 id="get-multiple-primary-domains"><a class="header" href="#get-multiple-primary-domains">Get Multiple Primary Domains</a></h2>
<p>To retrieve primary domains for a group of up to 100 users, we've created the <code>getMultiplePrimaryDomains</code> function in our JavaScript SDK. This function is optimized for network efficiency, making only four RPC calls, three of which are executed in parallel. The function returns a promise that resolves to an array of strings or undefined representing the primary domain, or lack thereof for each wallet passed to the function.</p>
<pre><code class="language-js">import { getMultiplePrimaryDomains } from "@bonfida/spl-name-service";

const wallets = [
  new PublicKey("3ogYncmMM5CmytsGCqKHydmXmKUZ6sGWvizkzqwT7zb1"),
  new PublicKey("FMmaHPDL47V1gXsfh9WjgAT7Er3dfDvarQubTU1Jxc1r"),
  // Public Keys of all the wallet addresses you're looking up a primary domain for (up to 100)
];

const primaryDomains = await getMultiplePrimaryDomains(connection, wallets);
</code></pre>
<h2 id="get-single-primary-domain"><a class="header" href="#get-single-primary-domain">Get Single Primary Domain</a></h2>
<p>The primary domain name of a single user can be retrieved with the code below.</p>
<pre><code class="language-js">import { getPrimaryDomain } from "@bonfida/spl-name-service";

// ...

const { domain, reverse } = await getPrimaryDomain(connection, user);
</code></pre>
<p><code>getPrimaryDomain</code> returns the following:</p>
<ul>
<li><code>domain</code>: The public key of the primary domain name</li>
<li><code>reverse</code>: The reverse look up of the account</li>
</ul>
<p>For instance for <a href="https://sns.id/profile/FidaeBkZkvDqi1GXNEwB8uWmj9Ngx2HXSS5nyGRuVFcZ">FidaeBkZkvDqi1GXNEwB8uWmj9Ngx2HXSS5nyGRuVFcZ</a>:</p>
<ul>
<li><code>domain = Crf8hzfthWGbGbLTVCiqRqV5MVnbpHB1L9KQMd6gsinb</code></li>
<li><code>reverse = bonfida</code></li>
</ul>
<h2 id="get-all-primary-domains"><a class="header" href="#get-all-primary-domains">Get All Primary Domains</a></h2>
<p>To get all primary domains currently existence, you can use the SNS API endpoint below.</p>
<pre><code>GET /v2/domains/all-primary
</code></pre>
<p>This endpoint returns all primary domains that have been registered.</p>
<h3 id="request"><a class="header" href="#request">Request</a></h3>
<p>No parameters are required for this request.</p>
<h3 id="response"><a class="header" href="#response">Response</a></h3>
<p>The response is a JSON object where each key is a wallet public key and the value is an object containing the following properties:</p>
<ul>
<li>domain: The primary domain name associated with the public key.</li>
<li>owner: The public key of the owner of the domain.</li>
<li>domain_key: The key associated with the domain.</li>
</ul>
<p>Example response:</p>
<pre><code>{
  "5J9BeWAZGekH71Huiro2qW6AJXSeBj7zPsHniKkmjToY": {
    "domain": "hansolana",
    "owner": "5J9BeWAZGekH71Huiro2qW6AJXSeBj7zPsHniKkmjToY",
    "domain_key": "7mNYJ8UL8YV7dpPjCREXgUaoyyULmmZxxo1raT4w9kKS"
  }
}
</code></pre>
<h3 id="caching"><a class="header" href="#caching">Caching</a></h3>
<p>This endpoint is cached and may lag behind the blockchain by a few minutes. For mission-critical resolution, it is recommended not to use this endpoint and instead use the blockchain directly. However, for simple UI applications, this endpoint is perfectly suitable.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="react-hooks-1"><a class="header" href="#react-hooks-1">React hooks</a></h1>
<p>The list below show how to implement your own React hooks using vanilla React. For production, it's recommended to use the <a href="https://www.npmjs.com/package/@bonfida/sns-react">React hooks library</a>.</p>
<ol>
<li><a href="domain-name/react-hooks//domain-name/react-hooks/use-domains.html">useDomains</a></li>
<li><a href="domain-name/react-hooks//domain-name/react-hooks/use-domain-records.html">useDomainRecords</a></li>
<li><a href="domain-name/react-hooks//domain-name/react-hooks/use-domains-for-user.html">useDomainsForUser</a></li>
<li><a href="domain-name/react-hooks//domain-name/react-hooks/use-primary-domain.html">usePrimaryDomain</a></li>
<li><a href="domain-name/react-hooks//domain-name/react-hooks/use-profile-pic.html">useProfilePic</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="usedomains"><a class="header" href="#usedomains">useDomains</a></h1>
<p>This hook can be used to resolve several domain names:</p>
<pre><code class="language-ts">import { getDomainKey, NameRegistryState } from "@bonfida/spl-name-service";
import { useEffect, useState, useRef } from "react";

type Result = (NameRegistryState | undefined)[] | undefined;

/**
 * This hook can be used to resolve several domain names
 * @param domains List of domains to resolve e.g ["bonfida", "serum"]
 * @returns
 */
export const useDomains = (domains: string[]) =&gt; {
  const { connection } = useConnection();
  const [result, setResult] = useState&lt;Result&gt;(undefined);
  const mounted = useRef(true);

  useEffect(() =&gt; {
    const fn = async () =&gt; {
      const keys = await Promise.all(domains.map((e) =&gt; getDomainKey(e)));

      const registries = await NameRegistryState.retrieveBatch(
        connection,
        keys.map((e) =&gt; e.pubkey)
      );

      if (mounted.current) {
        setResult(registries);
      }

      return () =&gt; (mounted.current = false);
    };

    fn().catch(console.error);
  }, [...domains]);

  return result;
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="userecords"><a class="header" href="#userecords">useRecords</a></h1>
<p>This hook can be used to retrieve all the V1 records of a domain. <strong>Please note, V1 records are deprecated. For current V2 records check out <a href="domain-name/react-hooks/./use-records-V2.html">useRecordsV2</a>.</strong></p>
<pre><code class="language-ts">type Result = (string | undefined)[] | undefined;

/**
 * This hook can be used to retrieve all the records of a domain
 * @param domains Domains to resolve records for e.g "bonfida"
 * @returns
 */
export const useRecords = (domain: string) =&gt; {
  const { connection } = useConnection();
  const [result, setResult] = useState&lt;Result&gt;(undefined);
  const mounted = useRef(true);

  useEffect(() =&gt; {
    const fn = async () =&gt; {
      const recordsKeys = Object.keys(Record).map((e) =&gt; Record[e]);

      const keys = await Promise.all(
        recordsKeys.map((e) =&gt; getDomainKey(e + "." + domain, true))
      );

      const registries = await NameRegistryState.retrieveBatch(
        connection,
        keys.map((e) =&gt; e.pubkey)
      );

      // Remove trailling 0s
      const records = registries.map((e) =&gt; {
        if (e?.data) {
          const idx = e.data?.indexOf(0x00);
          e.data = e.data?.slice(0, idx);

          return e.data.toString();
        }
        // Record is not defined
        return undefined;
      });

      if (mounted.current) {
        setResult(records);
      }

      return () =&gt; (mounted.current = false);
    };

    fn().catch(console.error);
  }, [domain]);

  return result;
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="userecordsv2"><a class="header" href="#userecordsv2">useRecordsV2</a></h1>
<p>This hook returns the serialized or deserialized V2 records of the given domain name.</p>
<pre><code class="language-ts">type Result = (string | undefined)[] | undefined;

/**
 * Returns the deserialized (or not) records V2 of the given domain name
 * @param connection The Solana RPC connection object
 * @param domain The domain name
 * @param records The list of records to fetch
 * @param deserialize Whether to deserialize the record content or not. Deserialization is done according to SNS IP-1
 * @returns Returns a list of records' content
 */

export const useRecordsV2 = (
  connection: Connection,
  domain: string,
  records: Record[],
  deserialize?: boolean
) =&gt; {
  return useAsync(async () =&gt; {
    // useAsync from the react-async-hook library
    const res = await getMultipleRecordsV2(connection, domain, records, {
      deserialize,
    });
    return res;
  }, [domain, ...records]);
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="usedomainsforuser"><a class="header" href="#usedomainsforuser">useDomainsForUser</a></h1>
<p>This hook can be used to retrieve all the domains owned by a user:</p>
<pre><code class="language-ts">interface Result {
  pubkey: PublicKey;
  registry: NameRegistryState;
  reverse: string;
}

/**
 * This hook can be used to retrieve all the domains of a user
 * @param user The user to search domains for
 * @returns
 */
export const useDomainsForUser = (user: PublicKey) =&gt; {
  const { connection } = useConnection();
  const [result, setResult] = useState&lt;Result[] | undefined&gt;(undefined);
  const mounted = useRef(true);

  useEffect(() =&gt; {
    const fn = async () =&gt; {
      const domains = await getAllDomains(connection, user);
      const registries = await NameRegistryState.retrieveBatch(connection, [
        ...domains,
      ]);
      const reverses = await reverseLookupBatch(connection, [...domains]);
      const _result: Result[] = [];
      for (let i = 0; i &lt; domains.length; i++) {
        _result.push({
          pubkey: domains[i],
          registry: registries[i]!,
          reverse: reverses[i]!,
        });
      }
      if (mounted.current) {
        setResult(_result);
      }

      return () =&gt; (mounted.current = false);
    };

    fn().catch(console.error);
  }, [user.toBase58()]);

  return result;
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="useprimarydomain"><a class="header" href="#useprimarydomain">usePrimaryDomain</a></h1>
<blockquote>
<p>üí° Primary domains used to be called favorite domains.</p>
</blockquote>
<p>Primary domains allow users who own several domains to select one of them as their default identity.</p>
<p><strong>This primary domain should be used by default by dApps.</strong></p>
<pre><code class="language-ts">import { useEffect, useRef, useState } from "react";
import { useConnection } from "@solana/wallet-adapter-react";
import { PublicKey } from "@solana/web3.js";
import { reverseLookup } from "@bonfida/spl-name-service";
import { FavouriteDomain, NAME_OFFERS_ID } from "@bonfida/name-offers";

type Result = string | undefined;

export const usePrimaryDomain = (user: PublicKey) =&gt; {
  const { connection } = useConnection();
  const [result, setResult] = useState&lt;Result&gt;(undefined);
  const mounted = useRef(true);

  useEffect(() =&gt; {
    const fn = async () =&gt; {
      const [favKey] = await FavouriteDomain.getKey(NAME_OFFERS_ID, user);
      const favourite = await FavouriteDomain.retrieve(connection, favKey);

      const reverse = await reverseLookup(connection, favourite.nameAccount);

      if (mounted.current) {
        setResult(reverse);
      }

      return () =&gt; (mounted.current = false);
    };

    fn().catch(console.error);
  }, [user.toBase58()]);

  return result;
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="useprofilepic"><a class="header" href="#useprofilepic">useProfilePic</a></h1>
<p>Users can set a profile picture using the <code>pic</code> record of their primary domain name. This record holds the URI to their profile picture.</p>
<pre><code class="language-ts">import { useEffect, useRef, useState } from "react";
import { useConnection } from "@solana/wallet-adapter-react";
import { PublicKey } from "@solana/web3.js";
import { getDomainKey, NameRegistryState } from "@bonfida/spl-name-service";

export const useProfilePic = (user: PublicKey) =&gt; {
  const { connection } = useConnection();
  const primary = usePrimaryDomain(user);
  const [result, setResult] = useState&lt;Result&gt;(undefined);
  const mounted = useRef(true);

  useEffect(() =&gt; {
    const fn = async () =&gt; {
      if (!primary) {
        return setResult(undefined);
      }

      const registry = await getPicRecord(connection, primary.toBase58());

      if (!registry.data) {
        return setResult(undefined);
      }

      if (mounted.current) {
        setResult(registry.data.toString("utf-8"));
      }

      return () =&gt; (mounted.current = false);
    };

    fn().catch(console.error);
  }, [user.toBase58(), primary]);

  return result;
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vue-sdk-1"><a class="header" href="#vue-sdk-1">Vue SDK</a></h1>
<p>The package <code>@bonfida/sns-vue</code> contains a set of useful Vue composables to help you integrate SNS into your dApp. A fully working Vue app can be found on <a href="https://github.com/SolanaNameService/sns-sdk/tree/main/examples/vue-app">Github</a> with a working example for each of the composable:</p>
<ul>
<li><a href="https://github.com/SolanaNameService/sns-sdk/blob/main/examples/vue-app/src/components/examples/useDomainOwner.vue">useDomainOwner</a></li>
<li><a href="https://github.com/SolanaNameService/sns-sdk/blob/main/examples/vue-app/src/components/examples/useDomainSize.vue">useDomainSize</a></li>
<li><a href="https://github.com/SolanaNameService/sns-sdk/blob/main/examples/vue-app/src/components/examples/useDomainsForOwner.vue">useDomainsForOwner</a></li>
<li><a href="https://github.com/SolanaNameService/sns-sdk/blob/main/examples/vue-app/src/components/examples/useFavoriteDomain.vue">usePrimaryDomain</a></li>
<li><a href="https://github.com/SolanaNameService/sns-sdk/blob/main/examples/vue-app/src/components/examples/useProfilePic.vue">useProfilePic</a></li>
<li><a href="https://github.com/SolanaNameService/sns-sdk/blob/main/examples/vue-app/src/components/examples/useRecords.vue">useRecords</a></li>
<li><a href="https://github.com/SolanaNameService/sns-sdk/blob/main/examples/vue-app/src/components/examples/useReverseLookup.vue">useReverseLookup</a></li>
<li><a href="https://github.com/SolanaNameService/sns-sdk/blob/main/examples/vue-app/src/components/examples/useSubdomains.vue">useSubdomains</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tokenization"><a class="header" href="#tokenization">Tokenization</a></h1>
<p>Domain names are <strong>not</strong> SPL tokens, however, they can be tokenized in NFTs that follow the Metaplex standard. It's only recommended to tokenize your domain if you want to resell your domain on an NFT market place like <a href="https://magiceden.io/marketplace/sns">Magic Eden</a> and <a href="https://www.tensor.trade/trade/sns">Tensor</a>.</p>
<h2 id="js-example"><a class="header" href="#js-example">JS example</a></h2>
<p>To retrieve all currently tokenized domain names use the <code>retrieveNfts</code> function. This function returns an array of currently tokenized domains as public keys, and contains all the mints of the tokenized domain name.</p>
<pre><code class="language-js">import { retrieveNfts } from "@bonfida/spl-name-service";

const nfts = await retrieveNfts(connection);
</code></pre>
<p>To retrieve all of the tokenized domain names of a specific owner use <code>getTokenizedDomains</code>. Function returns an array of public keys, their reverses, and mints.</p>
<pre><code class="language-js">import { getTokenizedDomains } from "@bonfida/spl-name-service";

const tokenizedDomains = await getTokenizedDomains(connection, owner);
</code></pre>
<p>To retrieve the public key of the owner of a specific NFT that represents a tokenized domain name, use the retrieveNftOwner function.</p>
<pre><code class="language-js">import { retrieveNftOwner } from "@bonfida/spl-name-service";

const owner = await retrieveNftOwner(connection, nameKey);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="registration"><a class="header" href="#registration">Registration</a></h1>
<blockquote>
<p><strong>Deprecated:</strong> The <code>registerDomainName</code> function is being deprecated as it relies on the older Pyth smart contract on Solana, which is scheduled to be sunsetted at the end of May 2024. Please transition to using <code>registerDomainNameV2</code> for future domain registrations.</p>
</blockquote>
<p>Easily integrate SNS domain registrations into your applications using our SNS Widget React Component. See a default usage example below. You can also customize the widget to fit your unique needs. More information is available here: https://github.com/Bonfida/sns-widget/blob/main/README.md</p>
<pre><code class="language-js">import Widget from "@bonfida/sns-widget";
// Apart from the component itself, you also need to import styles separately
import "@bonfida/sns-widget/style.css";

// Link to public RPC for Solana connection. Solana provides free public RPCs
// with rate limiters, so you might want to use your own RPC Node provider
const PUBLIC_RPC = "https://api.mainnet-beta.solana.com";

export const Component = () =&gt; {
  return &lt;Widget endpoint={PUBLIC_RPC} /&gt;;
};
</code></pre>
<p>You can also opt to create registration instructions via our SDK or API, both methods are equivalent. To register a domain you will have to specify the following:</p>
<ul>
<li>Domain names</li>
<li>Space (between 1kb and 10kb)</li>
<li>The public key of the buyer</li>
</ul>
<p>Domain names can be registered with the following tokens: USDC, USDT, wSOL, FIDA, mSOL, BONK and BAT.</p>
<blockquote>
<p><strong>Note:</strong> The registration instruction does not support native SOL but wrapped SOL</p>
</blockquote>
<h2 id="asset-pricing"><a class="header" href="#asset-pricing">Asset pricing</a></h2>
<p align="center">
<a href="https://pyth.network/" target="_blank">
<img src="domain-name/../assets/partner-logos/pyth-logo.svg" alt="Pyth Network" width="200" height="auto"/>
</a>
</p>
<p>Token pricing data during domain registration is provided to us by our friends at Pyth Network. Learn more about their Blockchain Oracle at <a href="https://pyth.network/">Pyth Network</a>.</p>
<h2 id="sdk"><a class="header" href="#sdk">SDK</a></h2>
<p>Unregistered domains can be registered using the SDK <code>@bonfida/spl-name-service</code> with the following instructions:</p>
<pre><code class="language-js">import { registerDomainNameV2 } from "@bonfida/spl-name-service";

const name = "bonfida"; // We want to register bonfida.sol
const space = 1 * 1_000; // We want a 1kB sized domain (max 10kB)

const buyer = new PublicKey("..."); // Publickey of the buyer
const buyerTokenAccount = new PublicKey("..."); // Publickey of the token account of the buyer (USDC)

const ix = await registerDomainNameV2(name, space, buyer, buyerTokenAccount);

// sign and send the instruction
</code></pre>
<h2 id="api"><a class="header" href="#api">API</a></h2>
<p>Registration instructions can also be created via API (equivalent to using the SDK):</p>
<pre><code>GET https://sns-sdk-proxy.bonfida.workers.dev/register?buyer={buyer}&amp;domain={domain}&amp;space={space}&amp;serialize={serialize}
</code></pre>
<p>This endpoint can be used to register domain for buyer. Additionaly, the buyer dans specify the space it wants to allocate for the domain account. In the case where serialize is true the endpoint will return the transaction serialized in the wire format base64 encoded. Otherwise it will return the instruction in the following format: <code>{ programId: string, keys: {isWritable: boolean, isSigner: boolean, pubkey: string}[], data: string }</code> where <code>data</code> is base64 encoded.</p>
<p>This endpoint also supports the optional mint parameter to change the mint of the token used for registration (currently supports USDC, USDT, FIDA and wSOL), if mint is omitted it defaults to USDC.</p>
<h2 id="registration-via-cpi"><a class="header" href="#registration-via-cpi">Registration via CPI</a></h2>
<p>Add the <code>sns-registrar</code> dependency to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
sns-registrar = { git = "ssh://git@github.com/Bonfida/sns-registrar.git", features = ["no-entrypoint"] }
</code></pre>
<p>In your code make sure to import the required functions</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use sns_registrar::{instruction_auto::create_split_v2, processor::create_split_v2};
<span class="boring">}</span></code></pre></pre>
<p>The main function for domain registration is <code>create_split_v2</code>. Here's how to use it:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let registration_instruction = create_split_v2(
    sns_registrar::ID,
    create_split_v2::Accounts {
        naming_service_program: accounts.spl_name_service.key,
        root_domain: accounts.root_domain.key,
        name: accounts.name_account.key,
        reverse_lookup: accounts.reverse_lookup.key,
        system_program: accounts.system_program.key,
        central_state: accounts.sns_registrar_central_state.key,
        buyer: accounts.buyer.key,
        domain_owner: accounts.new_domain_owner.key,
        buyer_token_source: accounts.buyer_token_source.key,
        pyth_feed_account: accounts.pyth_feed_account.key,
        vault: accounts.bonfida_fee_vault.key,
        spl_token_program: accounts.spl_token_program.key,
        rent_sysvar: accounts.rent_sysvar.key,
        state: accounts.sns_registrar_state.key,
        referrer_account_opt: None,
        fee_payer: accounts.fee_payer.key,
    },
    create_split_v2::Params {
        name: domain_name,
        space: 0,
        referrer_idx_opt: None,
    },
);
<span class="boring">}</span></code></pre></pre>
<p>Important Account Keys:</p>
<ul>
<li><code>sns_registrar</code>: Constant key <code>jCebN34bUfdeUYJT13J1yG16XWQpt5PDx6Mse9GUqhR</code></li>
<li><code>naming_service_program</code>: Constant key <code>namesLPneVptA9Z5rqUDD9tMTWEJwofgaYwp8cawRkX</code></li>
<li><code>root_domain</code>: Constant key <code>58PwtjSDuFHuUkYjH9BYnnQKHfwo9reZhC2zMJv9JPkx</code></li>
<li><code>central_state</code>: Constant key <code>33m47vH6Eav6jr5Ry86XjhRft2jRBLDnDgPSHoquXi2Z</code></li>
<li><code>name</code>: Computed using <code>sns_registrar::utils::get_name_key("something", None)?;</code> for registering <code>something.sol</code></li>
<li><code>reverse_lookup</code>: Computed using <code>sns_registrar::utils::get_reverse_key(accounts.name_account.key, None)?;</code></li>
<li><code>pyth_feed_account</code>: Derived based on the mint used for registration. See Pyth price feed derivation and token utilities</li>
<li><code>vault</code>: ATA of <code>5D2zKog251d6KPCyFyLMt3KroWwXXPWSgTPyhV22K2gR</code> for the mint used in registration</li>
<li><code>state</code>: PDA derived as: <code>Pubkey::find_program_address(&amp;[&amp;accounts.name_account.key.to_bytes()], accounts.sns_registrar.key).0</code></li>
<li><code>domain_owner</code> and <code>buyer</code> can be different this flexibility enables scenarios where one account pays for the registration while another becomes the owner of the domain.</li>
<li><code>buyer_token_source</code> is the associated token account of <code>buyer</code> for the mint used for the registration and used to pay the registration</li>
</ul>
<p>After creating the instruction, invoke it like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>invoke_signed(
    &amp;registration_instruction,
    &amp;[
        accounts.sns_registrar.clone(),
        accounts.spl_name_service.clone(),
        accounts.root_domain.clone(),
        accounts.name_account.clone(),
        accounts.reverse_lookup.clone(),
        accounts.system_program.clone(),
        accounts.sns_registrar_central_state.clone(),
        accounts.central_state.clone(),
        accounts.fee_payer.clone(),
        accounts.destination_token_vault.clone(),
        accounts.pyth_feed_account.clone(),
        accounts.bonfida_fee_vault.clone(),
        accounts.spl_token_program.clone(),
        accounts.rent_sysvar.clone(),
        accounts.sns_registrar_state.clone(),
        accounts.new_domain_owner.clone(),
    ],
    &amp;[&amp;signer_seeds],
)?;
<span class="boring">}</span></code></pre></pre>
<ul>
<li>The <code>space</code> parameter in <code>create_split_v2::Params</code> is set to <code>0</code> in this example.</li>
<li>The <code>referrer_account_opt</code> and <code>referrer_idx_opt</code> are set to <code>None</code> here. Use these for referral functionality if required.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="media-kit"><a class="header" href="#media-kit">Media kit</a></h1>
<blockquote>
<p><strong>Follow these guidelines when representing domain names on your website.</strong></p>
</blockquote>
<p>Domains names can be represented in two ways: inline and card.</p>
<p>Below are two examples of the inline and card representations.</p>
<ol>
<li><strong>Inline</strong></li>
</ol>
<p><img src="domain-name/../assets/media/examples/inline.png" alt="inline" /></p>
<ol start="2">
<li><strong>Card</strong></li>
</ol>
<p><img src="domain-name/../assets/media/examples/card.png" alt="card" /></p>
<h2 id="rare-domains"><a class="header" href="#rare-domains">Rare domains</a></h2>
<p>Rare domains are domains with 4 or less characters. These domains must be represented with the following gradient.</p>
<h3 id="gradient"><a class="header" href="#gradient">Gradient:</a></h3>
<p><img src="domain-name/../assets/media/wide/rare.svg" alt="rare-wide" /></p>
<h3 id="card-representation"><a class="header" href="#card-representation">Card representation</a></h3>
<p><img src="domain-name/../assets/media/card/rare.svg" alt="rare-card" /></p>
<h3 id="inline-representation"><a class="header" href="#inline-representation">Inline representation</a></h3>
<p><img src="domain-name/../assets/media/inline/rare.svg" alt="rare-inline" /></p>
<h2 id="emoji-domains"><a class="header" href="#emoji-domains">Emoji domains</a></h2>
<p>Emoji domains are domains that contain an emoji. These domains must be represented with the following gradient.</p>
<p><img src="domain-name/../assets/media/wide/emoji.svg" alt="emoji-wide" /></p>
<h3 id="card-representation-1"><a class="header" href="#card-representation-1">Card representation</a></h3>
<p><img src="domain-name/../assets/media/card/emoji.svg" alt="emoji-card" /></p>
<h3 id="inline-representation-1"><a class="header" href="#inline-representation-1">Inline representation</a></h3>
<p><img src="domain-name/../assets/media/inline/emoji.svg" alt="emoji-inline" /></p>
<h2 id="regular-domains"><a class="header" href="#regular-domains">Regular domains</a></h2>
<p>Regular domains are domains that have 5 or more characters and do not contain an emoji. These domains must be represented with the following gradient.</p>
<p><img src="domain-name/../assets/media/wide/regular.svg" alt="regular-wide" /></p>
<h3 id="card-representation-2"><a class="header" href="#card-representation-2">Card representation</a></h3>
<p><img src="domain-name/../assets/media/card/regular.svg" alt="regular-card" /></p>
<h3 id="inline-representation-2"><a class="header" href="#inline-representation-2">Inline representation</a></h3>
<p><img src="domain-name/../assets/media/inline/regular.svg" alt="regular-inline" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deleting-a-domain"><a class="header" href="#deleting-a-domain">Deleting a domain</a></h1>
<blockquote>
<p>üö® <strong>Deleting a domain is irreversible</strong></p>
</blockquote>
<blockquote>
<p>üö® <strong>Deleting a domain will make you lose ownership of the subdomains and records related to the domain</strong></p>
</blockquote>
<blockquote>
<p>üö® <strong>Deleting domain names is not recommended</strong></p>
</blockquote>
<p>Domain names can be deleted using the <code>deleteInstruction</code>, below is a NodeJS example:</p>
<pre><code class="language-js">import { Connection, Keypair, clusterApiUrl } from "@solana/web3.js";
import {
  getDomainKey,
  NAME_PROGRAM_ID,
  deleteInstruction,
} from "@bonfida/spl-name-service";
import { signAndSendInstructions } from "@bonfida/utils";

// bonfida.sol
const domain = "bonfida.sol"; // With or without .sol

const connection = new Connection(clusterApiUrl("mainnet-beta"), "processed");

const wallet = Keypair.fromSecretKey(...);

const deleteDomain = async () =&gt; {
  const { pubkey } = await getDomainKey(domain);

  const ix = deleteInstruction(
    NAME_PROGRAM_ID,
    pubkey,
    wallet.publicKey,
    wallet.publicKey
  );

  const tx = await signAndSendInstructions(connection, [], wallet, [ix]);

  console.log(`Deleted domain ${tx}`);
};

deleteDomain();
</code></pre>
<h2 id="deleting-subdomains"><a class="header" href="#deleting-subdomains">Deleting subdomains</a></h2>
<p>Subdomains can be deleted using the <code>deleteInstruction</code>, below is a NodeJS example:</p>
<pre><code class="language-js">import { Connection, Keypair, clusterApiUrl } from "@solana/web3.js";
import {
  getDomainKey,
  NAME_PROGRAM_ID,
  deleteInstruction,
} from "@bonfida/spl-name-service";
import { signAndSendInstructions } from "@bonfida/utils";

// dex.bonfida.sol
const domain = "dex.bonfida.sol"; // With or without .sol

const connection = new Connection(clusterApiUrl("mainnet-beta"), "processed");

const wallet = Keypair.fromSecretKey(...);

const deleteSubDomain = async () =&gt; {
  const { pubkey } = await getDomainKey(domain);

  const ix = deleteInstruction(
    NAME_PROGRAM_ID,
    pubkey,
    wallet.publicKey,
    wallet.publicKey
  );

  const tx = await signAndSendInstructions(connection, [], wallet, [ix]);

  console.log(`Deleted subdomain ${tx}`);
};

deleteSubDomain();
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="subdomains"><a class="header" href="#subdomains">Subdomains</a></h1>
<p>Subdomains in Solana Name Service (SNS) are similar to <code>.sol</code> domains but have a different parent. They can be considered as normal domains but from a different Top-Level Domain (TLD). For instance, <code>something.example.sol</code> can be considered the something subdomain of <code>example.sol</code> or a domain from the TLD <code>example.sol</code>.</p>
<h2 id="key-characteristics-of-subdomains"><a class="header" href="#key-characteristics-of-subdomains">Key Characteristics of Subdomains</a></h2>
<ul>
<li>
<p><strong>Parent Ownership:</strong> The owner of the parent domain retains the ability to transfer subdomains without the signature from the owner of the subdomains. This is a unique feature of subdomains in SNS.</p>
</li>
<li>
<p><strong>Limited Wallet Support:</strong> Subdomains have limited wallet support. This means that not all wallets may support transactions involving subdomains.</p>
</li>
<li>
<p><strong>Feature Support:</strong> Subdomains support the same features as main domains. This includes the ability to transfer and update data.</p>
</li>
</ul>
<h2 id="creating-a-subdomain"><a class="header" href="#creating-a-subdomain">Creating a subdomain</a></h2>
<p>This code snippet creates a subdomain and its reverse lookup account:</p>
<pre><code class="language-js">import { createSubdomain } from "@bonfida/spl-name-service";

// The subdomain to create with or without .sol e.g something.bonfida.sol or something.bonfida
const subdomain = "something.bonfida.sol";

// The owner of the parent domain
const owner = new PublicKey("...");

const ix = createSubdomain(connection, subdomain, owner);

// Sign and send the tx...
</code></pre>
<p>The created subdomains will initially be owned by the parent owner. A subdomain can be created and transfered inside the same transaction.</p>
<h2 id="transferring-a-subdomain"><a class="header" href="#transferring-a-subdomain">Transferring a Subdomain</a></h2>
<p>Subdomains can be transferred using the <code>transferSubdomain</code> instruction. Here is an example of how the subdomain owner can transfer a subdomain:</p>
<pre><code class="language-js">import { transferSubdomain } from "@bonfida/spl-name-service";

// ..

// Subdomains to transfer
const subdomain = "something.bonfida.sol";

// New owner of the domain
const newOwner = new PublicKey("...");

// Whether the parent name owner is signing the transfer
const isParentSigner = false;

const ix = await transferSubdomain(
  connection,
  subdomain,
  newOwner,
  isParentSigner
);

// sign and send instruction
</code></pre>
<p>The parent name owner can trigger a transfer by setting the <code>isParentSigner</code> flag to <code>true</code> and signing the transaction.</p>
<h2 id="resolving-subdomains"><a class="header" href="#resolving-subdomains">Resolving Subdomains</a></h2>
<p>Subdomains of a <code>.sol</code> domain can be resolved using the <code>findSubdomains</code> function. Here is an example of how to resolve subdomains:</p>
<pre><code class="language-js">import { findSubdomains } from "@bonfida/spl-name-service";

// Public key of bonfida.sol
const parentKey = new PublicKey("Crf8hzfthWGbGbLTVCiqRqV5MVnbpHB1L9KQMd6gsinb");

// Assuming that bonfida.sol has the following subdomains
// - sub_1.bonfida.sol
// - sub_2.bonfida.sol

const subdomains: string[] = await findSubdomains(connection, parentKey); // [sub_1, sub_2]
</code></pre>
<h2 id="deleting-a-subdomain"><a class="header" href="#deleting-a-subdomain">Deleting a Subdomain</a></h2>
<p>Subdomains can be deleted using the <code>deleteInstruction</code> function. Here is an example of how to delete a subdomain:</p>
<pre><code class="language-js">import { Keypair, clusterApiUrl } from "@solana/web3.js";
import {
  getDomainKey,
  NAME_PROGRAM_ID,
  deleteInstruction,
} from "@bonfida/spl-name-service";
import { signAndSendInstructions } from "@bonfida/utils";

// dex.bonfida.sol
const domain = "dex.bonfida.sol"; // With or without .sol

const wallet = Keypair.fromSecretKey(...);

const deleteSubDomain = async () =&gt; {
  const { pubkey } = await getDomainKey(domain);

  const ix = deleteInstruction(
    NAME_PROGRAM_ID,
    pubkey,
    wallet.publicKey,
    wallet.publicKey
  );

  const tx = await signAndSendInstructions(connection, [], wallet, [ix]);

  console.log(`Deleted subdomain ${tx}`);
};

deleteSubDomain();
</code></pre>
<blockquote>
<p>üí° While the deletion of a subdomain is a reversible action, it's important to be mindful of potential unintended consequences.</p>
</blockquote>
<p>In conclusion, subdomains in SNS are a powerful feature that allows for more granular control and organization of domain names. However, they come with their own set of considerations such as limited wallet support and different ownership rules.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="devnet"><a class="header" href="#devnet">Devnet</a></h1>
<p>Testing can be done on devnet with many of the same functions and methods previously described in this chapter, using the devnet module of the JavaScript SDK. A connection object created from a devnet RPC URL will need to be passed to these functions.</p>
<pre><code class="language-js">import { devnet } from "@bonfida/spl-name-service";

// Use Solana devnet RPC URL or a custom RPC URL
const connection = new Connection("https://api.devnet.solana.com");
</code></pre>
<h2 id="register-devnet-domains"><a class="header" href="#register-devnet-domains">Register Devnet Domains</a></h2>
<p>Many of the utility and binding functions in the devnet module will require existing devnet domain names. Use the <code>registerDomainNameV2</code> binding to register domains on devnet to be used in testing.</p>
<pre><code class="language-js">const ix = await devnet.bindings.registerDomainNameV2(
  connection,
  "devnet-test-5", // The name of the domain you want to register
  1_000,
  publicKey, // PublicKey of fee payer
  getAssociatedTokenAddressSync(NATIVE_MINT, publicKey, true), // import from @solana/spl-token
  NATIVE_MINT
);

// Sign and send instruction
</code></pre>
<h2 id="utils"><a class="header" href="#utils">Utils</a></h2>
<p>The devnet module contains utility functions for lookup and derivation tasks for usage with devnet out of the box. An example of the <code>reverseLookup</code> function which looks up a human readable domain from the public key of a domain name registry, is below.</p>
<pre><code class="language-js">// Public key of bonfida.sol
const domainKey = new PublicKey("Crf8hzfthWGbGbLTVCiqRqV5MVnbpHB1L9KQMd6gsinb");

const domainName = await devnet.utils.reverseLookup(connection, domainKey); // bonfida
</code></pre>
<h2 id="constants"><a class="header" href="#constants">Constants</a></h2>
<p>A set of devnet constants are also provided for use with custom functions as well as with the bindings described below. An example of deriving the <code>NAME_PROGRAM_ID</code> is below.</p>
<pre><code class="language-js">const programId = devnet.constants.NAME_PROGRAM_ID;
</code></pre>
<h2 id="bindings"><a class="header" href="#bindings">Bindings</a></h2>
<p>For more in depth domain name interactions like creating, updating, deleting, or transfering domains and records, bindings from the devnet module can be used. An example using the <code>createNameRegistry</code> function is below.</p>
<pre><code class="language-js">// Domain name to transfer
const domain = "devnet-test-5";

// New owner of the domain
const newOwner = new PublicKey("...");

// The .sol TLD
const nameParent = dev.constants.ROOT_DOMAIN_ACCOUNT;

const ix = await devnet.bindings.transferNameOwnership(
  connection,
  domain,
  newOwner,
  undefined, // Optional class of the domain name, if it exists
  nameParent
);

// Sign and send instruction
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="examples-1"><a class="header" href="#examples-1">Examples</a></h1>
<p>Below is a list of examples that can be used to test your code:</p>
<ol>
<li><a href="domain-name/sns-examples//domain-name/sns-examples/derivations.html">Key derivations</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="key-derivations"><a class="header" href="#key-derivations">Key derivations</a></h1>
<p>The following examples can be used to test your derivations:</p>
<h2 id="domain-name"><a class="header" href="#domain-name">Domain name</a></h2>
<ul>
<li><code>solana.sol</code>:
<ul>
<li>Public key: <code>9TdKztwu2cS3JConXYEwqscjuCixgQqFq1pAiPQEbkSy</code> (<a href="https://solana.fm/address/9TdKztwu2cS3JConXYEwqscjuCixgQqFq1pAiPQEbkSy">Explorer link</a>)</li>
<li>Reverse key: <code>AceeTYYPKzfmEd9uht5cB9ATMFEjJPcG1VLCRvgiV4fy</code> (<a href="https://solana.fm/address/AceeTYYPKzfmEd9uht5cB9ATMFEjJPcG1VLCRvgiV4fy">Explorer link</a>)</li>
</ul>
</li>
<li><code>bonfida.sol</code>:
<ul>
<li>Public key: <code>Crf8hzfthWGbGbLTVCiqRqV5MVnbpHB1L9KQMd6gsinb</code> (<a href="https://solana.fm/address/Crf8hzfthWGbGbLTVCiqRqV5MVnbpHB1L9KQMd6gsinb">Explorer link</a>)</li>
<li>Reverse key: <code>DqgmWxe2PPrfy45Ja3UPyFGwcbRzkRuwXt3NyxjX8krg</code> (<a href="https://solana.fm/address/DqgmWxe2PPrfy45Ja3UPyFGwcbRzkRuwXt3NyxjX8krg">Explorer link</a>)</li>
</ul>
</li>
<li><code>01.sol</code>:
<ul>
<li>Public key: <code>8nZ7dyd6fFSiHTV5qUCNz6kMLzVcgKgHVsDvE8AvPyq9</code> (<a href="https://solana.fm/address/8nZ7dyd6fFSiHTV5qUCNz6kMLzVcgKgHVsDvE8AvPyq9">Explorer link</a>)</li>
<li>Reverse key: <code>GFG4HcxU5URRfBxFLV9xvmJo6mdHCunEm2DRHc3aNtfL</code> (<a href="https://solana.fm/address/GFG4HcxU5URRfBxFLV9xvmJo6mdHCunEm2DRHc3aNtfL">Explorer link</a>)</li>
</ul>
</li>
</ul>
<h2 id="subdomain"><a class="header" href="#subdomain">Subdomain</a></h2>
<ul>
<li>
<p><code>dex.solana.sol</code>:</p>
<ul>
<li>Public key: <code>F1A1iznr16YfnWAnLXLKvS3aStm4VHwkheMD786KW8Ca</code> (<a href="https://solana.fm/address/F1A1iznr16YfnWAnLXLKvS3aStm4VHwkheMD786KW8Ca">Explorer link</a>)</li>
<li>Reverse key: <code>9gT93HfjZVHT8xHrJvzV7eRFs5bnXhPAsEpxvgvCsDaw</code> (<a href="https://solana.fm/address/9gT93HfjZVHT8xHrJvzV7eRFs5bnXhPAsEpxvgvCsDaw">Explorer link</a>)</li>
</ul>
</li>
<li>
<p><code>dex.bonfida.sol</code>:</p>
<ul>
<li>Public key: <code>HoFfFXqFHAC8RP3duuQNzag1ieUwJRBv1HtRNiWFq4Qu</code> (<a href="https://solana.fm/address/HoFfFXqFHAC8RP3duuQNzag1ieUwJRBv1HtRNiWFq4Qu">Explorer link</a>)</li>
<li>Reverse key: <code>6tAdEpjsrzHuRqJW3XMXEV7DFyCWW4giW6mW4bgvhcYV</code> (<a href="https://solana.fm/address/6tAdEpjsrzHuRqJW3XMXEV7DFyCWW4giW6mW4bgvhcYV">Explorer link</a>)</li>
</ul>
</li>
</ul>
<h2 id="record"><a class="header" href="#record">Record</a></h2>
<ul>
<li>
<p><code>solana.sol</code> IPFS record:</p>
<ul>
<li>Public key: <code>GvncrrXMGsBMtwg2uh8FShUqLS4GLtYrmBeCdX5PEbPR</code> (<a href="https://solana.fm/address/GvncrrXMGsBMtwg2uh8FShUqLS4GLtYrmBeCdX5PEbPR">Explorer link</a>)</li>
</ul>
</li>
<li>
<p><code>bonfida.sol</code> URL record:</p>
<ul>
<li>Public key: <code>CvhvqcxBbA4UdWuJFDMuuC4XbpCrAd9gidpW5wxEsjg5</code> (<a href="https://solana.fm/address/CvhvqcxBbA4UdWuJFDMuuC4XbpCrAd9gidpW5wxEsjg5">Explorer link</a>)</li>
</ul>
</li>
</ul>
<h2 id="-difference-between-records-and-subdomains"><a class="header" href="#-difference-between-records-and-subdomains">üí° Difference between records and subdomains</a></h2>
<p>In practice, let us consider the name <code>foo.sol</code> . If we want to find the domain's A record, containing an associated IPv4 address, then we can find it by querying <code>\1A.foo.sol</code>, with \1 the character of code value 1. The specification makes use of this prefix in order to differentiate between actual domains and records, which means that it is still possible to use the <code>A.foo.sol</code> subdomain with no collision.
In addition to this, the special <code>\1.foo.sol</code> is reserved to hold the list of all currently initialized records for a given subdomain</p>
<blockquote>
<p><strong>Note:</strong> <code>\0</code> and <code>\1</code> are convenient notations for:</p>
<ul>
<li><code>\0 = \x00</code>.</li>
<li><code>\1 = \x01</code>.</li>
</ul>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="twitter"><a class="header" href="#twitter">Twitter</a></h1>
<p>This following sections provide information on the following:</p>
<ul>
<li><a href="twitter/twitter-tld.html">The twitter TLD</a></li>
<li><a href="twitter/register.html">How to register a twitter handle</a></li>
<li><a href="twitter/twitter-direct-lookup.html">How to perform a direct look up</a></li>
<li><a href="twitter/twitter-reverse-lookup.html">How to perform a reverse look up</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tld-1"><a class="header" href="#tld-1">TLD</a></h1>
<p>The Twitter handle TLD is</p>
<pre><code class="language-js">export const TWITTER_ROOT_PARENT_REGISTRY_KEY = new PublicKey(
  "4YcexoW3r78zz16J2aqmukBLRwGq6rAvWzJpkYAXqebv"
);
</code></pre>
<p>The <code>.twitter</code> TLD is owned by the <code>root</code> TLD and all twitter handles are subdomains of the <code>.twitter</code> TLD</p>
<p><img src="twitter/../assets/twitter-tld.png" alt="twitter-tld" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="twitter-handle-registration"><a class="header" href="#twitter-handle-registration">Twitter handle registration</a></h1>
<p>Twitter handles can be registered <a href="https://sns.id/twitter">here</a> and a detailed guide can be found <a href="https://docs.bonfida.org/collection/solana-name-service-twitter">on the Community Help Center</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="direct-look-up-2"><a class="header" href="#direct-look-up-2">Direct look up</a></h1>
<p><img src="twitter/../assets/twitter-direct-reverse.png" alt="direct-reverse" /></p>
<p>To find the Twitter handle associated to a public key</p>
<pre><code class="language-js">import { getHandleAndRegistryKey } from "@bonfida/spl-name-service";

const pubkey = new PublicKey("FidaeBkZkvDqi1GXNEwB8uWmj9Ngx2HXSS5nyGRuVFcZ");

const [handle] = await getHandleAndRegistryKey(connection, pubkey);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reverse-look-up-3"><a class="header" href="#reverse-look-up-3">Reverse look up</a></h1>
<p><img src="twitter/../assets/twitter-direct-reverse.png" alt="direct-reverse" /></p>
<p>To find the public key associated to a Twitter handle</p>
<pre><code class="language-js">import { getTwitterRegistry } from "@bonfida/spl-name-service";

const handle = "bonfida";

const registry = await getTwitterRegistry(connection, handle);
const owner = registry.owner.toBase58();
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sns-api"><a class="header" href="#sns-api">SNS API</a></h1>
<p>‚ö†Ô∏è This API is not meant to replace the blockchain as the source of truth. The blockchain should always be considered as the only source of truth. This API is only a snapshot of the blockchain at a certain point in time and might be stale by a few seconds/minutes.</p>
<ul>
<li>The base URL of the API is:</li>
</ul>
<pre><code>https://api.sns.id
</code></pre>
<ul>
<li>The platform enum returned by <code>sales</code> endpoint is defined as below:</li>
</ul>
<pre><code class="language-javascript">enum PlatformEnum {
    None = 0,
    MagicEden = 1,
    FixedPrice = 2,
    UnsolictedOffer = 3,
    AuctionClaim = 4,
    AuctionPlaceBid = 5,
    Hyperspace = 6,
    SMBMarketplace = 7,
    Solanart = 8,
    Fractal = 9,
    Holaplex = 10,
    DegenApeMarketplace = 11,
    GooseFx = 12,
    SolanartAH =13,
    CoralCube = 14,
    AlphaArt = 15,
    DigitalEyes = 16,
    SolSea = 17,
    ExchangeArt = 18,
    Grape = 19,
    OpenSea = 20,
    Metaplex = 21,
    YAWWW = 22,
    RaribleAH = 23,
    Solvent = 24,
    TiexoT0 = 25,
    TiexoT1 = 26,
    TiexoT2 = 27,
    TiexoT3 = 28,
    TiexoT4 = 29,
    CoralCubeV2 = 30,
    Elixir = 31,
    Tensor = 32,
    GoatSwap = 33,
    Hadeswap = 34,
    AuctionHouse = 35,
    CategoryOffer = 36,
    NightMarket = 37,
    Cardinal = 38,
    MECCSwap = 39,
    SniperMarket = 40,
    Okx = 41,
}
</code></pre>
<ul>
<li>All timestamps are in <strong>seconds</strong></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="domains"><a class="header" href="#domains">Domains</a></h2>
<h3 id="history"><a class="header" href="#history">History</a></h3>
<p>This endpoint can be used to retrieve the transaction history for all registered domains. Since the response payload will be large, the below optional query parameters can be passed.</p>
<p><code>limit</code> - This is the number of records per response up to 200. 200 is also the default if no limit parameter is passed.</p>
<p><code>start_time</code> - The start in unix timestamp from when the domain transaction records should be obtained.</p>
<p><code>end_time</code> - The end in unix timestamp to when the domain transaction records should be obtained.</p>
<p><code>last_token</code> - This token is used to fetch the next set of responses and is recieved from the API response. After the initial API call, you can pass this as a parameter for further responses.</p>
<blockquote>
<p>Request</p>
</blockquote>
<pre><code>GET v2/domains/history?limit={limit}&amp;start_time={start_time}&amp;end_time={end_time}&amp;last_token={last_token}
</code></pre>
<blockquote>
<p>Response</p>
</blockquote>
<pre><code class="language-json">{
  "data": [
    {
      "operation": 1,
      "unix_timestamp": 1622592000,
      "tx_signature": "27EjmB4NdsRKMNkeYeF4rva...",
      "domain_key": "4cQ3zUeardJweGTnk...",
      "pre_tx_owner": "5fEPywJMxeP2HBo7JyBUv1G...",
      "post_tx_owner": "CUcYT9ZoBXET88o...",
      "transaction_type": 1,
      "usd_price": 152,
      "price": 1,
      "quote_mint": "So11111111111111111111111111111111111111112"
    }
  ],
  "last_token": "1622592000:abcdef1234567890:domain1"
}
</code></pre>
<p>The <code>operation</code> property in the response has the structure below. The <code>transaction_type</code> property correlates to <code>operation</code> where a value of 0 indicates a registration, and a value of 1 indicates a sale or transfer. For other operations, the <code>transaction_type</code> is <code>null</code>.</p>
<pre><code class="language-ts">enum Operation {
  Create, // registration (0)
  Transfer, // sale or transfer (1)
  Update, // update data in a name record (2)
  Delete, // delete or burn a domain (3)
  Realloc, // change the domain storage size (4)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="categories"><a class="header" href="#categories">Categories</a></h2>
<h3 id="get-the-list-of-categories"><a class="header" href="#get-the-list-of-categories">Get the list of categories</a></h3>
<p>This endpoint can be used to retrieve the list of all categories.</p>
<blockquote>
<p>Request</p>
</blockquote>
<pre><code>GET /categories/list
</code></pre>
<blockquote>
<p>Response</p>
</blockquote>
<pre><code class="language-json">{
  "success": true,
  "result": [
    "english-adjectives",
    "double-emoji"
    // ...
  ]
}
</code></pre>
<h3 id="get-the-domains-of-a-category"><a class="header" href="#get-the-domains-of-a-category">Get the domains of a category</a></h3>
<p>This endpoint can be used to retrieve the list of domains of a category.</p>
<blockquote>
<p>Request</p>
</blockquote>
<pre><code>GET /categories/list/{category}
</code></pre>
<blockquote>
<p>Response</p>
</blockquote>
<pre><code class="language-json">{
  "success": true,
  "result": [
    "qatar",
    "uganda"
    // ...
  ]
}
</code></pre>
<h3 id="get-categories-statistics"><a class="header" href="#get-categories-statistics">Get categories statistics</a></h3>
<p>This endpoint returns stats for all the categories.</p>
<blockquote>
<p>Request</p>
</blockquote>
<pre><code>GET /categories/stats?start_time={start_time}&amp;end_time={end_time}
</code></pre>
<blockquote>
<p>Response</p>
</blockquote>
<pre><code class="language-json">{
  "success": true,
  "result": [
    {
      "category_name": "0x999-club",
      "min_sale": 7.8846874,
      "max_sale": 80.0,
      "avg_price": 43.94234371185303,
      "volume": 87.88469,
      "owners": 1,
      "supply": 2
    }
    // ...
  ]
}
</code></pre>
<h3 id="get-statistics-for-a-category"><a class="header" href="#get-statistics-for-a-category">Get statistics for a category</a></h3>
<p>This endpoint returns stats for a given category.</p>
<blockquote>
<p>Request</p>
</blockquote>
<pre><code>GET /categories/stats/{category}?start_time={start_time}&amp;end_time={end_time}
</code></pre>
<blockquote>
<p>Response</p>
</blockquote>
<pre><code class="language-json">{
  "success": true,
  "result": [
    {
      "min_sale": 7.8846874,
      "max_sale": 80.0,
      "avg_price": 43.94234371185303,
      "volume": 87.88469,
      "owners": 1,
      "supply": 2
    }
  ]
}
</code></pre>
<h3 id="get-floors"><a class="header" href="#get-floors">Get floors</a></h3>
<p>This endpoint returns the current floors for all categories. Floor prices are given in USD value.</p>
<blockquote>
<p>Request</p>
</blockquote>
<pre><code>GET /categories/floors
</code></pre>
<blockquote>
<p>Response</p>
</blockquote>
<pre><code class="language-json">{
  "success": true,
  "result": {
    "0x999-club": 21.839999628067016,
    "4-letter-dictionary": 101.39999999999999
    // ...
  }
}
</code></pre>
<h3 id="get-floor-for-a-category"><a class="header" href="#get-floor-for-a-category">Get floor for a category</a></h3>
<p>This endpoint returns the current floor for a given category. Floor prices are given in USD value.</p>
<blockquote>
<p>Request</p>
</blockquote>
<pre><code>GET /categories/floors/{category}
</code></pre>
<blockquote>
<p>Response</p>
</blockquote>
<pre><code class="language-json">{
  "success": true,
  "result": 21.839999628067016
}
</code></pre>
<h3 id="get-supply"><a class="header" href="#get-supply">Get supply</a></h3>
<p>This endpoint can be used to retrieve the number of registered and unregistered domains of a category.</p>
<blockquote>
<p>Request</p>
</blockquote>
<pre><code>GET /categories/supply
</code></pre>
<blockquote>
<p>Response</p>
</blockquote>
<pre><code class="language-json">{
  "success": true,
  "result": {
    "0x999-club": {
      "total": 1000,
      "registered": 38,
      "unregistered": 962
    }
    // ...
  }
}
</code></pre>
<h3 id="get-top-categories-by-volume"><a class="header" href="#get-top-categories-by-volume">Get top categories by volume</a></h3>
<p>This endpoint returns the top 10 categories by volume between <code>start_time</code> and <code>end_time</code>.</p>
<blockquote>
<p>Request</p>
</blockquote>
<pre><code>GET /categories/top?start_time={start_time}&amp;end_time={end_time}
</code></pre>
<blockquote>
<p>Response</p>
</blockquote>
<pre><code class="language-json">{
  "success": true,
  "result": [
    {
      "category_name": "10k-club",
      "volume": 177737.16
    }
  ]
}
</code></pre>
<h2 id="get-owners"><a class="header" href="#get-owners">Get owners</a></h2>
<blockquote>
<p>Request</p>
</blockquote>
<p>This endpoint returns the public keys owning domains for a given category and the number of domains they own.</p>
<pre><code>GET /categories/owners/{category}
</code></pre>
<blockquote>
<p>Response</p>
</blockquote>
<pre><code class="language-json">{
  "success": true,
  "result": [
    {
      "owner_key": "1BWutmTvYPwDtmw9abTkS4Ssr8no61spGAvW1X6NDix",
      "nb_domains": 38
    }
  ]
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="users"><a class="header" href="#users">Users</a></h2>
<h3 id="domains-owned"><a class="header" href="#domains-owned">Domains Owned</a></h3>
<p>This endpoint can be used to retrieve the domains owned by a list of user public keys. You may include up to 20 public keys in a comma seperated list.</p>
<blockquote>
<p>Request</p>
</blockquote>
<pre><code>GET /v2/user/domains/{pubkeys}
</code></pre>
<blockquote>
<p>Response</p>
</blockquote>
<pre><code class="language-json">{
  "FMmaHPDL47V1gXsfh9WjgAT7Er3dfDvarQubTU1Jxc1r": ["03800", "best-intern"],
  "3f9fRjLaDSDVxd26xMEm4WuSXv62cGt5qVfEVGwMfTz6": ["00378", "02112", "11441"]
}
</code></pre>
<h3 id="primary-domains"><a class="header" href="#primary-domains">Primary domains</a></h3>
<blockquote>
<p>üí° Primary domains used to be called favorite domains.</p>
</blockquote>
<p>This endpoint can be used to retrieve the primary domains of a list of user public keys. You may include up to 20 public keys in a comma separated list. Results are cached, and refreshed every 5 minutes. If you're integrating SNS into your dApp, we strongly recommend using primary domains since users have selected these domains specifically to represent their identities apart from other domains they may own.</p>
<blockquote>
<p>Request</p>
</blockquote>
<pre><code>GET /v2/user/primary-domains/{pubkeys}
</code></pre>
<blockquote>
<p>Response</p>
</blockquote>
<pre><code class="language-json">{
  "FMmaHPDL47V1gXsfh9WjgAT7Er3dfDvarQubTU1Jxc1r": "best-intern",
  "3f9fRjLaDSDVxd26xMEm4WuSXv62cGt5qVfEVGwMfTz6": "11441"
}
</code></pre>
<h3 id="user-listings"><a class="header" href="#user-listings">User Listings</a></h3>
<p>This endpoint can be used to retrieve the domains of a user and their listing details. Please see the<code>PlatformEnum</code> definiton for details on <code>availability id</code>.</p>
<blockquote>
<p>Request</p>
</blockquote>
<pre><code>GET /v2/user/listings/{pubkey}
</code></pre>
<blockquote>
<p>Response</p>
</blockquote>
<pre><code class="language-json">[
  {
    "domain": "00378",
    "availability_id": 0,
    "price": null,
    "quote_mint": "So11111111111111111111111111111111111111112",
    "usd_price": null,
    "categories": ["100k-club"],
    "last_activity": {
      "price": 0.18,
      "quote_mint": "So11111111111111111111111111111111111111112",
      "usd_price": 18.4365
    }
  },
  {
    "domain": "02112",
    "availability_id": 2,
    "price": 10.0,
    "quote_mint": "So11111111111111111111111111111111111111112",
    "usd_price": 810.5181,
    "categories": ["100k-club"],
    "last_activity": {
      "price": 0.25,
      "quote_mint": "So11111111111111111111111111111111111111112",
      "usd_price": 19.401249
    }
  }
]
</code></pre>
<h3 id="domains-and-categories"><a class="header" href="#domains-and-categories">Domains and Categories</a></h3>
<p>This endpoint can be used to retrieve the list of domains owned by a user, as well as their corresponding categories.</p>
<blockquote>
<p>Request</p>
</blockquote>
<pre><code>GET /v2/user/category-domains/{pubkey}
</code></pre>
<blockquote>
<p>Response</p>
</blockquote>
<pre><code class="language-json">[
  { "domain_name": "00378", "category_name": "100k-club" },
  { "domain_name": "3231", "category_name": "10k-club" }
]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="listings"><a class="header" href="#listings">Listings</a></h2>
<h3 id="all-marketplace-listings"><a class="header" href="#all-marketplace-listings">All marketplace listings</a></h3>
<p>This endpoint can be used to retrieve the details of listings across marketplaces such as Sns.id, MagicEden, Tensor, and SolSniper.</p>
<p>The endpoint takes a JSON body with a <code>params</code> object containing optional filters:</p>
<ul>
<li><code>lang</code> - Language filter. Language struct shared below.</li>
<li><code>palindrome</code> - Boolean filter for palindromic domains.</li>
<li><code>emoji</code> - Boolean filter for domains containing emojis.</li>
<li><code>rare</code> - Boolean filter for rare domains.</li>
<li><code>digits_only</code> - Boolean filter for domains with only digits.</li>
<li><code>letters_only</code> - Boolean filter for domains with only letters.</li>
<li><code>min_len</code> - Integer filter for minimum length of domain names.</li>
<li><code>max_len</code> - Integer filter for maximum length of domain names.</li>
<li><code>mints</code> - List of token mints as an array of strings.</li>
<li><code>min_price</code> - Minimum price filter as a floating point integer.</li>
<li><code>max_price</code> - Maximum price filter as a floating point integer.</li>
<li><code>start_with</code> - String filter for domains that start with a specific string.</li>
<li><code>end_with</code> - String filter for domains that end with a specific string.</li>
<li><code>contain</code> - String filter ilter for domains that contain a specific string.</li>
<li><code>categories</code> - List of categories to filter by as an array of strings.</li>
<li><code>page_size</code> - Number of listings per page (default: 100, max: 100).</li>
<li><code>page</code> - Page number (default: 1).</li>
<li><code>order_by</code> - UsdPriceAsc, UsdPriceDesc, DomainAsc, DomainDesc, Random as strings.</li>
</ul>
<blockquote>
<p>Request</p>
</blockquote>
<pre><code>POST /v2/listings/listings-v3 -H 'Content-Type: application/json'  -d '{ "params": { "page_size": 10, "contain": "0" } }'
</code></pre>
<blockquote>
<p>Response</p>
</blockquote>
<pre><code class="language-json">{
  "total": 150,
  "data": [
    {
      "domain": "exampledomain",
      "price": 2,
      "quote_mint": "So11111111111111111111111111111111111111112",
      "availability_id": 2,
      "usd_price": 320,
      "metadata": {
        "length": 5,
        "lang": 1,
        "palindrome": false,
        "emoji": false,
        "rare": false,
        "digits_only": false,
        "letters_only": true
      }
    }
  ],
  "page_size": 100,
  "total_pages": 2,
  "page": 1
}
</code></pre>
<h3 id="listing-details"><a class="header" href="#listing-details">Listing Details</a></h3>
<p>This endpoint can be used to retrieve the listing details of a specific domain. The response is a JSON object with the below structure if the domain is listed, or null if the domain is not.</p>
<div class="table-wrapper"><table><thead><tr><th>Key</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>d</td><td>String</td><td>The domain name</td></tr>
<tr><td>p</td><td>Float (<code>f32</code>)</td><td>The price of the domain</td></tr>
<tr><td>q</td><td>String</td><td>The token mint of the listing (i.e the currency)</td></tr>
<tr><td>a</td><td>Enum (<code>u8</code>)</td><td>The availability ID (see <code>PlatformEnum</code> definition)</td></tr>
<tr><td>l</td><td>Enum (<code>u8</code>)</td><td>Language code (see definition below)</td></tr>
<tr><td>up</td><td>Float (<code>f32</code>)</td><td>The price in USD</td></tr>
<tr><td>e</td><td>Boolean</td><td>Indicates if the domain has an emoji</td></tr>
<tr><td>r</td><td>Boolean</td><td>Indicates if the domain is rare</td></tr>
<tr><td>do</td><td>Boolean</td><td>Indicates if the domain contains digits only</td></tr>
<tr><td>lo</td><td>Boolean</td><td>Indicates if the domain contains letters only</td></tr>
<tr><td>le</td><td>Integer</td><td>The length of the domain name</td></tr>
<tr><td>fp</td><td>Boolean</td><td>Indicates if the listing is a fixed price offer</td></tr>
<tr><td>me</td><td>Boolean</td><td>Indicates if the domain is listed on Magic Eden</td></tr>
<tr><td>pa</td><td>Boolean</td><td>Indicates if the domain is a palindrome</td></tr>
<tr><td>ca</td><td>Array (<code>Vec&lt;String&gt;</code>)</td><td>A list of categories the domain belongs to</td></tr>
</tbody></table>
</div>
<blockquote>
<p>Request</p>
</blockquote>
<pre><code>GET /v2/listings/listing/{domain}
</code></pre>
<blockquote>
<p>Response</p>
</blockquote>
<pre><code class="language-json">{
  "d": "bonfida.sol",
  "p": 100.0,
  "q": "USDC",
  "a": 2,
  "l": 0,
  "up": 100.0,
  "e": false,
  "r": true,
  "do": false,
  "lo": true,
  "le": 7,
  "fp": true,
  "me": false,
  "pa": false,
  "ca": []
}
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Language {
    English = 0,
    Cyrillic = 1,
    Chinese = 2,
    Japanese = 3,
    Emoji = 4,
    Unauthorized = 5,
    Korean = 6,
    Arabic = 7,
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="sales"><a class="header" href="#sales">Sales</a></h2>
<h3 id="last"><a class="header" href="#last">Last</a></h3>
<p>This endpoint can be used to retrieve the list of recent sales. The max <code>limit</code> parameter is 500.</p>
<blockquote>
<p>Request</p>
</blockquote>
<pre><code>GET /sales/last?limit={limit}
</code></pre>
<blockquote>
<p>Response</p>
</blockquote>
<pre><code class="language-json">{
  "success": true,
  "result": [
    {
      "unix_timestamp": 1663824910,
      "slot": 151782075,
      "domain_name": "wagbüëå",
      "domain_key": "FqRocnogXTAwTnhYxRc4BA3uFkAChsDefed6nVWeD1Xe",
      "domain_auction_key": "GQJyiqBXq2HWnFXUWcp3pDmBYZEw3CjiYbkUJoZC6qT2",
      "domain_token_mint": "ESPZfWYWQZ3fJaxq7GjzkCzXKJPRMfnKc1dhkVQBZyt2",
      "bidder_key": "TG41WLDXx4ofZ52up4pEKQcDj1zQ4oX9LUop5qnUwQr",
      "price": 1.55,
      "quote_mint": "So11111111111111111111111111111111111111112",
      "usd_price": 47.999626,
      "tx_signature": "2WcrNobBtLrarFNrakkMad2eyVzfBTzCnHo2cJYgWdoUHmH9eMqZe9SzJr53m1A4BqPzmXL5WcExc4t4r5DmMTC3",
      "platform_id": 1,
      "successful": true
    }
    // ...
  ]
}
</code></pre>
<h3 id="registrations"><a class="header" href="#registrations">Registrations</a></h3>
<p>This endpoint can be used to retrieve registrations between <code>end_time</code> and <code>start_time</code>. The max <code>limit</code> is 500.</p>
<blockquote>
<p>Request</p>
</blockquote>
<pre><code>GET /sales/registrations?limit={limit}&amp;end_time={end_time}&amp;start_time={end_time}
</code></pre>
<blockquote>
<p>Response</p>
</blockquote>
<pre><code class="language-json">{
  "success": true,
  "result": [
    {
      "unix_timestamp": 1663789595,
      "slot": 151721528,
      "tx_signature": "2D9VPjN93j7YTx13oHN9sL2RDHbytLMfNmxTCBc8a57faomn4e2iF2QyUU1DLfdA9FYEJq1SzXmaC8p9FntLckUL",
      "domain_name": "meggadao",
      "domain_key": "FoidaZVWPYNCgRkthdJqnSQ82x7SLkSpBAypR7RVtFNU",
      "domain_auction_key": "HmGENkrhkA7ekmj9kKni4CJLJyifjzohPAV1wWTWuQFX",
      "domain_token_mint": "ExankJNcWwJoS4ZYe5Xuw8r7ioqAcg5XkbzWT6NJhsiA",
      "price": 48.769577,
      "quote_mint": "EchesyfXePKdLtoiZSL8pBe8Myagyy8ZRqsACNCFGnvp",
      "usd_price": 20.184021
    }
  ]
}
</code></pre>
<h3 id="leaderboard"><a class="header" href="#leaderboard">Leaderboard</a></h3>
<p>This endpoint returns the top 100 sales ever.</p>
<blockquote>
<p>Request</p>
</blockquote>
<pre><code>GET /sales/leaderboard
</code></pre>
<blockquote>
<p>Response</p>
</blockquote>
<pre><code class="language-json">{
  "success": true,
  "result": [
    {
      "domain_name": "53",
      "usd_price": 15999.0
    }
    // ...
  ]
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="volumes"><a class="header" href="#volumes">Volumes</a></h2>
<h3 id="secondary-sales-volume"><a class="header" href="#secondary-sales-volume">Secondary sales volume</a></h3>
<p>This endpoint can be used to retrieve volumes for secondary sales accross all market places</p>
<blockquote>
<p>Request</p>
</blockquote>
<pre><code>GET /sales/volumes/sales?start_time={start_time}&amp;end_time={end_time}
</code></pre>
<blockquote>
<p>Response</p>
</blockquote>
<pre><code class="language-json">{
  "success": true,
  "result": [
    { "day": 1667174400, "volume": 115.98516 },
    { "day": 1667088000, "volume": 658.9297 }
  ]
}
</code></pre>
<h3 id="direct-registration-volume"><a class="header" href="#direct-registration-volume">Direct registration volume</a></h3>
<p>This endpoint can be used to retrieve direct registrations volume</p>
<blockquote>
<p>Request</p>
</blockquote>
<pre><code>GET /sales/volumes/registrations?start_time={start_time}&amp;end_time={end_time}
</code></pre>
<blockquote>
<p>Response</p>
</blockquote>
<pre><code class="language-json">{
  "success": true,
  "result": [
    { "day": 1667174400, "volume": 115.98516 },
    { "day": 1667088000, "volume": 658.9297 }
  ]
}
</code></pre>
<h3 id="aggregated-volume"><a class="header" href="#aggregated-volume">Aggregated volume</a></h3>
<p>This endpoint can be used to retrieve aggregated volume (secondary sales + direct registrations)</p>
<blockquote>
<p>Request</p>
</blockquote>
<pre><code>GET /sales/volumes/all?start_time={start_time}&amp;end_time={end_time}
</code></pre>
<blockquote>
<p>Response</p>
</blockquote>
<pre><code class="language-json">{
  "success": true,
  "result": [
    { "day": 1667174400, "volume": 115.98516 },
    { "day": 1667088000, "volume": 658.9297 }
  ]
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="owners"><a class="header" href="#owners">Owners</a></h2>
<h3 id="distribution"><a class="header" href="#distribution">Distribution</a></h3>
<p>This endpoint can be used to retrieve the domains distribution (includes escrow wallets)</p>
<pre><code>GET /owners/distribution
</code></pre>
<blockquote>
<p>Response</p>
</blockquote>
<pre><code class="language-json">{
  "success": true,
  "result": [
    { "nb_owners": 1, "nb_domains": 41896 }
    // ...
  ]
}
</code></pre>
<p>This endpoint can be used to retrieve the domains distribution (excludes escrow wallets)</p>
<pre><code>GET /owners/distribution-exclude-escrows
</code></pre>
<blockquote>
<p>Response</p>
</blockquote>
<pre><code class="language-json">{
  "success": true,
  "result": [
    { "nb_owners": 1, "nb_domains": 41896 }
    // ...
  ]
}
</code></pre>
<h3 id="domains-for-owner"><a class="header" href="#domains-for-owner">Domains for owner</a></h3>
<p>This endpoint can be used to retrieve the domain owned by a public key</p>
<pre><code>GET /owners/{owner_key}/domains
</code></pre>
<blockquote>
<p>Response</p>
</blockquote>
<pre><code class="language-json">{
  "success": true,
  "result": [
    "pharmacy",
    "softball",
    "travelagent"
    // ...
  ]
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="images"><a class="header" href="#images">Images</a></h2>
<p>Domain images can vary based on the rarity of a domain, if a domain contains an emoji character, or if a user has purchased a custom domain background during one of our limited time ecosystem artist collaborations.</p>
<p>More information about images can be found here: <a href="sns-api//domain-name/media-kit.html">Media Kit</a></p>
<h3 id="base-url"><a class="header" href="#base-url">Base URL</a></h3>
<p>Please note the base URL for images differs from other endpoints.</p>
<ul>
<li>The base URL of the API is:</li>
</ul>
<pre><code>https://image-api.bonfida.com
</code></pre>
<p>API response times can vary based on if a request for an image has been previously made. The image is generated upon the first request and then cached, greatly reducing subsequent response times.</p>
<h3 id="get-a-list-of-domain-images"><a class="header" href="#get-a-list-of-domain-images">Get a list of domain images</a></h3>
<p>This endpoint can be used to retrieve images for a list of domains.</p>
<blockquote>
<p>Request</p>
</blockquote>
<pre><code>GET /image?domain=foo&amp;domain=bar
</code></pre>
<blockquote>
<p>Response</p>
</blockquote>
<pre><code class="language-json">{
  "result": [
    { "domain": "foo", "image": "https://..." },
    { "domain": "bar", "image": "https://..." }
    // ...
  ]
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="marketplace"><a class="header" href="#marketplace">Marketplace</a></h1>
<h2 id="sns-marketplace"><a class="header" href="#sns-marketplace">SNS Marketplace</a></h2>
<p>The SNS Marketplace program makes it possible to integrate the purchase and sale of SNS domains directly into your own applications. Interact with the SNS Marketplace smart contract using our JS SDK linked below.</p>
<h3 id="deployment-1"><a class="header" href="#deployment-1">Deployment:</a></h3>
<ul>
<li>Program ID: <code>85iDfUvr3HJyLM2zcq5BXSiDvUWfw6cSE1FfNBo8Ap29</code></li>
<li>Auditor: Halborn</li>
<li>Audit report: <a href="https://github.com/HalbornSecurity/PublicReports/blob/master/Solana%20Program%20Audit/Bonfida_SNS_Solana_Program_Security_Assessment_Report_Halborn_Final.pdf">here</a></li>
<li>JS SDK: <a href="https://www.npmjs.com/package/@bonfida/name-offers">NPM</a></li>
</ul>
<p>This smart contract supports different types of sales:</p>
<ul>
<li>Fixed price</li>
<li>Unsolicited</li>
<li>Category</li>
<li>P2P</li>
</ul>
<p>The functions from our SDK detailed below will return instructions that you can use to build transactions.</p>
<p>Fixed price and unsolicited offers support the following tokens as quote currency: SOL, FIDA, USDC, USDT, mSOL, BONK, BAT, PYTH and bSOL.</p>
<p>All these listings can be accessed on <a href="https://www.sns.id/">sns.id</a></p>
<p>The SNS Marketplace also supports a referral system, allowing users to share <strong>15%</strong> of the transaction fees. This feature enables participants to earn rewards by referring new users to the marketplace. In order to earn the portion of the fees, users must pass their wallet address in <code>buyFixedPrice</code>, <code>acceptOffer</code> and <code>takeCategoryOffer</code></p>
<h3 id="fixed-price-offers"><a class="header" href="#fixed-price-offers">Fixed Price Offers</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct FixedPriceOffer {
    /// Account tag
    pub tag: Tag,
    /// Nonce
    pub nonce: u8,
    /// Name being sold
    pub name_account: Pubkey,
    /// Offer owner
    pub owner: Pubkey,
    /// Quote token used for offer
    pub quote_mint: Pubkey,
    /// Amount of the offer
    pub offer_amount: u64,
    // Offer amount token account destination
    pub token_destination: Pubkey,
}
<span class="boring">}</span></code></pre></pre>
<p>Fixed Price Offers allow sellers to list domain names for sale at a predetermined price. Buyers can purchase these domain names by paying the specified amount.</p>
<p>Creating a fixed price offer is handled by the <code>makeFixedPriceOffer</code> function, as shown in the code snippet below:</p>
<pre><code class="language-ts">const connection = new Connection("...");
const seller = new PublicKey("..."); // Public key of the seller i.e domain owner
const mint = new PublicKey("EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"); // USDC mint
const amount = 1 * 1e6; // Amount with decimals, here 1 USDC
const { pubkey: domainKey } = getDomainKeySync("something.sol"); // Domain public key

const ix = await makeFixedPriceOffer(
  connection,
  amount,
  mint,
  seller,
  domainKey,
  NAME_OFFERS_ID // The program ID that can be imported directly from our SDK
);
</code></pre>
<p>Buying a fixed price offer is facilitated through the <code>buyFixedPrice</code> function, which ensures the transfer of the domain to the buyer and the payment to the seller:</p>
<pre><code class="language-ts">const connection = new Connection("...");
const buyer = new PublicKey("..."); // Public key of the offer buyer
const source = new PublicKey("..."); // Source of the funds used to purchase the offer. In case of SOL it's the same as `buyer`. If another token is used, it's the ATA of the buyer for the given mint.
const { pubkey: domainKey } = getDomainKeySync("something.sol"); // Domain public key
const referrer: PublicKey | undefined = undefined; // Optional referrer

// Use a util function from our SDK to get fixed price offers by name, by owner, or all fixed price offers.
const fixedPriceOffers = await getFixedPriceOffersForName(
  connection,
  domainKey
);

// This example arbitrarily selects the first fixed price offer in the list. Filter offers based on the your needs.
const fixedPriceKey = fixedPriceOffers[0].pubkey;

const ix = await buyFixedPrice(
  connection,
  fixedPriceKey,
  buyer,
  source,
  NAME_OFFERS_ID,
  referrer
);
</code></pre>
<p>Fixed price offers can be cancelled using the <code>cancelFixedPriceOffer</code> function.</p>
<h3 id="unsolicited-offers"><a class="header" href="#unsolicited-offers">Unsolicited Offers</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Offer {
    /// Tag
    pub tag: Tag,
    /// Nonce
    pub nonce: u8,
    /// Name account of the offer
    pub name_account: Pubkey,
    /// Offer owner
    pub owner: Pubkey,
    /// Quote token used for offer
    pub quote_mint: Pubkey,
    /// Amount of the offer
    pub offer_amount: u64,
    /// Escrow account key
    pub escrow: Pubkey,
}
<span class="boring">}</span></code></pre></pre>
<p>Unsolicited offers allow buyers to propose a purchase price for a domain not listed for sale. The domain owner can then accept or ignore the offer.</p>
<p>Placing an unsolicited offers is handled by the <code>makeOffer</code> function</p>
<pre><code class="language-ts">const mint = new PublicKey("EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"); // USDC mint
const amount = 1 * 1e6; // Amount with decimals, here 1 USDC
const { pubkey: domainKey } = getDomainKeySync("something.sol"); // Domain public key
const owner = new PublicKey("..."); // Owner of the unsolicited offer
const tokenSource = new PublicKey("..."); // Token source used to place the offer.

const ix = await makeOffer(
  amount,
  domainKey,
  owner,
  mint,
  tokenSource,
  NAME_OFFERS_ID
);
</code></pre>
<p>An unsolicited offer can be accepted by the domain owner using the <code>acceptOffer</code> function:</p>
<pre><code class="language-ts">const connection = new Connection("...");
const domainOwner = new PublicKey("..."); // Current domain owner
const { pubkey: domainKey } = getDomainKeySync("something.sol"); // Domain public key
const offerEscrow = new PublicKey("..."); // PDA used to store the funds of the offer, the address is written in the state
const destination = new PublicKey("..."); // The token account used to receive the funds from the escrow
const referrer: PublicKey | undefined = undefined; // Optional referrer

// Use a util function from the SDK to get offers by domain name, by domain owner, etc.
const offers = await getOffersForName(connection, "something.sol");

// This example arbitrarily selects the first offer in the list. Filter offers based on your needs.
const offerKey = offers[0].pubkey;
const offerOwner = offers[0].owner;

const ix = await acceptOffer(
  connection,
  NAME_OFFERS_ID,
  offerKey,
  offerOwner,
  publicKey,
  domainKey,
  offerEscrow,
  destination,
  referrer
);
</code></pre>
<p>Unsolicited offers can be canceled using the <code>cancelOffer</code> function.</p>
<h3 id="category-offers"><a class="header" href="#category-offers">Category offers</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct CategoryOffer {
    // Account tag
    pub tag: Tag,
    // The PDA nonce
    pub nonce: u8,
    // The total number of domains requested
    pub nb_domains: u64,
    // The SOL price per domain
    pub sol_price: u64,
    // The category of the offer
    pub category: Pubkey,
    // The owner of the offer
    pub owner: Pubkey,
    // Timestamp at which the offer was created
    pub created_at: u64,
}
<span class="boring">}</span></code></pre></pre>
<p>Category Offers allow buyers to bid on an entire domain category. Sellers can accept these offers, selling domains within the specified category.</p>
<p>The creation of a category offer is managed by the <code>makeCategoryOffer</code> function, which specifies the number of domains, the SOL price per domain, and the category:</p>
<pre><code class="language-ts">import { CATEGORIES } from "@bonfida/sns-categories"; // Map of current categories

const amount = 10 * LAMPORTS_PER_SOL; // Amount of the offer in lamports here 10 SOL
const nbDomains = 10; // Number of domains the buyer wants to buy
const buyer = new PublicKey("...");

// Filter CATEGORIES to find the categoryKey which is the Public key of the category.
const categoryKey = [...CATEGORIES].find(
  ([, value]) =&gt; value === "999-club"
)?.[0];

const ix = await makeCategoryOffer(
  amount,
  nbDomains,
  categoryKey,
  NAME_OFFERS_ID,
  buyer
);
</code></pre>
<p>Taking a category offer is facilitated through the <code>takeCategoryOffer</code> function, allowing sellers to sell domains within the category at the specified price.</p>
<pre><code class="language-ts">const connection = new Connection("...");
const { pubkey: domainKey } = getDomainKeySync("999.sol"); // Domain public key
const memberKey = CategoryMember.findKey("999", categoryKey); // Membership of the domain to the category
const seller = new PublicKey("..."); // Seller of the domain here 999.sol
const referrer: PublicKey | undefined = undefined; // Optional referrer

// Use a util function from the SDK to get category offers by category, category offers for a specific owner, etc.
const categoryOffers = await getCategoryOffer(connection, categoryKey);
// This example arbitrarily selects the first category offer in the list. Filter offers based on your needs.
const categoryOfferKey = categoryOffers[0].pubkey;

const ix = await takeCategoryOffer(
  connection,
  NAME_OFFERS_ID,
  categoryOfferKey,
  domainKey,
  memberKey,
  seller,
  referrer
);
</code></pre>
<p>Category offers can be cancelled using the <code>cancelCategoryOffer</code> function.</p>
<h3 id="p2p-offers"><a class="header" href="#p2p-offers">P2P Offers</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct P2pOffer {
    // Account tag
    pub tag: Tag,
    // Derivation nonce
    pub nonce: u8,
    // The owner of the p2p offer
    pub owner: Pubkey,
    // The counter party of the offer
    pub counter_party: Pubkey,
    // The domain(s) being traded
    pub domains: Vec&lt;Pubkey&gt;,
    // Domains against which the offer is priced
    pub quotes: Vec&lt;Pubkey&gt;,
    // Amount of SOL (in addition to the quote domains)
    pub amount: i64,
    // Expiry timestamp in seconds
    pub expiry_ts: u64,
}
<span class="boring">}</span></code></pre></pre>
<p>P2P (Peer-to-Peer) Offers enable direct transactions between a buyer and a seller without listing the domain publicly. Sellers can create a P2P offer specifying the buyer's address, the SOL amount, the domain names involved and optionally set an expiration date to the offer.</p>
<p>P2P offers can be created using the <code>makeP2p</code> function</p>
<pre><code class="language-ts">const amount = 10 * LAMPORTS_PER_SOL; // The SOL amount (in lamports) of the P2P offer (can be 0)
const owner = new PublicKey("..."); // The owner of the P2P offer (i.e creator)
const baseDomains: PublicKey[] = []; // The domains the owner wants to sell
const quoteDomains: PublicKey[] = []; // The domains the owner wants to buy (i.e the domains of the counter party)
const endDate: number | undefined = undefined; // The unix timestamp (in seconds) at which the P2P offer expires (optional)
const counterParty = new PublicKey("..."); // The counter party of the P2P offer

const ix = await makeP2p(
  amount,
  owner,
  baseDomains,
  quoteDomains,
  endDate,
  counterParty,
  NAME_OFFERS_ID
);
</code></pre>
<p>P2P offers can be accepted using the <code>acceptP2p</code> function</p>
<pre><code class="language-ts">const p2pOfferKey = new PublicKey("..."); // The P2P offer key

const ix = await acceptP2p(connection, NAME_OFFERS_ID, p2pOfferKey);
</code></pre>
<p>P2P offers can be cancelled using <code>cancelP2p</code></p>
<h2 id="nft-marketplace"><a class="header" href="#nft-marketplace">NFT Marketplace</a></h2>
<p>Tokenized domain names can be purchased on NFT marketplaces such as <a href="https://magiceden.io/marketplace/sns">Magic Eden</a> and <a href="https://www.tensor.trade/trade/sns">Tensor</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sns-suggest-introduction---alpha"><a class="header" href="#sns-suggest-introduction---alpha">SNS Suggest Introduction - Alpha</a></h1>
<p>The SNS Suggest API can be used by applications looking to offer autocomplete or autosuggest for <code>.sol</code> domains.</p>
<p>‚ö†Ô∏è This API is not meant to replace the blockchain as the source of truth. The blockchain should always be considered as the only source of truth. This API is only a snapshot of the blockchain at a certain point in time and might be stale by a few seconds/minutes.</p>
<p>‚ö†Ô∏è This feature is currently experimental and is subject to change</p>
<p>This API is using MeiliSearch under the hood, you can refer to its documentation for more details <a href="https://docs.meilisearch.com">https://docs.meilisearch.com</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="current-owner"><a class="header" href="#current-owner">Current owner</a></h2>
<p>The current owner endpoint will return the following information:</p>
<ul>
<li>Domain name (<code>String</code>)</li>
<li>Domain key (<code>String</code>)</li>
<li>Domain token mint: The mint of the NFT representing the domain if it is tokenized (<code>String</code>)</li>
<li>Domain auction key: The key of the auction state associated to the domain (<code>String</code>)</li>
<li>Owner key: The key of the current owner of the domain (<code>String</code>)</li>
<li>Availability ID: The enum described <a href="sns-suggest//sns-api/index.html">here</a> (<code>Option&lt;i16&gt;</code>)</li>
<li>Price: The price of the domain if the domain is available (<code>Option&lt;f32&gt;</code>)</li>
<li>Quote mint: The mint in which the domain is quoted if it is available</li>
<li>Fixed price key: The key of current fixed price offer if it exists (<code>Option&lt;String&gt;</code>)</li>
</ul>
<h3 id="search"><a class="header" href="#search">Search</a></h3>
<p>To search for domains that match a certain keywaord (e.g <code>00</code>):</p>
<pre><code>curl \
  -X POST 'https://sns-suggest-proxy.bonfida.com' \
  -H 'Content-Type: application/json' \
  --data-binary '{
    "q": "00" &lt;- You keywords
  }'

</code></pre>
<pre><code class="language-json">{
  "hits": [
    {
      "domain_name": "00",
      "id": "00",
      "domain_key": "4oZe4sxw1cSbm4KoiukMs6FSG6zW8rzKgkLDPQd5Gk6Q",
      "domain_token_mint": "HWDX6pDdb3mp2223PzLccezouex1m4LLEw9GTjV85Rkx",
      "domain_auction_key": "ctPQ35SSXvti38NmNYmwy9Lk4EtyxHMZViVNSZNTPUo",
      "owner_key": "5Aw5mkykrqMj8tbqzKVrgBW79w26ha1ELe3zj6ZKYz4b",
      "availability_id": null,
      "price": null,
      "quote_mint": null,
      "fixed_price_offer_account": null
    }
    //...
  ],
  "query": "",
  "processingTimeMs": 0,
  "limit": 20,
  "offset": 0,
  "estimatedTotalHits": 1000
}
</code></pre>
<p>The search feature is <strong>typo tolerent</strong></p>
<h3 id="simple-ui-integration"><a class="header" href="#simple-ui-integration">Simple UI integration</a></h3>
<p>Below is a simple React hook example</p>
<pre><code class="language-ts">import axios from "axios";
import { useState, useEffect, useRef } from "react";

export interface Item {
  domain_name: string;
  id: string;
  domain_key: string;
  domain_token_mint: string;
  domain_auction_key: string;
  owner_key: string | null | undefined;
  availability_id: number | null | undefined;
  price: number | null | undefined;
  quote_mint: string | null | undefined;
  fixed_price_offer_account: string | null | undefined;
}

export interface Result {
  hits: Item[];
  query: string;
  processingTimeMs: number;
  limit: number;
  offset: number;
  estimatedTotalHits: number;
}

const URL = "https://sns-suggest-proxy.bonfida.com";

export const useDomainAutoSuggest = (domain: string) =&gt; {
  const [result, setResult] = useState&lt;Item[] | undefined&gt;(undefined);
  const mounted = useRef(true);

  useEffect(() =&gt; {
    const fn = async () =&gt; {
      const payload = { q: domain };

      const { data }: { data: Result } = await axios.post(URL, payload, {
        headers: {
          "Content-type": "application/json",
        },
      });

      if (mounted.current) {
        setResult(data.hits);
      }

      return () =&gt; (mounted.current = false);
    };
    fn().catch(console.error);
  }, [domain]);

  return result;
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sns-quicknode-api"><a class="header" href="#sns-quicknode-api">SNS Quicknode API</a></h1>
<p>The Solana Name Service Quicknode marketplace plugin accepts requests using the <a href="https://www.jsonrpc.org/specification">JSON-RPC-2.0</a> specification over <code>HTTP POST</code>.</p>
<p>This means that it accepts <code>HTTP POST</code> requests with the <code>Content-Type</code> header set to <code>application/json</code>, containing a json payload. For example:</p>
<pre><code class="language-json">{
    "jsonrpc": "2.0",
    "method": "get_domain_key",
    "params": {
        "domain": "bonfida.sol"
    },
    "id": 5678
}
</code></pre>
<p>The response is a JSON object. For example:</p>
<pre><code class="language-json">{
    "jsonrpc": "2.0",
    "result": "HKKp49qGWXd639QsuH7JiLijfVW5UtCVY4s1n2HANwEA",
    "id": 5678
}
</code></pre>
<p>The API supports a variety of methods which are detailed in this chapter.</p>
<!-- ## `get_all_domains_for_owner`

Returns the list of SNS domains currently owned by a given account.

### Parameters

- **owner** `string` *required*: A base58-encoded Solana Pubkey.

### Result

The result will be an RPCResponse JSON object with field:

- **value** `string[]`: A list of owned domain names

## `get_domain_data`

Returns base64 encoded contents of the domain's data payload, or those of an associated record.

### Parameters

- **domain** `string` *required*: The domain name to query.
- **record** `string` *optional*: The associated record to get the data from instead.

### Result

The result will be an RPCResponse JSON object with field:

- **value** `string`: A base64 encoding of the record or domain's data payload.

## `get_domain_key`

Returns a domain's Solana account public key.

### Parameters

- **domain** `string` *required*: The domain name to query for.

### Result

The result will be an RPCResponse JSON object with field:

- **value** `string`: A base58-encoded Solana public key.

## `get_domain_record_key`

Returns a domain's Solana account public key.

### Parameters

- **domain** `string` *required*: The domain name to query for.
- **record** `string` *required*: The record identifier to query for.

### Result

The result will be an RPCResponse JSON object with field:

- **value** `string`: A base58-encoded Solana public key.

## `get_domain_reverse_key`

Returns a domain's reverse registry Solana account public key.

### Parameters

- **domain** `string` *required*: The domain name to query for.

### Result

The result will be an RPCResponse JSON object with field:

- **value** `string`: A base58-encoded Solana public key.

## `get_favourite_domain`

Returns a user wallet's favourite (i.e. primary) domain.

### Parameters

- **owner** `string` *required*: The base58-encoded Solana public key of the wallet to query for.

### Result

The result will be an RPCResponse JSON object with field:

- **value** `string`: The domain name.

## `get_registration_transaction`

Returns a ready-to-sign, base64-encoded transaction object to register a new SNS domain.

### Parameters

- **domain** `string` *required*: The domain name.
- **buyer** `string` *required*: The base58-encoded Solana public key of the buyer's paying wallet.
- **buyer_token_account** `string` *required*: The base58-encoded Solana public key of the buyer's paying token account.
- **space** `integer` *required*: The number of bytes to allocate in the new registered domain.
- **mint** `string` *optional*: The Solana public key of the Token mint used for payment, defaults to `EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v` (USDC).
- **referrer_key** `string` *optional*: The base58-encoded Solana public key of the registration referrer.

### Result

The result will be an RPCResponse JSON object with field:

- **value** `string`: The base64-encoded Solana Transaction object.

## `get_subdomains`

Returns a list of currently registered subdomains for a given domain.

### Parameters

- **domain** `string` *required*: The domain name.

### Result

The result will be an RPCResponse JSON object with field:

- **value** `string[]`: The list of currently registered subdomain names.

## `get_supported_records`

Returns a list of all the currently supported record types.

### Parameters

None

### Result

The result will be an RPCResponse JSON object with field:

- **value** `string[]`: The list of currently supported record types.

## `resolve_domain`

Returns the resolved Solana Public key associated to a domain.

### Parameters

- **domain** `string` *required*: The domain name to resolve.

### Result

The result will be an RPCResponse JSON object with field:

- **value** `string`: The base-58 encoded Solana Public Key the domain resolves to.

## `reverse_lookup`

Returns the domain name associated with a raw SNS account.

### Parameters

- **domain_key** `string` *required*: The base58-encoded public key of the Solana account to reverse lookup.

### Result

The result will be an RPCResponse JSON object with field:

- **value** `string`: The domain name. -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="sns_getalldomainsforowner"><a class="header" href="#sns_getalldomainsforowner"><code>sns_getAllDomainsForOwner</code></a></h1>
<p>Returns the list of SNS domains currently owned by a given account.</p>
<h2 id="parameters"><a class="header" href="#parameters">Parameters</a></h2>
<ul>
<li><strong>owner</strong> <code>string</code> <em>required</em>: A base58-encoded Solana Pubkey.</li>
</ul>
<h2 id="result"><a class="header" href="#result">Result</a></h2>
<p>The result will be an RPCResponse JSON object with field:</p>
<ul>
<li><strong>result</strong> <code>Domain[]</code>: A list of <code>Domain</code> objects</li>
</ul>
<p>The <code>Domain</code> Object contains two fields :</p>
<ul>
<li><strong>name</strong> <code>string</code>: The domain name</li>
<li><strong>key</strong> <code>string</code>: The domain's base-58 encoded public key</li>
</ul>
<h2 id="example-1"><a class="header" href="#example-1">Example</a></h2>
<pre><code class="language-json">{
  "jsonrpc": "2.0",
  "method": "sns_getAllDomainsForOwner",
  "params": [
    "HKKp49qGWXd639QsuH7JiLijfVW5UtCVY4s1n2HANwEA"
  ],
  "id": 42
}
</code></pre>
<pre><code class="language-json">{
  "jsonrpc": "2.0",
  "result": [
    {
      "key": "Crf8hzfthWGbGbLTVCiqRqV5MVnbpHB1L9KQMd6gsinb",
      "name": "bonfida"
    },
    {
      "key": "8xMJaFHqas1gzS7xLuWh298TDuBUw4hqLXL2ZFs376hH",
      "name": "springboks"
    },
    {
      "key": "BAW7NsKcY8SLr98ZNYcH2HeDvPBPE2EoyjuPKcJ9bW1d",
      "name": "9772"
    },
    {
      "key": "9B8y69VYEvLuwnaPdqNWL2wrV2XCLKrNAewC3FQEXptn",
      "name": "üë®‚Äçüåæ"
    }
  ],
  "id": 42
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sns_getdomaindata"><a class="header" href="#sns_getdomaindata"><code>sns_getDomainData</code></a></h1>
<p>Returns base64 encoded contents of the domain's data payload, or those of an associated record.</p>
<h2 id="parameters-1"><a class="header" href="#parameters-1">Parameters</a></h2>
<ul>
<li><strong>domain</strong> <code>string</code> <em>required</em>: The domain name to query.</li>
<li><strong>record</strong> <code>string</code> <em>optional</em>: The associated record to get the data from instead.</li>
</ul>
<h2 id="result-1"><a class="header" href="#result-1">Result</a></h2>
<p>The result will be an RPCResponse JSON object with field:</p>
<ul>
<li><strong>result</strong> <code>string</code>: A base64 encoding of the record or domain's data payload.</li>
</ul>
<h2 id="example-2"><a class="header" href="#example-2">Example</a></h2>
<pre><code class="language-json">{
  "jsonrpc": "2.0",
  "method": "sns_getDomainData",
  "params": [
    "bonfida.sol",
    "github"
  ],
  "id": 42
}
</code></pre>
<pre><code class="language-json">{
  "jsonrpc": "2.0",
  "result": "aHR0cHM6Ly9naXRodWIuY29tL0JvbmZpZGEvAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=",
  "id": 42
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sns_getdomainkey"><a class="header" href="#sns_getdomainkey"><code>sns_getDomainKey</code></a></h1>
<p>Returns a domain's Solana account public key.</p>
<h2 id="parameters-2"><a class="header" href="#parameters-2">Parameters</a></h2>
<ul>
<li><strong>domain</strong> <code>string</code> <em>required</em>: The domain name to query for.</li>
</ul>
<h2 id="result-2"><a class="header" href="#result-2">Result</a></h2>
<p>The result will be an RPCResponse JSON object with field:</p>
<ul>
<li><strong>result</strong> <code>string</code>: A base58-encoded Solana public key.</li>
</ul>
<h2 id="example-3"><a class="header" href="#example-3">Example</a></h2>
<pre><code class="language-json">{
  "jsonrpc": "2.0",
  "method": "sns_getDomainKey",
  "params": [
    "bonfida.sol"
  ],
  "id": 42
}
</code></pre>
<pre><code class="language-json">{
  "jsonrpc": "2.0",
  "result": "Crf8hzfthWGbGbLTVCiqRqV5MVnbpHB1L9KQMd6gsinb",
  "id": 42
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sns_getdomainrecordkey"><a class="header" href="#sns_getdomainrecordkey"><code>sns_getDomainRecordKey</code></a></h1>
<p>Returns a domain record's Solana account public key. Supported record identifier include <code>SOL</code>, <code>ETH</code> and <code>IPFS</code>. The <code>get_supported_records</code> method returns a list of all supported records.</p>
<h2 id="parameters-3"><a class="header" href="#parameters-3">Parameters</a></h2>
<ul>
<li><strong>domain</strong> <code>string</code> <em>required</em>: The domain name to query for.</li>
<li><strong>record</strong> <code>string</code> <em>required</em>: The record identifier to query for.</li>
</ul>
<h2 id="result-3"><a class="header" href="#result-3">Result</a></h2>
<p>The result will be an RPCResponse JSON object with field:</p>
<ul>
<li><strong>result</strong> <code>string</code>: A base58-encoded Solana public key.</li>
</ul>
<h2 id="example-4"><a class="header" href="#example-4">Example</a></h2>
<pre><code class="language-json">{
  "jsonrpc": "2.0",
  "method": "sns_getDomainRecordKey",
  "params": [
    "bonfida.sol",
    "github"
  ],
  "id": 42
}
</code></pre>
<pre><code class="language-json">{
  "jsonrpc": "2.0",
  "result": "4sQDE98ZzQ23Rygb7tx1HhXQiuxswKhSBvECCREW35Ei",
  "id": 42
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sns_getfavouritedomain"><a class="header" href="#sns_getfavouritedomain"><code>sns_getFavouriteDomain</code></a></h1>
<p>Returns a user wallet's favourite (i.e. primary) domain.</p>
<h2 id="parameters-4"><a class="header" href="#parameters-4">Parameters</a></h2>
<ul>
<li><strong>owner</strong> <code>string</code> <em>required</em>: The base58-encoded Solana public key of the wallet to query for.</li>
</ul>
<h2 id="result-4"><a class="header" href="#result-4">Result</a></h2>
<p>The result will be an RPCResponse JSON object with field:</p>
<ul>
<li><strong>result</strong> <code>Domain</code>: A <code>Domain</code> object describig the requested domain name.</li>
</ul>
<p>The <code>Domain</code> Object contains two fields :</p>
<ul>
<li><strong>name</strong> <code>string</code>: The domain name</li>
<li><strong>key</strong> <code>string</code>: The domain's base-58 encoded public key</li>
</ul>
<h2 id="example-5"><a class="header" href="#example-5">Example</a></h2>
<pre><code class="language-json">{
  "jsonrpc": "2.0",
  "method": "sns_getFavouriteDomain",
  "params": [
    "HKKp49qGWXd639QsuH7JiLijfVW5UtCVY4s1n2HANwEA"
  ],
  "id": 42
}
</code></pre>
<pre><code class="language-json">{
  "jsonrpc": "2.0",
  "result": {
    "key": "Crf8hzfthWGbGbLTVCiqRqV5MVnbpHB1L9KQMd6gsinb",
    "name": "bonfida"
  },
  "id": 42
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sns_getregistrationtransaction"><a class="header" href="#sns_getregistrationtransaction"><code>sns_getRegistrationTransaction</code></a></h1>
<p>Returns a ready-to-sign, base64-encoded transaction object to register a new SNS domain.</p>
<h2 id="parameters-5"><a class="header" href="#parameters-5">Parameters</a></h2>
<ul>
<li><strong>domain</strong> <code>string</code> <em>required</em>: The domain name.</li>
<li><strong>buyer</strong> <code>string</code> <em>required</em>: The base58-encoded Solana public key of the buyer's paying wallet.</li>
<li><strong>buyer_token_account</strong> <code>string</code> <em>required</em>: The base58-encoded Solana public key of the buyer's paying token account.</li>
<li><strong>space</strong> <code>integer</code> <em>required</em>: The number of bytes to allocate in the new registered domain.</li>
<li><strong>mint</strong> <code>string</code> <em>optional</em>: The Solana public key of the Token mint used for payment, defaults to <code>EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v</code> (USDC).</li>
<li><strong>referrer_key</strong> <code>string</code> <em>optional</em>: The base58-encoded Solana public key of the registration referrer.</li>
</ul>
<h2 id="result-5"><a class="header" href="#result-5">Result</a></h2>
<p>The result will be an RPCResponse JSON object with field:</p>
<ul>
<li><strong>result</strong> <code>string</code>: The base64-encoded Solana Transaction object.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sns_getsubdomains"><a class="header" href="#sns_getsubdomains"><code>sns_getSubdomains</code></a></h1>
<p>Returns a list of currently registered subdomains for a given domain.</p>
<h2 id="parameters-6"><a class="header" href="#parameters-6">Parameters</a></h2>
<ul>
<li><strong>domain</strong> <code>string</code> <em>required</em>: The domain name.</li>
</ul>
<h2 id="result-6"><a class="header" href="#result-6">Result</a></h2>
<p>The result will be an RPCResponse JSON object with field:</p>
<ul>
<li><strong>result</strong> <code>string[]</code>: The list of currently registered subdomain name account keys, encoded as base58.</li>
</ul>
<h2 id="example-6"><a class="header" href="#example-6">Example</a></h2>
<pre><code class="language-json">{
  "jsonrpc": "2.0",
  "method": "sns_getSubdomains",
  "params": [
    "bonfida.sol"
  ],
  "id": 42
}
</code></pre>
<pre><code class="language-json">{
  "jsonrpc": "2.0",
  "result": [
    "naming",
    "dex",
    "test"
  ],
  "id": 42
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sns_getsupportedrecords"><a class="header" href="#sns_getsupportedrecords"><code>sns_getSupportedRecords</code></a></h1>
<p>Returns a list of all the currently supported record types.</p>
<h2 id="parameters-7"><a class="header" href="#parameters-7">Parameters</a></h2>
<p>None</p>
<h2 id="result-7"><a class="header" href="#result-7">Result</a></h2>
<p>The result will be an RPCResponse JSON object with field:</p>
<ul>
<li><strong>result</strong> <code>string[]</code>: The list of currently supported record types.</li>
</ul>
<h2 id="example-7"><a class="header" href="#example-7">Example</a></h2>
<pre><code class="language-json">{
  "jsonrpc": "2.0",
  "method": "sns_getSupportedRecords",
  "params": [],
  "id": 42
}
</code></pre>
<pre><code class="language-json">{
  "jsonrpc": "2.0",
  "result": [
    "IPFS",
    "ARWV",
    "SOL",
    "ETH",
    "BTC",
    "LTC",
    "DOGE",
    "email",
    "url",
    "discord",
    "github",
    "reddit",
    "twitter",
    "telegram",
    "pic",
    "SHDW",
    "POINT",
    "BSC",
    "INJ",
    "backpack"
  ],
  "id": 42
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sns_resolvedomain"><a class="header" href="#sns_resolvedomain"><code>sns_resolveDomain</code></a></h1>
<p>Returns the resolved Solana Public key associated to a domain.</p>
<h2 id="parameters-8"><a class="header" href="#parameters-8">Parameters</a></h2>
<ul>
<li><strong>domain</strong> <code>string</code> <em>required</em>: The domain name to resolve.</li>
</ul>
<h2 id="result-8"><a class="header" href="#result-8">Result</a></h2>
<p>The result will be an RPCResponse JSON object with field:</p>
<ul>
<li><strong>value</strong> <code>string</code>: The base-58 encoded Solana Public Key the domain resolves to.</li>
</ul>
<h2 id="example-8"><a class="header" href="#example-8">Example</a></h2>
<pre><code class="language-json">{
  "jsonrpc": "2.0",
  "method": "sns_resolveDomain",
  "params": [
    "bonfida.sol"
  ],
  "id": 42
}
</code></pre>
<pre><code class="language-json">{
  "jsonrpc": "2.0",
  "result": "HKKp49qGWXd639QsuH7JiLijfVW5UtCVY4s1n2HANwEA",
  "id": 42
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sns_reverse_lookup"><a class="header" href="#sns_reverse_lookup"><code>sns_reverse_lookup</code></a></h1>
<p>Returns the domain name associated with a raw SNS account.</p>
<h2 id="parameters-9"><a class="header" href="#parameters-9">Parameters</a></h2>
<ul>
<li><strong>domain_key</strong> <code>string</code> <em>required</em>: The base58-encoded public key of the Solana account to reverse lookup.</li>
</ul>
<h2 id="result-9"><a class="header" href="#result-9">Result</a></h2>
<p>The result will be an RPCResponse JSON object with field:</p>
<ul>
<li><strong>value</strong> <code>string</code>: The domain name.</li>
</ul>
<h2 id="example-9"><a class="header" href="#example-9">Example</a></h2>
<pre><code class="language-json">{
  "jsonrpc": "2.0",
  "method": "sns_reverseLookup",
  "params": [
    "Crf8hzfthWGbGbLTVCiqRqV5MVnbpHB1L9KQMd6gsinb"
  ],
  "id": 42
}
</code></pre>
<pre><code class="language-json">{
  "jsonrpc": "2.0",
  "result": "bonfida",
  "id": 42
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sns_getdomainreversekey"><a class="header" href="#sns_getdomainreversekey"><code>sns_getDomainReverseKey</code></a></h1>
<p>Returns a domain's reverse registry Solana account public key.</p>
<h2 id="parameters-10"><a class="header" href="#parameters-10">Parameters</a></h2>
<ul>
<li><strong>domain</strong> <code>string</code> <em>required</em>: The domain name to query for.</li>
</ul>
<h2 id="result-10"><a class="header" href="#result-10">Result</a></h2>
<p>The result will be an RPCResponse JSON object with field:</p>
<ul>
<li><strong>result</strong> <code>string</code>: A base58-encoded Solana public key.</li>
</ul>
<h2 id="example-10"><a class="header" href="#example-10">Example</a></h2>
<pre><code class="language-json">{
  "jsonrpc": "2.0",
  "method": "sns_getDomainReverseKey",
  "params": [
    "bonfida.sol"
  ],
  "id": 42
}
</code></pre>
<pre><code class="language-json">{
  "jsonrpc": "2.0",
  "result": "DqgmWxe2PPrfy45Ja3UPyFGwcbRzkRuwXt3NyxjX8krg",
  "id": 42
}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
