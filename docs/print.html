<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Solana Name Service Guide</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="deployment.html"><strong aria-hidden="true">2.</strong> Deployment</a></li><li class="chapter-item expanded "><a href="installation.html"><strong aria-hidden="true">3.</strong> SNS Library</a></li><li class="chapter-item expanded "><a href="changelog.html"><strong aria-hidden="true">4.</strong> Changelog</a></li><li class="chapter-item expanded "><a href="faq.html"><strong aria-hidden="true">5.</strong> FAQ</a></li><li class="chapter-item expanded "><a href="registry.html"><strong aria-hidden="true">6.</strong> Name Registry</a></li><li class="chapter-item expanded "><a href="domain-name/wallet-guide/index.html"><strong aria-hidden="true">7.</strong> Wallet Guide</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="domain-name/wallet-guide/resolving-domains.html"><strong aria-hidden="true">7.1.</strong> Resolving Domains</a></li><li class="chapter-item expanded "><a href="domain-name/wallet-guide/bridged-domains.html"><strong aria-hidden="true">7.2.</strong> Bridged Domains</a></li><li class="chapter-item expanded "><a href="domain-name/wallet-guide/twitter-handles.html"><strong aria-hidden="true">7.3.</strong> Twitter handles</a></li></ol></li><li class="chapter-item expanded "><a href="domain-name/index.html"><strong aria-hidden="true">8.</strong> Domain Name</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="domain-name/domain-tld.html"><strong aria-hidden="true">8.1.</strong> TLD</a></li><li class="chapter-item expanded "><a href="domain-name/web-resolution.html"><strong aria-hidden="true">8.2.</strong> Web resolution</a></li><li class="chapter-item expanded "><a href="domain-name/domain-direct-lookup.html"><strong aria-hidden="true">8.3.</strong> Direct look up</a></li><li class="chapter-item expanded "><a href="domain-name/domain-reverse-lookup.html"><strong aria-hidden="true">8.4.</strong> Reverse look up</a></li><li class="chapter-item expanded "><a href="domain-name/subdomain-lookup.html"><strong aria-hidden="true">8.5.</strong> Subdomain look up</a></li><li class="chapter-item expanded "><a href="domain-name/domain-find-for-owner.html"><strong aria-hidden="true">8.6.</strong> Get all domains of a user</a></li><li class="chapter-item expanded "><a href="domain-name/all-domains.html"><strong aria-hidden="true">8.7.</strong> Get all domains</a></li><li class="chapter-item expanded "><a href="domain-name/records.html"><strong aria-hidden="true">8.8.</strong> Records</a></li><li class="chapter-item expanded "><a href="domain-name/edit-domain-content.html"><strong aria-hidden="true">8.9.</strong> Edit domain content</a></li><li class="chapter-item expanded "><a href="domain-name/transfer.html"><strong aria-hidden="true">8.10.</strong> Transfer domains</a></li><li class="chapter-item expanded "><a href="domain-name/favorite-domain.html"><strong aria-hidden="true">8.11.</strong> Favorite domain</a></li><li class="chapter-item expanded "><a href="domain-name/react-hooks/index.html"><strong aria-hidden="true">8.12.</strong> React hooks</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="domain-name/react-hooks/use-domains.html"><strong aria-hidden="true">8.12.1.</strong> useDomains</a></li><li class="chapter-item expanded "><a href="domain-name/react-hooks/use-domain-records.html"><strong aria-hidden="true">8.12.2.</strong> useDomainRecords</a></li><li class="chapter-item expanded "><a href="domain-name/react-hooks/use-domains-for-user.html"><strong aria-hidden="true">8.12.3.</strong> useDomainsForUser</a></li><li class="chapter-item expanded "><a href="domain-name/react-hooks/use-favorite-domain.html"><strong aria-hidden="true">8.12.4.</strong> useFavoriteDomain</a></li><li class="chapter-item expanded "><a href="domain-name/react-hooks/use-profile-pic.html"><strong aria-hidden="true">8.12.5.</strong> useProfilePic</a></li></ol></li><li class="chapter-item expanded "><a href="domain-name/tokenization.html"><strong aria-hidden="true">8.13.</strong> Tokenization</a></li><li class="chapter-item expanded "><a href="domain-name/registration.html"><strong aria-hidden="true">8.14.</strong> Registration</a></li><li class="chapter-item expanded "><a href="domain-name/media-kit.html"><strong aria-hidden="true">8.15.</strong> Media kit</a></li><li class="chapter-item expanded "><a href="domain-name/delete-domain.html"><strong aria-hidden="true">8.16.</strong> Delete domains</a></li><li class="chapter-item expanded "><a href="domain-name/create-subdomain.html"><strong aria-hidden="true">8.17.</strong> Creating subdomains</a></li><li class="chapter-item expanded "><a href="domain-name/sns-examples/index.html"><strong aria-hidden="true">8.18.</strong> Examples</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="domain-name/sns-examples/derivations.html"><strong aria-hidden="true">8.18.1.</strong> Key derivations</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="twitter/index.html"><strong aria-hidden="true">9.</strong> Twitter</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="twitter/twitter-tld.html"><strong aria-hidden="true">9.1.</strong> TLD</a></li><li class="chapter-item expanded "><a href="twitter/register.html"><strong aria-hidden="true">9.2.</strong> Registration</a></li><li class="chapter-item expanded "><a href="twitter/twitter-direct-lookup.html"><strong aria-hidden="true">9.3.</strong> Direct look up</a></li><li class="chapter-item expanded "><a href="twitter/twitter-reverse-lookup.html"><strong aria-hidden="true">9.4.</strong> Reverse look up</a></li></ol></li><li class="chapter-item expanded "><a href="sns-api/index.html"><strong aria-hidden="true">10.</strong> SNS API</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="sns-api/categories.html"><strong aria-hidden="true">10.1.</strong> Categories</a></li><li class="chapter-item expanded "><a href="sns-api/sales.html"><strong aria-hidden="true">10.2.</strong> Sales</a></li><li class="chapter-item expanded "><a href="sns-api/volumes.html"><strong aria-hidden="true">10.3.</strong> Volumes</a></li><li class="chapter-item expanded "><a href="sns-api/owners.html"><strong aria-hidden="true">10.4.</strong> Owners</a></li></ol></li><li class="chapter-item expanded "><a href="sns-suggest/index.html"><strong aria-hidden="true">11.</strong> SNS Suggest API - Alpha</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="sns-suggest/current-owner.html"><strong aria-hidden="true">11.1.</strong> Current Owner</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Solana Name Service Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p><img src="./assets/introduction.gif" alt="introduction" /></p>
<h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Welcome to the Solana Name Service (SNS). SNS has a simple mission of providing a decentralized and yet affordable way to map domain names (represented as .sol) to on-chain data. Where on-chain data can be anything from a Solana (SOL) address to IPFS CID, images, text, and more.
One of the clear benefits of the name service is a human-readable name that maps to a SOL address. Essentially, creating an identity for users in the metaverse.
Why does this matter you may ask? Well, wallet address formats can be a barrier to entry, and therefore having an identifiable address can facilitate payments and its efficiency.
Nonetheless, Solana domain names can have much broader applications than just payments. Most decentralized apps (dApps) have a single point of failure which is their centralized and censorable domain name. However, on-chain domain names cannot be censored or taken away! Thus a website hosted on IPFS (or Arweave) using a Solana domain name would be completely decentralized and very difficult to censor.</p>
<h2 id="twitter-handles--sol-domain-names"><a class="header" href="#twitter-handles--sol-domain-names">Twitter handles &amp; .sol domain names</a></h2>
<p>Both Twitter handles and .sol domain names are a part of SNS, yet are slightly different. A Twitter handle can only be claimed by the owner of the Twitter account. In order to guarantee this, the user needs to tweet the wallet address they want to associate with the account and then sign a transaction using the same wallet address. An oracle then verifies that the public key contained in the tweet matches with the signer. In practice, this means that Twitter names are already reserved. Twitter users just need to claim their public key by tweeting it.
Still, this has privacy implications that require you to have an identifiable Twitter account. This is where .sol domain names are useful. The domain names serve the same purpose as Twitter handles except they do not require you to reveal any personal information or a Twitter account.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deployment"><a class="header" href="#deployment">Deployment</a></h1>
<p>The Solana Name Service program is deployed on <a href="https://explorer.solana.com/address/namesLPneVptA9Z5rqUDD9tMTWEJwofgaYwp8cawRkX">Mainnet</a>, <a href="https://explorer.solana.com/address/namesLPneVptA9Z5rqUDD9tMTWEJwofgaYwp8cawRkX?cluster=devnet">Devnet</a> and <a href="https://explorer.solana.com/address/namesLPneVptA9Z5rqUDD9tMTWEJwofgaYwp8cawRkX?cluster=testnet">Testnet</a> at the following address:</p>
<pre><code>namesLPneVptA9Z5rqUDD9tMTWEJwofgaYwp8cawRkX
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sns-sdk"><a class="header" href="#sns-sdk">SNS SDK</a></h1>
<p>The SNS SDK monorepo can be found <a href="https://github.com/Bonfida/sns-sdk">here</a>. It contains SDK for:</p>
<ul>
<li><a href="https://crates.io/crates/sns-sdk">A Rust SDK</a></li>
<li><a href="https://github.com/Bonfida/sns-sdk#javascript">A Javascript SDK</a></li>
<li><a href="https://github.com/Bonfida/sns-sdk#react">A React hooks library</a></li>
<li><a href="https://github.com/Bonfida/sns-sdk#cli">A CLI</a></li>
</ul>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<h3 id="rust-sdk"><a class="header" href="#rust-sdk">Rust SDK</a></h3>
<pre><code>cargo add sns-sdk
</code></pre>
<p>or</p>
<pre><code>sns-sdk = &quot;0.1.0&quot;
</code></pre>
<h3 id="js-library"><a class="header" href="#js-library">JS Library</a></h3>
<p>To install the <a href="https://www.npmjs.com/package/@bonfida/spl-name-service">JS library</a></p>
<pre><code class="language-js">npm i @bonfida/spl-name-service
</code></pre>
<p>or</p>
<pre><code class="language-js">yarn add @bonfida/spl-name-service
</code></pre>
<p>To install the React</p>
<h3 id="react-hooks"><a class="header" href="#react-hooks">React hooks</a></h3>
<p>To install the <a href="https://www.npmjs.com/package/@bonfida/sns-react">React hooks library</a></p>
<pre><code>npm i @bonfida/sns-react
</code></pre>
<p>or</p>
<pre><code>yarn add @bonfida/sns-react
</code></pre>
<h3 id="cli"><a class="header" href="#cli">CLI</a></h3>
<pre><code>cargo install --git https://github.com/Bonfida/sns-sdk.git sns
</code></pre>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<p>The following examples show how to resolve the domain <code>bonfida.sol</code>:</p>
<ol>
<li>With the JS SDK</li>
</ol>
<pre><code class="language-js">const connection = new Connection(clusterApiUrl(&quot;mainnet-beta&quot;));
const owner = await resolve(connection, &quot;bonfida&quot;);
expect(owner.toBase58()).toBe(&quot;HKKp49qGWXd639QsuH7JiLijfVW5UtCVY4s1n2HANwEA&quot;);
</code></pre>
<ol start="2">
<li>With the Rust SDK</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let client = RpcClient::new(std::env::var(&quot;RPC_URL&quot;).unwrap());
let res = resolve_owner(&amp;client, &quot;bonfida&quot;).await.unwrap();
assert_eq!(res, pubkey!(&quot;HKKp49qGWXd639QsuH7JiLijfVW5UtCVY4s1n2HANwEA&quot;));
<span class="boring">}</span></code></pre></pre>
<ol start="3">
<li>With the CLI</li>
</ol>
<pre><code class="language-bash">$ sns resolve bonfida

+---------+----------------------------------------------+----------------------------------------------------------------------------------+
| Domain  | Owner                                        | Explorer                                                                         |
+---------+----------------------------------------------+----------------------------------------------------------------------------------+
| bonfida | HKKp49qGWXd639QsuH7JiLijfVW5UtCVY4s1n2HANwEA | https://explorer.solana.com/address/HKKp49qGWXd639QsuH7JiLijfVW5UtCVY4s1n2HANwEA |
+---------+----------------------------------------------+----------------------------------------------------------------------------------+
</code></pre>
<ol start="5">
<li>With the React SDK</li>
</ol>
<pre><code class="language-ts">import { useConnection, useWallet } from &quot;@solana/wallet-adapter-react&quot;;
import { useDomainOwner, useDomainsForOwner } from &quot;@bonfida/sns-react&quot;;

export const Example = () =&gt; {
  const { connection } = useConnection();
  const { publicKey, connected } = useWallet();
  const { result } = useDomainOwner(connection, &quot;bonfida&quot;);
  // ...
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="changelog"><a class="header" href="#changelog">Changelog</a></h1>
<ul>
<li><code>0.1.50</code>: add <code>POINT</code> record</li>
<li><code>0.1.41</code>: add <code>getAllRegisteredDomains</code></li>
<li><code>0.1.40</code>: fix <code>performReverseLookupBatch</code></li>
<li><code>0.1.39</code>: add <code>Record</code> <code>enum</code> and records getter functions</li>
<li><code>0.1.38</code>: add <code>getFavoriteDomain</code>, <code>getDomainKey</code> and <code>getAllDomains</code></li>
<li>In version <code>0.1.26</code> the signature of <code>NameRegistryState.retrieve</code> changed, it is now returning an object of type <code>{ registry: NameRegistryState, nftOwner: PublicKey | undefined }</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="faq"><a class="header" href="#faq">FAQ</a></h1>
<h2 id="where-can-i-buy-a-domain"><a class="header" href="#where-can-i-buy-a-domain">Where can I buy a domain?</a></h2>
<p>You can buy a domain on the <a href="https://sns.id">Solana Name Service website</a></p>
<h2 id="how-do-i-find-a-domain-if-i-only-know-its-public-key"><a class="header" href="#how-do-i-find-a-domain-if-i-only-know-its-public-key">How do I find a domain if I only know its public key?</a></h2>
<p>If you only know the public key of a domain you can do a reverse look up to find the associated domain. For example:</p>
<pre><code class="language-js">import { performReverseLookup } from &quot;@bonfida/spl-name-service&quot;;

// Public key of bonfida.sol
const domainKey = new PublicKey(&quot;Crf8hzfthWGbGbLTVCiqRqV5MVnbpHB1L9KQMd6gsinb&quot;);

const domainName = await performReverseLookup(connection, domainKey); // bonfida
</code></pre>
<h2 id="how-do-i-find-the-public-key-of-a-domain"><a class="header" href="#how-do-i-find-the-public-key-of-a-domain">How do I find the public key of a domain?</a></h2>
<p>If you want to find the public key of a domain you need to derive it:</p>
<pre><code class="language-js">import {
  getHashedName,
  getNameAccountKey,
  NameRegistryState,
} from &quot;@bonfida/spl-name-service&quot;;

const domainName = &quot;bonfida&quot;; // Without the .sol

// Step 1
const hashedName = await getHashedName(domainName);

// Step 2
const domainKey = await getNameAccountKey(
  hashedName,
  undefined,
  SOL_TLD_AUTHORITY
);
</code></pre>
<h2 id="how-can-i-find-the-content-of-a-domain"><a class="header" href="#how-can-i-find-the-content-of-a-domain">How can I find the content of a domain?</a></h2>
<p>You can access the content of a domain by retrieving its registry:</p>
<pre><code class="language-js">const { registry } = await NameRegistryState.retrieve(connection, domainKey);
const { parentName, owner, class, data } = registry;
</code></pre>
<h2 id="how-do-i-find-the-twitter-handle-of-a-public-key"><a class="header" href="#how-do-i-find-the-twitter-handle-of-a-public-key">How do I find the twitter handle of a public key?</a></h2>
<p>To find the twitter handle of a public key</p>
<pre><code class="language-js">import { getHandleAndRegistryKey } from &quot;@bonfida/spl-name-service&quot;;

const pubkey = new PublicKey(&quot;FidaeBkZkvDqi1GXNEwB8uWmj9Ngx2HXSS5nyGRuVFcZ&quot;);

const [handle] = await getHandleAndRegistryKey(connection, pubkey);
</code></pre>
<h2 id="how-do-i-find-the-public-key-of-a-twitter-handle"><a class="header" href="#how-do-i-find-the-public-key-of-a-twitter-handle">How do I find the public key of a twitter handle?</a></h2>
<p>To find the public key of a twitter handle</p>
<pre><code class="language-js">import { getTwitterRegistry } from &quot;@bonfida/spl-name-service&quot;;

const handle = &quot;bonfida&quot;;

const registry = await getTwitterRegistry(connection, handle);
</code></pre>
<h2 id="how-do-i-find-all-the-subdomains-of-a-domain"><a class="header" href="#how-do-i-find-all-the-subdomains-of-a-domain">How do I find all the subdomains of a domain?</a></h2>
<p>You can find all the subdomains using the following RPC filter:</p>
<pre><code class="language-js">const filters = [
  {
    memcmp: {
      offset: 32,
      bytes: userAccount.toBase58(),
    },
  },
  {
    memcmp: {
      offset: 0,
      bytes: parent_key.toBase58(),
    },
  },
];
</code></pre>
<h2 id="how-do-i-find-all-the-subdomains-of-a-user"><a class="header" href="#how-do-i-find-all-the-subdomains-of-a-user">How do I find all the subdomains of a user?</a></h2>
<p>You can find all the subdomains of a user by doing the following</p>
<ol>
<li>Retrieve all the domains of the user</li>
<li>Iterate over the domains and retrieve the subdomains for each</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="name-registry-understanding-domains-on-solana"><a class="header" href="#name-registry-understanding-domains-on-solana">Name Registry: Understanding Domains on Solana</a></h1>
<p>Solana can be viewed as a key-value database, where everything, including domains, is uniquely identifiable by a public key. The data inside a domain account contains an object called the Name Registry. The Name Registry is made of a header and payload.</p>
<h2 id="name-registry-explained"><a class="header" href="#name-registry-explained">Name Registry Explained</a></h2>
<center>
<img src="assets/registry.png" alt="name-registry" />
</center>
<h3 id="name-registry-header"><a class="header" href="#name-registry-header">Name Registry Header</a></h3>
<p>The header contains three public keys that define the domain's properties:</p>
<ul>
<li><code>Parent</code>: Represents the parent domain in the hierarchy.</li>
<li><code>Owner</code>: Indicates the entity that has control over the domain.</li>
<li><code>Class</code>: A special key that enables advanced use-cases, such as third-party verification in a badge system.</li>
</ul>
<p>Below is the structure of the header in Rust:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// The layout of the remaining bytes in the account data are determined by the record `class`
#[derive(Clone, Debug, BorshSerialize, BorshDeserialize, PartialEq)]
pub struct NameRecordHeader {
    // Names are hierarchical.  `parent_name` contains the account address of the parent
    // name, or `Pubkey::default()` if no parent exists.
    pub parent_name: Pubkey,

    // The owner of this name
    pub owner: Pubkey,

    // The class of data this account represents (DNS record, twitter handle, SPL Token name/symbol, etc)
    //
    // If `Pubkey::default()` the data is unspecified.
    pub class: Pubkey,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="data-flexible-data-storage"><a class="header" href="#data-flexible-data-storage">Data: Flexible Data Storage</a></h3>
<p>The data section can hold arbitrary binary data. Its length is set during domain registration, and the domain owner can decide what to store in this part of the Name Registry.</p>
<p>In simple terms, the Name Registry data structure provides a way to organize and store information about a domain on Solana, including its relationships, ownership, and any additional data the owner wishes to include.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wallet-guide"><a class="header" href="#wallet-guide">Wallet Guide</a></h1>
<p>This is the step-by-step guide to help wallet providers integrate .sol domain names and Twitter handles as a way to use them to send and receive funds instead of a pubkey.</p>
<p>The guide lays out the process of integrating domains to both Solana and the other blockchains SNS has been bridged to. Specifically, it’ll aid you in understanding the nuanced aspects of resolving tokenized domains, those with record sections and subdomains.</p>
<p>The instructions are structured in a three-part layout:</p>
<p>7.1 <a href="domain-name/wallet-guide//domain-name/wallet-guide/resolving-domains.html">Resolving domains</a>: describes how to integrate domains on Solana</p>
<p>7.2 <a href="domain-name/wallet-guide//domain-name/wallet-guide/bridged-domains.html">Resolving bridged domains</a>: describes how to integrate domains on other chains</p>
<p>7.3 <a href="domain-name/wallet-guide//domain-name/wallet-guide/twitter-handles.html">Resolving Twitter handles</a>: describes how to integrate Twitter handles linked to a pubkey</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="resolving-domains"><a class="header" href="#resolving-domains">Resolving domains</a></h1>
<p>Below is the correct methodology to resolve <code>.sol</code> domain names. If you are a wallet or a service provider using SNS to send funds please make sure to follow these guidelines to avoid loss of funds.</p>
<p><img src="domain-name/wallet-guide/../../assets/wallet-guide.png" alt="wallet-guide" /></p>
<ol>
<li>
<p>Check if the domain name is tokenized</p>
<ul>
<li><strong>Yes:</strong> The correct destination of funds is the token holder</li>
<li><strong>No:</strong> Go to step 2</li>
</ul>
</li>
<li>
<p>Check the SOL record</p>
<ul>
<li><strong>If</strong> the SOL record is set and the signature is valid, the public key specified in the record is the correct destination. If the signature is invalid go to step 3</li>
<li><strong>Else</strong> go to step 3</li>
</ul>
</li>
<li>
<p>The correct destination of funds is the domain owner</p>
</li>
</ol>
<p>A JS implementation would be as follow:</p>
<pre><code class="language-js">import { Connection, PublicKey } from &quot;@solana/web3.js&quot;;
import { getSolRecord } from &quot;./record&quot;;
import { getDomainKey } from &quot;./utils&quot;;
import { NameRegistryState } from &quot;./state&quot;;
import { sign } from &quot;tweetnacl&quot;;
import { Record } from &quot;./types/record&quot;;

/**
 * This function can be used to verify the validity of a SOL record
 * @param record The record data to verify
 * @param signedRecord The signed data
 * @param pubkey The public key of the signer
 * @returns
 */
export const checkSolRecord = (
  record: Uint8Array,
  signedRecord: Uint8Array,
  pubkey: PublicKey
) =&gt; {
  return sign.detached.verify(record, signedRecord, pubkey.toBytes());
};

/**
 * This function can be used to resolve a domain name to transfer funds
 * @param connection The Solana RPC connection object
 * @param domain The domain to resolve
 * @returns
 */
export const resolve = async (connection: Connection, domain: string) =&gt; {
  const { pubkey } = await getDomainKey(domain);

  const { registry, nftOwner } = await NameRegistryState.retrieve(
    connection,
    pubkey
  );

  if (nftOwner) {
    return nftOwner;
  }

  try {
    const recordKey = await getDomainKey(Record.SOL + &quot;.&quot; + domain, true);
    const solRecord = await getSolRecord(connection, domain);

    if (solRecord.data?.length !== 96) {
      throw new Error(&quot;Invalid SOL record data&quot;);
    }

    const encoder = new TextEncoder();
    const expectedBuffer = Buffer.concat([
      solRecord.data.slice(0, 32),
      recordKey.pubkey.toBuffer(),
    ]);
    const expected = encoder.encode(expectedBuffer.toString(&quot;hex&quot;));

    const valid = checkSolRecord(
      expected,
      solRecord.data.slice(32),
      registry.owner
    );

    if (!valid) {
      throw new Error(&quot;Signature invalid&quot;);
    }

    return new PublicKey(solRecord.data.slice(0, 32));
  } catch (err) {
    console.log(err);
  }

  return registry.owner;
};
</code></pre>
<blockquote>
<p>Not resolving domains properly might lead to loss of funds ⚠️</p>
</blockquote>
<h2 id="faq-1"><a class="header" href="#faq-1">FAQ</a></h2>
<ol>
<li>What happens if funds are sent to the <code>NameRegistry</code> owner when the domain is tokenized?</li>
</ol>
<p>As long as the user owns the tokenized domains (i.e the NFT) they will be able to withdraw from the PDA escrow that received the funds. However, if for some reason the user does not own the NFT they won't be able to withdraw the funds.</p>
<ol start="2">
<li>Why is there a signature in the SOL record?</li>
</ol>
<p>The SOL record data contains a 96-byte array that is the concatenation of a public key (32 bytes) and signature (64 bytes). The first 32 bytes represent the public key (<code>pubkey</code>) to which funds should be sent and the next 64 bytes are the signature of <code>pubkey_as_bytes + record_key_as_bytes</code> signed by the owner of the domain. If the signature is invalid funds <strong>must not</strong> be transferred to the SOL record address.</p>
<p>The signature is required to prevent funds being sent to a stale SOL record after a domain has been transferred or sold to a new owner.</p>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<p>This section provides examples to assist you in testing your implementation. However, they are not exhaustive, therefore, ensure to carry out comprehensive tests beyond these examples. Use them as guidelines and adapt them to suit your specific needs.</p>
<div class="table-wrapper"><table><thead><tr><th>domain</th><th>owner</th></tr></thead><tbody>
<tr><td>wallet-guide-5.sol</td><td>Fxuoy3gFjfJALhwkRcuKjRdechcgffUApeYAfMWck6w8</td></tr>
<tr><td>wallet-guide-4.sol</td><td>Hf4daCT4tC2Vy9RCe9q8avT68yAsNJ1dQe6xiQqyGuqZ</td></tr>
<tr><td>wallet-guide-3.sol</td><td>Fxuoy3gFjfJALhwkRcuKjRdechcgffUApeYAfMWck6w8</td></tr>
<tr><td>wallet-guide-2.sol</td><td>36Dn3RWhB8x4c83W6ebQ2C2eH9sh5bQX2nMdkP2cWaA4</td></tr>
<tr><td>wallet-guide-1.sol</td><td>36Dn3RWhB8x4c83W6ebQ2C2eH9sh5bQX2nMdkP2cWaA4</td></tr>
<tr><td>wallet-guide-0.sol</td><td>Fxuoy3gFjfJALhwkRcuKjRdechcgffUApeYAfMWck6w8</td></tr>
<tr><td>sub-0.wallet-guide-3.sol</td><td>Fxuoy3gFjfJALhwkRcuKjRdechcgffUApeYAfMWck6w8</td></tr>
<tr><td>sub-1.wallet-guide-3.sol</td><td>Hf4daCT4tC2Vy9RCe9q8avT68yAsNJ1dQe6xiQqyGuqZ</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="resolving-bridged-domains"><a class="header" href="#resolving-bridged-domains">Resolving bridged domains</a></h1>
<p>The Solana Name Service (SNS) going cross-chain means that it is expanding its functionality beyond the Solana ecosystem, enabling users to export their domain names to alternative blockchains using the <a href="https://wormhole.com/">Wormhole bridge</a>. This move aims to increase the utility and adoption of SNS, while also fostering collaboration and interoperability between different blockchain networks. By allowing SNS domains to be resolved on supported chains like EVM-based chains, SNS becomes more accessible to a wider range of developers and users, promoting the growth of the Solana ecosystem and showcasing its capabilities beyond its native environment.</p>
<h2 id="evm-chains"><a class="header" href="#evm-chains">EVM Chains</a></h2>
<p>The Solana Name Service has been bridged to the following EVM chains:</p>
<ul>
<li>BNB Testnet (deployed at <code>0x4d50e149bb3d8c889f4ccdfffba0ef8016168d92</code>)</li>
<li>BNB Mainnet (deployed at <code>0xd1Ae42Ce34E6b7ab5B41dcc851424F3cF410BF16</code>)</li>
</ul>
<p>Solana domain names bridged on EVM chains can be resolved using the NPM package <a href="https://www.npmjs.com/package/@bonfida/sns-warp-evm">@bonfida/sns-warp-evm</a>.</p>
<h3 id="installation-1"><a class="header" href="#installation-1">Installation</a></h3>
<p>With Yarn:</p>
<pre><code>yarn add @bonfida/sns-warp-evm
</code></pre>
<p>With NPM</p>
<pre><code>npm i @bonfida/sns-warp-evm
</code></pre>
<h3 id="resolving-a-sol-domain"><a class="header" href="#resolving-a-sol-domain">Resolving a .sol domain</a></h3>
<p>The following code can be used to resolve .sol domains</p>
<pre><code class="language-js">import { SupportedChains, SNS } from &quot;@bonfida/sns-warp-evm&quot;;

// The domain name to resolve
const domain = &quot;mock3.sol&quot;;
// The chain on which to resolve the domain
const targetChain = SupportedChains.BNBMainnet;

const sns = new SNS(SupportedChains.BNBMainnet);
const resolved = await sns.resolveName(domain);

console.log(resolved); // &lt;- 0x1D719d2dB763f905b1924F46a5185e001Dd93786
</code></pre>
<h3 id="reverse-look-up"><a class="header" href="#reverse-look-up">Reverse look up</a></h3>
<pre><code class="language-js">import { SupportedChains, SNS } from &quot;@bonfida/sns-warp-evm&quot;;
import { namehash } from &quot;@ethersproject/hash&quot;;

// The chain on which to perform the reverse lookup
const targetChain = SupportedChains.BNBMainnet;

const sns = new SNS(targetChain);
const nameHash = namehash(&quot;mock3.sol&quot;);

const resolved = await sns.resolveReverse(nameHash);
console.log(resolved); // &lt;- mock3
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="resolving-twitter-handles"><a class="header" href="#resolving-twitter-handles">Resolving Twitter handles</a></h1>
<p>The Solana name service supports the registration of Twitter handles, allowing users to connect their Twitter profile to their wallet.</p>
<h2 id="direct-look-up"><a class="header" href="#direct-look-up">Direct look up</a></h2>
<p>To find the Twitter handle associated to a public key</p>
<pre><code class="language-js">import { getHandleAndRegistryKey } from &quot;@bonfida/spl-name-service&quot;;

const pubkey = new PublicKey(&quot;FidaeBkZkvDqi1GXNEwB8uWmj9Ngx2HXSS5nyGRuVFcZ&quot;);

const [handle] = await getHandleAndRegistryKey(connection, pubkey);
</code></pre>
<h2 id="reverse-look-up-1"><a class="header" href="#reverse-look-up-1">Reverse look up</a></h2>
<p>To find the public key associated to a Twitter handle</p>
<pre><code class="language-js">import { getTwitterRegistry } from &quot;@bonfida/spl-name-service&quot;;

const handle = &quot;bonfida&quot;;

const registry = await getTwitterRegistry(connection, handle);
const owner = registry.owner.toBase58();
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="domain-names"><a class="header" href="#domain-names">Domain names</a></h1>
<p>This following sections provide information on the following:</p>
<ul>
<li><a href="domain-name/domain-tld.html">The domain names TLD</a></li>
<li><a href="domain-name/domain-direct-lookup.html">Direct look up</a></li>
<li><a href="domain-name/domain-reverse-lookup.html">Reverse look up</a></li>
<li><a href="domain-name/subdomain-lookup.html">Subdomain look up</a></li>
<li><a href="domain-name/domain-find-for-owner.html">Get all domains of a user</a></li>
<li><a href="domain-name/all-domains.html">Get all domains</a></li>
<li><a href="domain-name/records.html">Records</a></li>
<li><a href="domain-name/transfer.html">Transfer domains</a></li>
<li><a href="domain-name/edit-domain-content.html">Edit domain content</a></li>
<li><a href="domain-name/favorite-domains.html">Favorite domain</a></li>
<li><a href="domain-name/react-hooks">React hooks</a></li>
<li><a href="domain-name/tokenization.html">Domain name tokenization</a></li>
<li><a href="domain-name/registration.html">Domain registration</a></li>
<li><a href="domain-name/media-kit.html">Media kit</a></li>
<li><a href="domain-name/delete-domain.html">Deleting domains</a></li>
<li><a href="domain-name/create-subdomain.html">Creating subdomains</a></li>
<li><a href="domain-name/sns-examples">Examples</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tld"><a class="header" href="#tld">TLD</a></h1>
<p><img src="domain-name/../assets/hierarchy.png" alt="root-tld" /></p>
<p>In Solana, the hierarchy of domain names and the TLD system is organized similarly to the traditional internet domain structure. The top of the hierarchy is the Root domain, which holds the Top Level Domains (TLDs) like <code>.sol</code>.</p>
<p>Under the Root domain, you have the TLDs, such as <code>.sol</code>. All the domain names registered with the .sol extension are considered children (or subdomains) of the <code>.sol</code> TLD. For example, bonfida.sol is a child of the <code>.sol</code> TLD.</p>
<p>Further down the hierarchy, you can have subdomains of the registered domain names. For instance, <code>dex.bonfida.sol</code> is a child of <code>bonfida.sol</code>.</p>
<p>In simple terms, the hierarchy of Solana domain names starts with the Root domain, followed by TLDs (e.g., <code>.sol</code>), then the registered domain names (e.g., <code>bonfida.sol</code>), and finally any subdomains (e.g., <code>dex.bonfida.sol</code>). This hierarchical structure allows for an organized way to manage and identify domain names on the Solana network.</p>
<h2 id="tld-list"><a class="header" href="#tld-list">TLD list</a></h2>
<ul>
<li>Root TLD: <code>ZoAhWEqTVqHVqupYmEanDobY7dee5YKbQox9BNASZzU</code></li>
<li>.sol TLD: <code>58PwtjSDuFHuUkYjH9BYnnQKHfwo9reZhC2zMJv9JPkx</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="web-resolution"><a class="header" href="#web-resolution">Web resolution</a></h1>
<h2 id="web-resolvers"><a class="header" href="#web-resolvers">Web resolvers</a></h2>
<p>While SNS offers numerous benefits, its separation from the traditional Domain Name System (DNS) can present challenges for adoption and accessibility. To address these challenges, we are building the necessary infrastructure to bridge the gap between SNS and DNS, making it easier for users to interact with SNS through familiar methods.</p>
<p>Below are three such methods for resolving .sol domain names:</p>
<ul>
<li>Natively in the <a href="https://brave.com">Brave browser</a></li>
</ul>
<!-- - Via the [Backpack](https://www.backpack.app) wallet extension -->
<ul>
<li>Through a proxy service called <a href="https://github.com/Bonfida/name-resolver">sol-domain.org</a></li>
</ul>
<h3 id="brave-browser"><a class="header" href="#brave-browser">Brave browser</a></h3>
<p>The <a href="https://brave.com">Brave browser</a> supports native resolution of .sol domain names, allowing users to access Solana Name Service domains directly from the URL bar. To resolve an SNS domain in the Brave browser, simply type the domain followed by <code>.sol</code> in the URL bar, and press Enter. For instance, to access the <a href="https://pyth.network/">Pyth network website</a>, you would enter <code>pyth.sol</code> in the URL bar.</p>
<!-- ## Backpack

[Backpack](https://www.backpack.app) is a wallet extension that supports SNS domain resolution. By using Backpack, users can resolve .sol domain names directly from their browser. To resolve a .sol domain with Backpack, simply

- Install the wallet extension
- Enable `Solana` in the `Domain Website Resolver` settings
- Enter the .sol domain you want to resolve directly in the browser's search bar (e.g., `pyth.sol`)
- The Backpack extension will automatically detect the .sol domain and redirect you -->
<h3 id="resolution-via-sol-domainorg-proxy-service"><a class="header" href="#resolution-via-sol-domainorg-proxy-service">Resolution via sol-domain.org Proxy Service</a></h3>
<p>The <a href="https://github.com/Bonfida/name-resolver">sol-domain.org</a> service is a proxy that enables users to access SNS domains via the traditional DNS system. To resolve a .sol domain using sol-domain.org, append the domain name to the beginning of the sol-domain.org URL. For example, to resolve the <code>pyth.sol</code> domain, you would enter <a href="https://pyth.sol-domain.org/">https://pyth.sol-domain.org</a> in the URL bar of your browser.</p>
<h2 id="resolving-sol-domain-names-in-practice"><a class="header" href="#resolving-sol-domain-names-in-practice">Resolving .sol domain names in practice</a></h2>
<p>The process for resolving <code>.sol</code> domain names follows a defined set of rules based on different types of records: URL, IPFS, Arweave, and Shadow Drive. The resolution process checks for these records in the specified order until it finds a valid record.</p>
<h3 id="step-by-step-process"><a class="header" href="#step-by-step-process">Step-by-step process</a></h3>
<h4 id="step-1-url-record"><a class="header" href="#step-1-url-record">Step 1: URL Record</a></h4>
<p>First, check if the URL record exists and is valid. If so, this is the website to resolve to. The URL record typically contains the HTTP or HTTPS link to the website hosted on the domain.</p>
<h4 id="step-2-ipfs-record"><a class="header" href="#step-2-ipfs-record">Step 2: IPFS Record</a></h4>
<p>If there is no valid URL record, proceed to check for an IPFS record.</p>
<p>If the IPFS record exists and is valid, the user should be redirected to the corresponding IPFS content via an IPFS gateway. An IPFS gateway acts as a bridge between the traditional web and the IPFS network, allowing browsers that don't natively support IPFS to access IPFS content.</p>
<h4 id="step-3-arweave-record"><a class="header" href="#step-3-arweave-record">Step 3: Arweave Record</a></h4>
<p>If neither a URL nor an IPFS record is found or valid, check for an Arweave record.</p>
<p>If the Arweave record exists and is valid, the user should be redirected to the Arweave content via an Arweave gateway. Similar to the IPFS gateway, an Arweave gateway allows users to access Arweave-hosted content through traditional web browsers.</p>
<h4 id="step-4-shadow-drive-record"><a class="header" href="#step-4-shadow-drive-record">Step 4: Shadow Drive Record</a></h4>
<p>Lastly, if no URL, IPFS, or Arweave records are found or valid, check for a Shadow Drive record.</p>
<p>If the Shadow Drive record exists and is valid, the user should be redirected to the content via a Shadow Drive gateway. Like IPFS and Arweave gateways, a Shadow Drive gateway provides access to Shadow Drive-hosted content for traditional web browsers.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="direct-look-up-1"><a class="header" href="#direct-look-up-1">Direct look up</a></h1>
<p><img src="domain-name/../assets/direct-reverse.png" alt="direct-reverse" /></p>
<p>In order to get the information of a domain name you need to:</p>
<ol>
<li>Get the domain name public key</li>
<li>Retrieve the account info</li>
</ol>
<pre><code class="language-js">import { getDomainKey, NameRegistryState } from &quot;@bonfida/spl-name-service&quot;;

const domainName = &quot;bonfida&quot;; // With or without the .sol at the end

// Step 1
const { pubkey } = await getDomainKey(domainName);

// Step 2
// The registry object contains all the info about the domain name
// The NFT owner is of type PublicKey | undefined
const { registry, nftOwner } = await NameRegistryState.retrieve(
  connection,
  pubkey
);

// Subdomain derivation
const subDomain = &quot;dex.bonfida&quot;; // With or without the .sol at the end
const { pubkey: subKey } = await getDomainKey(subDomain);

// Record derivation (e.g IPFS record)
const record = &quot;IPFS.bonfida&quot;; // With or without the .sol at the end
const { pubkey: recordKey } = await getDomainKey(record, true);
</code></pre>
<p>The <code>retrieve</code> method returns an object made of two fields:</p>
<ul>
<li><code>registry</code> is of type <code>NameRegistryState</code></li>
<li><code>nftOwner</code> is of type <code>PublicKey | undefined</code>
<ul>
<li>When <code>nftOwner</code> is of type <code>PublicKey</code> it means that the domain is tokenized and the current NFT holder is <code>nftOwner</code>. When a domain is tokenized <code>registry.owner</code> is an escrow account that is program owner. Funds should be sent to <code>nftOwner</code></li>
<li>When <code>nftOwner</code> is of type <code>undefined</code> it means that the domain is not tokenized and funds should be sent to <code>registry.owner</code></li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>Note:</strong> <code>NameRegistryState.retrieveBatch</code> can be used to retrieve multiple name registries at once.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reverse-look-up-2"><a class="header" href="#reverse-look-up-2">Reverse look up</a></h1>
<p><img src="domain-name/../assets/direct-reverse.png" alt="direct-reverse" /></p>
<p>If you know the public key of a domain name registry and want to get the human readable name, you need to perform a <strong>reverse lookup</strong>.</p>
<p>The following code can be used to resolve the domain name from its public key:</p>
<pre><code class="language-js">import { performReverseLookup } from &quot;@bonfida/spl-name-service&quot;;

// Public key of bonfida.sol
const domainKey = new PublicKey(&quot;Crf8hzfthWGbGbLTVCiqRqV5MVnbpHB1L9KQMd6gsinb&quot;);

const domainName = await performReverseLookup(connection, domainKey); // bonfida
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="subdomain-look-up"><a class="header" href="#subdomain-look-up">Subdomain look up</a></h1>
<p>In order to resolve all subdomains of a parent domain:</p>
<pre><code class="language-js">import { findSubdomains } from &quot;@bonfida/spl-name-service&quot;;

// Public key of bonfida.sol
const parentKey = new PublicKey(&quot;Crf8hzfthWGbGbLTVCiqRqV5MVnbpHB1L9KQMd6gsinb&quot;);

// Assuming that bonfida.sol has the following subdomains
// - sub_1.bonfida.sol
// - sub_2.bonfida.sol

const subdomains: string[] = await findSubdomains(connection, parentKey); // [sub_1, sub_2]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="get-all-domains-of-a-user"><a class="header" href="#get-all-domains-of-a-user">Get all domains of a user</a></h1>
<p>You can retrieve all the domain names of a user with the following <code>MemcmpFilter</code></p>
<pre><code class="language-js">const filters = [
  {
    memcmp: {
      offset: 32,
      bytes: user.toBase58(),
    },
  },
  {
    memcmp: {
      offset: 0,
      bytes: SOL_TLD_AUTHORITY.toBase58(),
    },
  },
];
</code></pre>
<p>If you are using <code>@bonfida/spl-name-service</code> you can use the following code:</p>
<pre><code class="language-js">import { getAllDomains } from &quot;@bonfida/spl-name-service&quot;;

// ...

const domains = await getAllDomains(connection, user);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="get-all-domain-names"><a class="header" href="#get-all-domain-names">Get all domain names</a></h1>
<p>You can retrieve all the registered domain names using a <code>getProgramAccounts</code> request with the following RPC filter</p>
<pre><code class="language-js">const filters = [
  {
    memcmp: {
      offset: 0,
      bytes: SOL_TLD_AUTHORITY.toBase58(),
    },
  },
];
</code></pre>
<p>If you are using <code>@bonfida/spl-name-service</code> you can use the following code:</p>
<pre><code class="language-js">import { getAllRegisteredDomains } from &quot;@bonfida/spl-name-service&quot;;

// ...

const registeredDomains = await getAllRegisteredDomains(connection);
</code></pre>
<p>To avoid enormous payload response, <code>getAllRegisteredDomains</code> slices the data to only return the owner of the domain (i.e <code>dataSlice = { offset: 32, length: 32 }</code>)</p>
<pre><code class="language-js">/**
 * This function can be used to retrieve all the registered `.sol` domains.
 * The account data is sliced to avoid enormous payload and only the owner is returned
 * @param connection The Solana RPC connection object
 * @returns
 */
export const getAllRegisteredDomains = async (connection: Connection) =&gt; {
  const filters = [
    {
      memcmp: {
        offset: 0,
        bytes: ROOT_DOMAIN_ACCOUNT.toBase58(),
      },
    },
  ];
  const dataSlice = { offset: 32, length: 32 };

  const accounts = await connection.getProgramAccounts(NAME_PROGRAM_ID, {
    dataSlice,
    filters,
  });
  return accounts;
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="records"><a class="header" href="#records">Records</a></h1>
<p>In addition to typical DNS records (A, AAAA, TXT, MX, etc.), the Solana Name Service introduces brand new web3-specific types. The following table will be updated as new protocols are integrated.</p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Value</th></tr></thead><tbody>
<tr><td>IPFS</td><td>An IPFS CID</td></tr>
<tr><td>ARWV</td><td>An Arweave address</td></tr>
<tr><td>SOL</td><td>A concatenation of a public key and a signature</td></tr>
<tr><td>ETH</td><td>An ETH public key</td></tr>
<tr><td>BTC</td><td>A BTC public key</td></tr>
<tr><td>LTC</td><td>An LTC public key</td></tr>
<tr><td>DOGE</td><td>A DOGE public key</td></tr>
<tr><td>email</td><td>An email address</td></tr>
<tr><td>url</td><td>A website URL</td></tr>
<tr><td>discord</td><td>A discord username</td></tr>
<tr><td>github</td><td>A github username</td></tr>
<tr><td>reddit</td><td>A reddit username</td></tr>
<tr><td>twitter</td><td>A twitter username</td></tr>
<tr><td>telegram</td><td>A telegram username</td></tr>
<tr><td>pic</td><td>A profile picture</td></tr>
<tr><td>SHDW</td><td>A Shadow drive address</td></tr>
<tr><td>POINT</td><td>A Point network record</td></tr>
<tr><td>BSC</td><td>A BSC public key</td></tr>
<tr><td>INJ</td><td>A Cosmos (Injective) public key</td></tr>
<tr><td>backpack</td><td>A Backpack username</td></tr>
</tbody></table>
</div>
<h2 id="record-enum"><a class="header" href="#record-enum">Record enum</a></h2>
<p>The following <code>enum</code> is exported from <code>@bonfida/spl-name-service</code></p>
<pre><code class="language-js">export enum Record {
  IPFS = &quot;IPFS&quot;,
  ARWV = &quot;ARWV&quot;,
  SOL = &quot;SOL&quot;,
  ETH = &quot;ETH&quot;,
  BTC = &quot;BTC&quot;,
  LTC = &quot;LTC&quot;,
  DOGE = &quot;DOGE&quot;,
  Email = &quot;email&quot;,
  Url = &quot;url&quot;,
  Discord = &quot;discord&quot;,
  Github = &quot;github&quot;,
  Reddit = &quot;reddit&quot;,
  Twitter = &quot;twitter&quot;,
  Telegram = &quot;telegram&quot;,
  Pic = &quot;pic&quot;,
  SHDW = &quot;SHDW&quot;,
  POINT = &quot;POINT&quot;,
  BSC = &quot;BSC&quot;,
  Injective = &quot;INJ&quot;,
  Backpack = &quot;backpack&quot;,
}
</code></pre>
<h2 id="record-derivation"><a class="header" href="#record-derivation">Record derivation</a></h2>
<p>Record keys can be derived with the <code>getDomainKey</code> function and the <code>record</code> flag set to <code>true</code></p>
<pre><code class="language-js">const record = Record.IPFS + &quot;.&quot; + &quot;bonfida&quot;; // With or without the .sol at the end
const { pubkey: recordKey } = await getDomainKey(record, true);
</code></pre>
<blockquote>
<p>If the <code>record</code> flag is set to <code>false</code>, the <code>getDomainKey</code> function will derive the key of the subdomain</p>
</blockquote>
<h2 id="resolving-records"><a class="header" href="#resolving-records">Resolving records</a></h2>
<p>The following resolving functions are exported:</p>
<ul>
<li><code>getIpfsRecord</code>: This function can be used to retrieve the IPFS record of a domain name</li>
<li><code>getArweaveRecord</code>: This function can be used to retrieve the Arweave record of a domain name</li>
<li><code>getSolRecord</code>: This function can be used to retrieve the SOL record of a domain name</li>
<li><code>getEthRecord</code>: This function can be used to retrieve the ETH record of a domain name</li>
<li><code>getBtcRecord</code>: This function can be used to retrieve the BTC record of a domain name</li>
<li><code>getLtcRecord</code>: This function can be used to retrieve the LTC record of a domain name</li>
<li><code>getDogeRecord</code>: This function can be used to retrieve the DOGE record of a domain name</li>
<li><code>getEmailRecord</code>: This function can be used to retrieve the email record of a domain name</li>
<li><code>getUrlRecord</code>: This function can be used to retrieve the URL record of a domain name</li>
<li><code>getDiscordRecord</code>: This function can be used to retrieve the Discord record of a domain name</li>
<li><code>getGithubRecord</code>: This function can be used to retrieve the Github record of a domain name</li>
<li><code>getRedditRecord</code>: This function can be used to retrieve the Reddit record of a domain name</li>
<li><code>getTwitterRecord</code>: This function can be used to retrieve the Twitter record of a domain name</li>
<li><code>getTelegramRecord</code>: This function can be used to retrieve the Telegram record of a domain name</li>
<li><code>getShdwRecord</code>: This function can be used to retrieve the SHDW record of a domain name</li>
<li><code>getBscRecord</code>: This function can be used to retrieve the BSC record of a domain name</li>
<li><code>getInjectiveRecord</code>: This function can be used to retrieve the Cosmos Injective record of a domain name</li>
<li><code>getBackpackRecord</code>: This function can be used to retrieve the Backpack record of a domain name</li>
</ul>
<p>All functions have the following signature</p>
<pre><code class="language-js">(connection: Connection, domain: string) =&gt; Promise&lt;NameRegistryState&gt;
</code></pre>
<p>A more generic resolving function <code>getRecord</code> is also exported with the following signature</p>
<pre><code class="language-js">(connection: Connection, domain: string, record: Record) =&gt; Promise&lt;NameRegistryState&gt;
</code></pre>
<h2 id="the-sol-record"><a class="header" href="#the-sol-record">The SOL record</a></h2>
<p>The SOL record can be used to receive funds to a different address than the one owning the domain. This allows people to hold the domain on a cold wallet while being able to receive funds on a hot wallet.</p>
<p>The SOL record data contains a 96-byte array that is the concatenation of a public key (32 bytes) and signature (64 bytes). The first 32 bytes represent the public key (<code>pubkey</code>) to which funds should be sent and the next 64 bytes are the signature of <code>pubkey_as_bytes + record_key_as_bytes</code> by the owner of the domain. If the signature is invalid funds <strong>must not</strong> be transferred.</p>
<p>The signature is required to prevent funds being sent to a stale SOL record after a domain has been transferred or sold.</p>
<h2 id="gateway"><a class="header" href="#gateway">Gateway</a></h2>
<p>The following records can be resolved in browser using <a href="https://sol-domain.org">https://sol-domain.org</a>:</p>
<ul>
<li><code>Url</code></li>
<li><code>IPFS</code></li>
<li><code>ARWV</code></li>
<li><code>SHDW</code></li>
</ul>
<p>The implementation of this resolver can be found <a href="https://github.com/Bonfida/name-resolver">on Github</a></p>
<blockquote>
<p>For example <a href="https://bonfida.sol-domain.org">https://bonfida.sol-domain.org</a></p>
</blockquote>
<h2 id="difference-between-records-and-subdomains"><a class="header" href="#difference-between-records-and-subdomains">Difference between records and subdomains</a></h2>
<p>In practice, let us consider the name <code>foo.sol</code> . If we want to find the domain's A record, containing an associated IPv4 address, then we can find it by querying <code>\1A.foo.sol</code>, with \1 the character of code value 1. The specification makes use of this prefix in order to differentiate between actual domains and records, which means that it is still possible to use the <code>A.foo.sol</code> subdomain with no collision.
In addition to this, the special <code>\1.foo.sol</code> is reserved to hold the list of all currently initialized records for a given subdomain</p>
<blockquote>
<p><strong>Note:</strong> <code>\0</code> and <code>\1</code> are convenient notations for:</p>
<ul>
<li><code>\0 = \x00</code>.</li>
<li><code>\1 = \x01</code>.</li>
</ul>
</blockquote>
<h2 id="editing-records"><a class="header" href="#editing-records">Editing records</a></h2>
<p>Below is a NodeJS example of how to create and edit a record</p>
<pre><code class="language-js">import {
  Connection,
  TransactionInstruction,
  Keypair,
  clusterApiUrl,
} from &quot;@solana/web3.js&quot;;
import {
  Record,
  getDomainKey,
  createNameRegistry,
  NameRegistryState,
  updateInstruction,
  NAME_PROGRAM_ID,
  Numberu32,
} from &quot;@bonfida/spl-name-service&quot;;
import { signAndSendInstructions } from &quot;@bonfida/utils&quot;;

const connection = new Connection(clusterApiUrl(&quot;mainnet-beta&quot;), &quot;processed&quot;);
const wallet = Keypair.fromSecretKey(...);

// bonfida.sol
const domain = &quot;bonfida&quot;; // With or without the .sol at the end

// The IPFS record of bonfida.sol
const record = Record.IPFS;

const update = async () =&gt; {
  const ixs: TransactionInstruction[] = [];
  const { pubkey: domainKey } = await getDomainKey(domain);
  const { pubkey: recordKey } = await getDomainKey(record + &quot;.&quot; + domain, true);

  const recordAccInfo = await connection.getAccountInfo(recordKey);

  if (!recordAccInfo?.data) {
    // The record does not exist so create it first
    const space = 2_000;
    const lamports = await connection.getMinimumBalanceForRentExemption(
      space + NameRegistryState.HEADER_LEN
    );
    const ix = await createNameRegistry(
      connection,
      Buffer.from([1]).toString() + record,
      space,
      wallet.publicKey,
      wallet.publicKey,
      lamports,
      undefined,
      domainKey
    );
    ixs.push(ix);
  }

  const ix = updateInstruction(
    NAME_PROGRAM_ID,
    recordKey,
    new Numberu32(0),
    Buffer.from(&quot;Some IPFS CID&quot;),
    wallet.publicKey
  );

  ixs.push(ix);

  const tx = await signAndSendInstructions(connection, [], wallet, ixs);
  console.log(`Updated record ${tx}`);
};

update();
</code></pre>
<h2 id="deleting-a-record"><a class="header" href="#deleting-a-record">Deleting a record</a></h2>
<p>Records can be deleted using the <code>deleteInstruction</code> function, below is a NodeJS example</p>
<pre><code class="language-js">import { Connection, Keypair, clusterApiUrl } from &quot;@solana/web3.js&quot;;
import {
  Record,
  getDomainKey,
  NAME_PROGRAM_ID,
  deleteInstruction,
} from &quot;@bonfida/spl-name-service&quot;;
import { signAndSendInstructions } from &quot;@bonfida/utils&quot;;

const domain = &quot;bonfida.sol&quot;; // With or without .sol

const record = Record.IPFS;

const connection = new Connection(clusterApiUrl(&quot;mainnet-beta&quot;), &quot;processed&quot;);

const wallet = Keypair.fromSecretKey(...) // Your wallet owning the domain

const deleteRecord = async () =&gt; {
  const { pubkey: recordKey } = await getDomainKey(record + &quot;.&quot; + domain, true);

  const ix = deleteInstruction(
    NAME_PROGRAM_ID,
    recordKey,
    wallet.publicKey,
    wallet.publicKey
  );

  const tx = await signAndSendInstructions(connection, [], wallet, [ix]);

  console.log(`Deleted record ${tx}`);
};

deleteRecord();
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="edit-domain-content"><a class="header" href="#edit-domain-content">Edit domain content</a></h1>
<p>To write data in a domain registry you can use the following code:</p>
<pre><code class="language-js">import {
  updateNameRegistryData,
  ROOT_DOMAIN_ACCOUNT,
} from &quot;@bonfida/spl-name-service&quot;;

const data = Buffer.from(&quot;Hello, world!&quot;);

// The offset to which the data should be written into the registry, usually 0
const offset = 0;

const ix = await updateNameRegistryData(
  connection,
  name,
  offset,
  data,
  undefined,
  ROOT_DOMAIN_ACCOUNT
);

// sign and send instruction
</code></pre>
<p>If the data is too large to fit in a single transaction, you will have to update the domain in several transaction by slicing the buffer and increasing the offset accordingly.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="transfer-domain"><a class="header" href="#transfer-domain">Transfer domain</a></h1>
<p>Domain names can be transferred using the <code>transferNameOwnership</code> instruction:</p>
<pre><code class="language-js">import {
  transferNameOwnership,
  NameRegistryState,
  SOL_TLD_AUTHORITY,
} from &quot;@bonfida/spl-name-service&quot;;

// ..

// Domain name to transfer
const domain = &quot;bonfida&quot;;

// New owner of the domain
const newOwner = new PublicKey(&quot;...&quot;);

const ix = await transferNameOwnership(
  connection,
  domain,
  newOwner,
  undefined,
  SOL_TLD_AUTHORITY
);

// sign and send instruction
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="favorite-domain"><a class="header" href="#favorite-domain">Favorite domain</a></h1>
<p>Users have the possibility to select a domain name as their favorite one. If you are a developper and want to integrate SNS to your DApp it's recommended to always use the favorite domain name to replace the user's public key.</p>
<p>The favorite domain name can be retrieved with the following code</p>
<pre><code class="language-js">import { getFavoriteDomain } from &quot;@bonfida/spl-name-service&quot;;

// ...

const { domain, reverse } = await getFavoriteDomain(connection, user);
</code></pre>
<p><code>getFavoriteDomain</code> returns the following:</p>
<ul>
<li><code>domain</code>: The public key of the domain name</li>
<li><code>reverse</code>: The reverse look up of the account</li>
</ul>
<p>For instance for <a href="https://sns.id/profile/FidaeBkZkvDqi1GXNEwB8uWmj9Ngx2HXSS5nyGRuVFcZ">FidaeBkZkvDqi1GXNEwB8uWmj9Ngx2HXSS5nyGRuVFcZ</a>:</p>
<ul>
<li><code>domain = Crf8hzfthWGbGbLTVCiqRqV5MVnbpHB1L9KQMd6gsinb</code></li>
<li><code>reverse = bonfida</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="react-hooks-1"><a class="header" href="#react-hooks-1">React hooks</a></h1>
<p>The list below show how to implement your own React hooks using vanilla React. For production, it's recommended to use the <a href="https://www.npmjs.com/package/@bonfida/sns-react">React hooks library</a>.</p>
<ol>
<li><a href="domain-name/react-hooks//domain-name/react-hooks/use-domains.html">useDomains</a></li>
<li><a href="domain-name/react-hooks//domain-name/react-hooks/use-domain-records.html">useDomainRecords</a></li>
<li><a href="domain-name/react-hooks//domain-name/react-hooks/use-domains-for-user.html">useDomainsForUser</a></li>
<li><a href="domain-name/react-hooks//domain-name/react-hooks/use-favorite-domain.html">useFavoriteDomain</a></li>
<li><a href="domain-name/react-hooks//domain-name/react-hooks/use-profile-pic.html">useProfilePic</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="usedomains"><a class="header" href="#usedomains">useDomains</a></h1>
<p>This hook can be used to resolve several domain names:</p>
<pre><code class="language-ts">import { getDomainKey, NameRegistryState } from &quot;@bonfida/spl-name-service&quot;;
import { useEffect, useState, useRef } from &quot;react&quot;;

type Result = (NameRegistryState | undefined)[] | undefined;

/**
 * This hook can be used to resolve several domain names
 * @param domains List of domains to resolve e.g [&quot;bonfida&quot;, &quot;serum&quot;]
 * @returns
 */
export const useDomains = (domains: string[]) =&gt; {
  const { connection } = useConnection();
  const [result, setResult] = useState&lt;Result&gt;(undefined);
  const mounted = useRef(true);

  useEffect(() =&gt; {
    const fn = async () =&gt; {
      const keys = await Promise.all(domains.map((e) =&gt; getDomainKey(e)));

      const registries = await NameRegistryState.retrieveBatch(
        connection,
        keys.map((e) =&gt; e.pubkey)
      );

      if (mounted.current) {
        setResult(registries);
      }

      return () =&gt; (mounted.current = false);
    };

    fn().catch(console.error);
  }, [...domains]);

  return result;
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="usedomainrecords"><a class="header" href="#usedomainrecords">useDomainRecords</a></h1>
<p>This hook can be used to retrieve all the records of a domain:</p>
<pre><code class="language-ts">type Result = (string | undefined)[] | undefined;

/**
 * This hook can be used to retrieve all the records of a domain
 * @param domains Domains to resolve records for e.g &quot;bonfida&quot;
 * @returns
 */
export const useRecords = (domain: string) =&gt; {
  const { connection } = useConnection();
  const [result, setResult] = useState&lt;Result&gt;(undefined);
  const mounted = useRef(true);

  useEffect(() =&gt; {
    const fn = async () =&gt; {
      const recordsKeys = Object.keys(Record).map((e) =&gt; Record[e]);

      const keys = await Promise.all(
        recordsKeys.map((e) =&gt; getDomainKey(e + &quot;.&quot; + domain, true))
      );

      const registries = await NameRegistryState.retrieveBatch(
        connection,
        keys.map((e) =&gt; e.pubkey)
      );

      // Remove trailling 0s
      const records = registries.map((e) =&gt; {
        if (e?.data) {
          const idx = e.data?.indexOf(0x00);
          e.data = e.data?.slice(0, idx);

          return e.data.toString();
        }
        // Record is not defined
        return undefined;
      });

      if (mounted.current) {
        setResult(records);
      }

      return () =&gt; (mounted.current = false);
    };

    fn().catch(console.error);
  }, [domain]);

  return result;
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="usedomainsforuser"><a class="header" href="#usedomainsforuser">useDomainsForUser</a></h1>
<p>This hook can be used to retrieve all the domains owned by a user:</p>
<pre><code class="language-ts">interface Result {
  pubkey: PublicKey;
  registry: NameRegistryState;
  reverse: string;
}

/**
 * This hook can be used to retrieve all the domains of a user
 * @param user The user to search domains for
 * @returns
 */
export const useDomainsForUser = (user: PublicKey) =&gt; {
  const { connection } = useConnection();
  const [result, setResult] = useState&lt;Result[] | undefined&gt;(undefined);
  const mounted = useRef(true);

  useEffect(() =&gt; {
    const fn = async () =&gt; {
      const domains = await getAllDomains(connection, user);
      const registries = await NameRegistryState.retrieveBatch(connection, [
        ...domains,
      ]);
      const reverses = await performReverseLookupBatch(connection, [
        ...domains,
      ]);
      const _result: Result[] = [];
      for (let i = 0; i &lt; domains.length; i++) {
        _result.push({
          pubkey: domains[i],
          registry: registries[i]!,
          reverse: reverses[i]!,
        });
      }
      if (mounted.current) {
        setResult(_result);
      }

      return () =&gt; (mounted.current = false);
    };

    fn().catch(console.error);
  }, [user.toBase58()]);

  return result;
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="usefavoritedomain"><a class="header" href="#usefavoritedomain">useFavoriteDomain</a></h1>
<p>Favorite domains allow users who own several domains to select one of them as their default identity.</p>
<p><strong>This favorite domain should be used by default by dApps.</strong></p>
<pre><code class="language-ts">import { useEffect, useRef, useState } from &quot;react&quot;;
import { useConnection } from &quot;@solana/wallet-adapter-react&quot;;
import { PublicKey } from &quot;@solana/web3.js&quot;;
import { performReverseLookup } from &quot;@bonfida/spl-name-service&quot;;
import { FavouriteDomain, NAME_OFFERS_ID } from &quot;@bonfida/name-offers&quot;;

type Result = string | undefined;

export const useFavoriteDomain = (user: PublicKey) =&gt; {
  const { connection } = useConnection();
  const [result, setResult] = useState&lt;Result&gt;(undefined);
  const mounted = useRef(true);

  useEffect(() =&gt; {
    const fn = async () =&gt; {
      const [favKey] = await FavouriteDomain.getKey(NAME_OFFERS_ID, user);
      const favourite = await FavouriteDomain.retrieve(connection, favKey);

      const reverse = await performReverseLookup(
        connection,
        favourite.nameAccount
      );

      if (mounted.current) {
        setResult(reverse);
      }

      return () =&gt; (mounted.current = false);
    };

    fn().catch(console.error);
  }, [user.toBase58()]);

  return result;
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="useprofilepic"><a class="header" href="#useprofilepic">useProfilePic</a></h1>
<p>Users can set a profile picture using the <code>pic</code> record of their favorite domain name. This record holds the URI to their profile picture.</p>
<pre><code class="language-ts">import { useEffect, useRef, useState } from &quot;react&quot;;
import { useConnection } from &quot;@solana/wallet-adapter-react&quot;;
import { PublicKey } from &quot;@solana/web3.js&quot;;
import { getDomainKey, NameRegistryState } from &quot;@bonfida/spl-name-service&quot;;

export const useProfilePic = (user: PublicKey) =&gt; {
  const { connection } = useConnection();
  const favorite = useFavoriteDomain(user);
  const [result, setResult] = useState&lt;Result&gt;(undefined);
  const mounted = useRef(true);

  useEffect(() =&gt; {
    const fn = async () =&gt; {
      if (!favorite) {
        return setResult(undefined);
      }

      const registry = await getPicRecord(connection, favorite.toBase58());

      if (!registry.data) {
        return setResult(undefined);
      }

      if (mounted.current) {
        setResult(registry.data.toString(&quot;utf-8&quot;));
      }

      return () =&gt; (mounted.current = false);
    };

    fn().catch(console.error);
  }, [user.toBase58(), favorite]);

  return result;
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tokenization"><a class="header" href="#tokenization">Tokenization</a></h1>
<p>Domain names are <strong>not</strong> SPL tokens, however, they can be tokenized in NFTs that follow the Metaplex standard. It's only recommended to tokenize your domain if you want to resell your domain on an NFT market place like <a href="https://magiceden.io/marketplace/bonfida">Magic Eden</a> or <a href="https://hyperspace.xyz/collection/solananameservice">Hyperspace</a>.</p>
<p>The smart contract handling the tokenization of domain names can be found here: <a href="https://github.com/Bonfida/name-tokenizer">Name tokenizer</a></p>
<h2 id="js-example"><a class="header" href="#js-example">JS example</a></h2>
<p>To retrieve all the tokenized domain names</p>
<pre><code class="language-js">import { retrieveNfts } from &quot;@bonfida/spl-name-service&quot;;

// nfts is of type PublicKey[] and contains all the mints of the tokenized domain names
const nfts = await retrieveNfts(connection);
</code></pre>
<p>To retrieve the owner of the NFT that represent a tokenized domain name</p>
<pre><code class="language-js">import { retrieveNftOwner } from &quot;@bonfida/spl-name-service&quot;;

const owner = await retrieveNftOwner(connection, nameKey);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="registration"><a class="header" href="#registration">Registration</a></h1>
<p>Registration instructions can be created either via SDK or API, both methods are equivalent. To register a domain you will have to specify the following:</p>
<ul>
<li>Domain names</li>
<li>Space (between 1kb and 10kb)</li>
<li>The public key of the buyer</li>
</ul>
<h2 id="sdk"><a class="header" href="#sdk">SDK</a></h2>
<p>Unregistered domains can be registered using the SDK <code>@bonfida/spl-name-service</code> with the following instructions:</p>
<pre><code class="language-js">import { registerDomainName } from &quot;@bonfida/spl-name-service&quot;;

const name = &quot;bonfida&quot;; // We want to register bonfida.sol
const space = 1 * 1_000; // We want a 1kB sized domain (max 10kB)

const buyer = new PublicKey(&quot;...&quot;); // Publickey of the buyer
const buyerTokenAccount = new PublicKey(&quot;...&quot;); // Publickey of the token account of the buyer (USDC)

const [, ix] = await registerDomainName(name, space, buyer, buyerTokenAccount);

// sign and send the instruction
</code></pre>
<h2 id="api"><a class="header" href="#api">API</a></h2>
<p>Registration instructions can also be created via API (equivalent to using the SDK):</p>
<pre><code>POST https://naming-api.bonfida.com/registrar/new-domain
</code></pre>
<p>With the following request body</p>
<pre><code class="language-json">{
  &quot;domain&quot;: &quot;domain_to_register&quot;,
  &quot;pubkey&quot;: &quot;pubkey_of_the_user&quot;,
  &quot;space&quot;: &quot;domain_space&quot;, // Between 1_000 and 10_000
  &quot;language&quot;: &quot;0&quot;
}
</code></pre>
<p>Response:</p>
<pre><code class="language-json">{
  &quot;success&quot;: true,
  &quot;data&quot;: {
    &quot;keys&quot;: [
      {
        &quot;pubkey&quot;: &quot;SysvarRent111111111111111111111111111111111&quot;,
        &quot;isSigner&quot;: false,
        &quot;isWritable&quot;: false
      },
      // ...
      {
        &quot;pubkey&quot;: &quot;62pexKUPWncYECF7DMtENjKbwZnrJoMpvDkrrtceC8Ee&quot;,
        &quot;isSigner&quot;: false,
        &quot;isWritable&quot;: false
      }
    ],
    &quot;programId&quot;: &quot;jCebN34bUfdeUYJT13J1yG16XWQpt5PDx6Mse9GUqhR&quot;,
    &quot;data&quot;: [
      9,
      // ...
      0
    ]
  }
}
</code></pre>
<p>More details about direct registration can be found <a href="https://docs.bonfida.org/collection/how-to-create-a-solana-domain-name/purchasing-a-domain-name/direct-registration">here</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="media-kit"><a class="header" href="#media-kit">Media kit</a></h1>
<blockquote>
<p><strong>Follow these guidelines when representing domain names on your website.</strong></p>
</blockquote>
<p>Domains names can be represented in two ways: inline and card.</p>
<p>Below are two examples of the inline and card representations.</p>
<ol>
<li><strong>Inline</strong></li>
</ol>
<p><img src="domain-name/../assets/media/examples/inline.png" alt="inline" /></p>
<ol start="2">
<li><strong>Card</strong></li>
</ol>
<p><img src="domain-name/../assets/media/examples/card.png" alt="card" /></p>
<h2 id="rare-domains"><a class="header" href="#rare-domains">Rare domains</a></h2>
<p>Rare domains are domains with 4 or less characters. These domains must be represented with the following gradient.</p>
<h3 id="gradient"><a class="header" href="#gradient">Gradient:</a></h3>
<p><img src="domain-name/../assets/media/wide/rare.svg" alt="rare-wide" /></p>
<h3 id="card-representation"><a class="header" href="#card-representation">Card representation</a></h3>
<p><img src="domain-name/../assets/media/card/rare.svg" alt="rare-card" /></p>
<h3 id="inline-representation"><a class="header" href="#inline-representation">Inline representation</a></h3>
<p><img src="domain-name/../assets/media/inline/rare.svg" alt="rare-inline" /></p>
<h2 id="emoji-domains"><a class="header" href="#emoji-domains">Emoji domains</a></h2>
<p>Emoji domains are domains that contain an emoji. These domains must be represented with the following gradient.</p>
<p><img src="domain-name/../assets/media/wide/emoji.svg" alt="emoji-wide" /></p>
<h3 id="card-representation-1"><a class="header" href="#card-representation-1">Card representation</a></h3>
<p><img src="domain-name/../assets/media/card/emoji.svg" alt="emoji-card" /></p>
<h3 id="inline-representation-1"><a class="header" href="#inline-representation-1">Inline representation</a></h3>
<p><img src="domain-name/../assets/media/inline/emoji.svg" alt="emoji-inline" /></p>
<h2 id="regular-domains"><a class="header" href="#regular-domains">Regular domains</a></h2>
<p>Regular domains are domains that have 5 or more characters and do not contain an emoji. These domains must be represented with the following gradient.</p>
<p><img src="domain-name/../assets/media/wide/regular.svg" alt="regular-wide" /></p>
<h3 id="card-representation-2"><a class="header" href="#card-representation-2">Card representation</a></h3>
<p><img src="domain-name/../assets/media/card/regular.svg" alt="regular-card" /></p>
<h3 id="inline-representation-2"><a class="header" href="#inline-representation-2">Inline representation</a></h3>
<p><img src="domain-name/../assets/media/inline/regular.svg" alt="regular-inline" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deleting-a-domain"><a class="header" href="#deleting-a-domain">Deleting a domain</a></h1>
<blockquote>
<p>🚨 <strong>Deleting a domain is irreversible</strong></p>
</blockquote>
<blockquote>
<p>🚨 <strong>Deleting a domain will make you loose ownership of the subdomains and records related to the domain</strong></p>
</blockquote>
<blockquote>
<p>🚨 <strong>Deleting domain names is not recommended</strong></p>
</blockquote>
<p>Domain names can be deleted using the <code>deleteInstruction</code>, below is a NodeJS example:</p>
<pre><code class="language-js">import { Connection, Keypair, clusterApiUrl } from &quot;@solana/web3.js&quot;;
import {
  getDomainKey,
  NAME_PROGRAM_ID,
  deleteInstruction,
} from &quot;@bonfida/spl-name-service&quot;;
import { signAndSendInstructions } from &quot;@bonfida/utils&quot;;

// bonfida.sol
const domain = &quot;bonfida.sol&quot;; // With or without .sol

const connection = new Connection(clusterApiUrl(&quot;mainnet-beta&quot;), &quot;processed&quot;);

const wallet = Keypair.fromSecretKey(...);

const deleteDomain = async () =&gt; {
  const { pubkey } = await getDomainKey(domain);

  const ix = deleteInstruction(
    NAME_PROGRAM_ID,
    pubkey,
    wallet.publicKey,
    wallet.publicKey
  );

  const tx = await signAndSendInstructions(connection, [], wallet, [ix]);

  console.log(`Deleted domain ${tx}`);
};

deleteDomain();
</code></pre>
<h2 id="deleting-subdomains"><a class="header" href="#deleting-subdomains">Deleting subdomains</a></h2>
<p>Subdomains can be deleted using the <code>deleteInstruction</code>, below is a NodeJS example:</p>
<pre><code class="language-js">import { Connection, Keypair, clusterApiUrl } from &quot;@solana/web3.js&quot;;
import {
  getDomainKey,
  NAME_PROGRAM_ID,
  deleteInstruction,
} from &quot;@bonfida/spl-name-service&quot;;
import { signAndSendInstructions } from &quot;@bonfida/utils&quot;;

// dex.bonfida.sol
const domain = &quot;dex.bonfida.sol&quot;; // With or without .sol

const connection = new Connection(clusterApiUrl(&quot;mainnet-beta&quot;), &quot;processed&quot;);

const wallet = Keypair.fromSecretKey(...);

const deleteSubDomain = async () =&gt; {
  const { pubkey } = await getDomainKey(domain);

  const ix = deleteInstruction(
    NAME_PROGRAM_ID,
    pubkey,
    wallet.publicKey,
    wallet.publicKey
  );

  const tx = await signAndSendInstructions(connection, [], wallet, [ix]);

  console.log(`Deleted subdomain ${tx}`);
};

deleteSubDomain();
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-a-subdomain"><a class="header" href="#creating-a-subdomain">Creating a subdomain</a></h1>
<p>This code snippet creates a subdomain and its reverse lookup account:</p>
<pre><code class="language-js">import {
  createNameRegistry,
  getDomainKey,
  NameRegistryState,
  createReverseName,
} from &quot;@bonfida/spl-name-service&quot;;

const ixs: TransactionInstruction[] = [];

const subdomain = &quot;amazing-sub.bonfida.sol&quot;;
const { parent, pubkey } = await getDomainKey(subdomain);

// Space allocated to the subdomains
// In this example 2kb but can be more
const space = 2_000;
const lamports = await connection.getMinimumBalanceForRentExemption(
  space + NameRegistryState.HEADER_LEN
);

const ix_create = await createNameRegistry(
  connection,
  &quot;\0&quot;.concat(&quot;amazing-sub&quot;),
  space, // Hardcode space to 2kB
  owner,
  owner,
  lamports,
  undefined,
  parent
);
ixs.push(ix_create);

// Create the reverse name
const [, ix_reverse] = await createReverseName(
  pubkey,
  &quot;\0&quot;.concat(&quot;amazing-sub&quot;),
  owner,
  parent,
  owner
);
ixs.push(...ix_reverse);

// Sign an send the tx
</code></pre>
<p>From <code>0.2.2</code> this logic is exported via the <code>createSubdomain</code> function</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="examples-1"><a class="header" href="#examples-1">Examples</a></h1>
<p>Below is a list of examples that can be used to test your code:</p>
<ol>
<li><a href="domain-name/sns-examples//domain-name/sns-examples/derivations.html">Key derivations</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="key-derivations"><a class="header" href="#key-derivations">Key derivations</a></h1>
<p>The following examples can be used to test your derivations:</p>
<h2 id="domain-name"><a class="header" href="#domain-name">Domain name</a></h2>
<ul>
<li><code>solana.sol</code>:
<ul>
<li>Public key: <code>9TdKztwu2cS3JConXYEwqscjuCixgQqFq1pAiPQEbkSy</code> (<a href="https://solana.fm/address/9TdKztwu2cS3JConXYEwqscjuCixgQqFq1pAiPQEbkSy">Explorer link</a>)</li>
<li>Reverse key: <code>AceeTYYPKzfmEd9uht5cB9ATMFEjJPcG1VLCRvgiV4fy</code> (<a href="https://solana.fm/address/AceeTYYPKzfmEd9uht5cB9ATMFEjJPcG1VLCRvgiV4fy">Explorer link</a>)</li>
</ul>
</li>
<li><code>bonfida.sol</code>:
<ul>
<li>Public key: <code>Crf8hzfthWGbGbLTVCiqRqV5MVnbpHB1L9KQMd6gsinb</code> (<a href="https://solana.fm/address/Crf8hzfthWGbGbLTVCiqRqV5MVnbpHB1L9KQMd6gsinb">Explorer link</a>)</li>
<li>Reverse key: <code>DqgmWxe2PPrfy45Ja3UPyFGwcbRzkRuwXt3NyxjX8krg</code> (<a href="https://solana.fm/address/DqgmWxe2PPrfy45Ja3UPyFGwcbRzkRuwXt3NyxjX8krg">Explorer link</a>)</li>
</ul>
</li>
<li><code>01.sol</code>:
<ul>
<li>Public key: <code>8nZ7dyd6fFSiHTV5qUCNz6kMLzVcgKgHVsDvE8AvPyq9</code> (<a href="https://solana.fm/address/8nZ7dyd6fFSiHTV5qUCNz6kMLzVcgKgHVsDvE8AvPyq9">Explorer link</a>)</li>
<li>Reverse key: <code>GFG4HcxU5URRfBxFLV9xvmJo6mdHCunEm2DRHc3aNtfL</code> (<a href="https://solana.fm/address/GFG4HcxU5URRfBxFLV9xvmJo6mdHCunEm2DRHc3aNtfL">Explorer link</a>)</li>
</ul>
</li>
</ul>
<h2 id="subdomain"><a class="header" href="#subdomain">Subdomain</a></h2>
<ul>
<li>
<p><code>dex.solana.sol</code>:</p>
<ul>
<li>Public key: <code>F1A1iznr16YfnWAnLXLKvS3aStm4VHwkheMD786KW8Ca</code> (<a href="https://solana.fm/address/F1A1iznr16YfnWAnLXLKvS3aStm4VHwkheMD786KW8Ca">Explorer link</a>)</li>
<li>Reverse key: <code>9gT93HfjZVHT8xHrJvzV7eRFs5bnXhPAsEpxvgvCsDaw</code> (<a href="https://solana.fm/address/9gT93HfjZVHT8xHrJvzV7eRFs5bnXhPAsEpxvgvCsDaw">Explorer link</a>)</li>
</ul>
</li>
<li>
<p><code>dex.bonfida.sol</code>:</p>
<ul>
<li>Public key: <code>HoFfFXqFHAC8RP3duuQNzag1ieUwJRBv1HtRNiWFq4Qu</code> (<a href="https://solana.fm/address/HoFfFXqFHAC8RP3duuQNzag1ieUwJRBv1HtRNiWFq4Qu">Explorer link</a>)</li>
<li>Reverse key: <code>6tAdEpjsrzHuRqJW3XMXEV7DFyCWW4giW6mW4bgvhcYV</code> (<a href="https://solana.fm/address/6tAdEpjsrzHuRqJW3XMXEV7DFyCWW4giW6mW4bgvhcYV">Explorer link</a>)</li>
</ul>
</li>
</ul>
<h2 id="record"><a class="header" href="#record">Record</a></h2>
<ul>
<li>
<p><code>solana.sol</code> IPFS record:</p>
<ul>
<li>Public key: <code>GvncrrXMGsBMtwg2uh8FShUqLS4GLtYrmBeCdX5PEbPR</code> (<a href="https://solana.fm/address/GvncrrXMGsBMtwg2uh8FShUqLS4GLtYrmBeCdX5PEbPR">Explorer link</a>)</li>
</ul>
</li>
<li>
<p><code>bonfida.sol</code> URL record:</p>
<ul>
<li>Public key: <code>CvhvqcxBbA4UdWuJFDMuuC4XbpCrAd9gidpW5wxEsjg5</code> (<a href="https://solana.fm/address/CvhvqcxBbA4UdWuJFDMuuC4XbpCrAd9gidpW5wxEsjg5">Explorer link</a>)</li>
</ul>
</li>
</ul>
<h2 id="-difference-between-records-and-subdomains"><a class="header" href="#-difference-between-records-and-subdomains">💡 Difference between records and subdomains</a></h2>
<p>In practice, let us consider the name <code>foo.sol</code> . If we want to find the domain's A record, containing an associated IPv4 address, then we can find it by querying <code>\1A.foo.sol</code>, with \1 the character of code value 1. The specification makes use of this prefix in order to differentiate between actual domains and records, which means that it is still possible to use the <code>A.foo.sol</code> subdomain with no collision.
In addition to this, the special <code>\1.foo.sol</code> is reserved to hold the list of all currently initialized records for a given subdomain</p>
<blockquote>
<p><strong>Note:</strong> <code>\0</code> and <code>\1</code> are convenient notations for:</p>
<ul>
<li><code>\0 = \x00</code>.</li>
<li><code>\1 = \x01</code>.</li>
</ul>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="twitter"><a class="header" href="#twitter">Twitter</a></h1>
<p>This following sections provide information on the following:</p>
<ul>
<li><a href="twitter/twitter-tld.html">The twitter TLD</a></li>
<li><a href="twitter/register.html">How to register a twitter handle</a></li>
<li><a href="twitter/twitter-direct-lookup.html">How to perform a direct look up</a></li>
<li><a href="twitter/twitter-reverse-lookup.html">How to perform a reverse look up</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tld-1"><a class="header" href="#tld-1">TLD</a></h1>
<p>The Twitter handle TLD is</p>
<pre><code class="language-js">export const TWITTER_ROOT_PARENT_REGISTRY_KEY = new PublicKey(
  &quot;4YcexoW3r78zz16J2aqmukBLRwGq6rAvWzJpkYAXqebv&quot;
);
</code></pre>
<p>The <code>.twitter</code> TLD is owned by the <code>root</code> TLD and all twitter handles are subdomains of the <code>.twitter</code> TLD</p>
<p><img src="twitter/../assets/twitter-tld.png" alt="twitter-tld" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="twitter-handle-registration"><a class="header" href="#twitter-handle-registration">Twitter handle registration</a></h1>
<p>Twitter handles can be registered <a href="https://sns.id/twitter">here</a> and a detailed guide can be found <a href="https://docs.bonfida.org/collection/solana-name-service-twitter">on the Community Help Center</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="direct-look-up-2"><a class="header" href="#direct-look-up-2">Direct look up</a></h1>
<p><img src="twitter/../assets/twitter-direct-reverse.png" alt="direct-reverse" /></p>
<p>To find the Twitter handle associated to a public key</p>
<pre><code class="language-js">import { getHandleAndRegistryKey } from &quot;@bonfida/spl-name-service&quot;;

const pubkey = new PublicKey(&quot;FidaeBkZkvDqi1GXNEwB8uWmj9Ngx2HXSS5nyGRuVFcZ&quot;);

const [handle] = await getHandleAndRegistryKey(connection, pubkey);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reverse-look-up-3"><a class="header" href="#reverse-look-up-3">Reverse look up</a></h1>
<p><img src="twitter/../assets/twitter-direct-reverse.png" alt="direct-reverse" /></p>
<p>To find the public key associated to a Twitter handle</p>
<pre><code class="language-js">import { getTwitterRegistry } from &quot;@bonfida/spl-name-service&quot;;

const handle = &quot;bonfida&quot;;

const registry = await getTwitterRegistry(connection, handle);
const owner = registry.owner.toBase58();
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sns-api"><a class="header" href="#sns-api">SNS API</a></h1>
<p>⚠️ This API is not meant to replace the blockchain as the source of truth. The blockchain should always be considered as the only source of truth. This API is only a snapshot of the blockchain at a certain point in time and might be stale by a few seconds/minutes.</p>
<ul>
<li>The base URL of the API is:</li>
</ul>
<pre><code>https://sns-api.bonfida.com
</code></pre>
<ul>
<li>The platform enum returned by <code>sales</code> endpoint is defined as below:</li>
</ul>
<pre><code class="language-javascript">enum PlatformEnum {
    None = 0,
    MagicEden = 1,
    FixedPrice = 2,
    UnsolictedOffer = 3,
    AuctionClaim = 4,
    AuctionPlaceBid = 5,
    Hyperspace = 6,
    SMBMarketplace = 7,
    Solanart = 8,
    Fractal = 9,
    Holaplex = 10,
    DegenApeMarketplace = 11,
    GooseFx = 12,
    SolanartAH =13,
    CoralCube = 14,
    AlphaArt = 15,
    DigitalEyes = 16,
    SolSea = 17,
    ExchangeArt = 18,
    Grape = 19,
    OpenSea = 20,
    Metaplex = 21,
    YAWWW = 22,
    RaribleAH = 23,
    Solvent = 24,
    TiexoT0 = 25,
    TiexoT1 = 26,
    TiexoT2 = 27,
    TiexoT3 = 28,
    TiexoT4 = 29,
    CoralCubeV2 = 30,
    Elixir = 31,
    Tensor = 32,
    GoatSwap = 33,
    Hadeswap = 34,
}
</code></pre>
<ul>
<li>All timestamps are in <strong>seconds</strong></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="categories"><a class="header" href="#categories">Categories</a></h2>
<h3 id="get-the-list-of-categories"><a class="header" href="#get-the-list-of-categories">Get the list of categories</a></h3>
<p>This endpoint can be used to retrieve the list of all categories.</p>
<blockquote>
<p>Request</p>
</blockquote>
<pre><code>GET /categories/list
</code></pre>
<blockquote>
<p>Response</p>
</blockquote>
<pre><code class="language-json">{
  &quot;success&quot;: true,
  &quot;result&quot;: [
    &quot;english-adjectives&quot;,
    &quot;double-emoji&quot;
    // ...
  ]
}
</code></pre>
<h3 id="get-the-domains-of-a-category"><a class="header" href="#get-the-domains-of-a-category">Get the domains of a category</a></h3>
<p>This endpoint can be used to retrieve the list of domains of a category.</p>
<blockquote>
<p>Request</p>
</blockquote>
<pre><code>GET /categories/list/{category}
</code></pre>
<blockquote>
<p>Response</p>
</blockquote>
<pre><code class="language-json">{
  &quot;success&quot;: true,
  &quot;result&quot;: [
    &quot;qatar&quot;,
    &quot;uganda&quot;
    // ...
  ]
}
</code></pre>
<h3 id="get-categories-statistics"><a class="header" href="#get-categories-statistics">Get categories statistics</a></h3>
<p>This endpoint returns stats for all the categories.</p>
<blockquote>
<p>Request</p>
</blockquote>
<pre><code>GET /categories/stats?start_time={start_time}&amp;end_time={end_time}
</code></pre>
<blockquote>
<p>Response</p>
</blockquote>
<pre><code class="language-json">{
  &quot;success&quot;: true,
  &quot;result&quot;: [
    {
      &quot;category_name&quot;: &quot;0x999-club&quot;,
      &quot;min_sale&quot;: 7.8846874,
      &quot;max_sale&quot;: 80.0,
      &quot;avg_price&quot;: 43.94234371185303,
      &quot;volume&quot;: 87.88469,
      &quot;owners&quot;: 1,
      &quot;supply&quot;: 2
    }
    // ...
  ]
}
</code></pre>
<h3 id="get-statistics-for-a-category"><a class="header" href="#get-statistics-for-a-category">Get statistics for a category</a></h3>
<p>This endpoint returns stats for a given category.</p>
<blockquote>
<p>Request</p>
</blockquote>
<pre><code>GET /categories/stats/{category}?start_time={start_time}&amp;end_time={end_time}
</code></pre>
<blockquote>
<p>Response</p>
</blockquote>
<pre><code class="language-json">{
  &quot;success&quot;: true,
  &quot;result&quot;: [
    {
      &quot;min_sale&quot;: 7.8846874,
      &quot;max_sale&quot;: 80.0,
      &quot;avg_price&quot;: 43.94234371185303,
      &quot;volume&quot;: 87.88469,
      &quot;owners&quot;: 1,
      &quot;supply&quot;: 2
    }
  ]
}
</code></pre>
<h3 id="get-floors"><a class="header" href="#get-floors">Get floors</a></h3>
<p>This endpoint returns the current floors for all categories. Floor prices are given in USD value.</p>
<blockquote>
<p>Request</p>
</blockquote>
<pre><code>GET /categories/floors
</code></pre>
<blockquote>
<p>Response</p>
</blockquote>
<pre><code class="language-json">{
  &quot;success&quot;: true,
  &quot;result&quot;: {
    &quot;0x999-club&quot;: 21.839999628067016,
    &quot;4-letter-dictionary&quot;: 101.39999999999999
    // ...
  }
}
</code></pre>
<h3 id="get-floor-for-a-category"><a class="header" href="#get-floor-for-a-category">Get floor for a category</a></h3>
<p>This endpoint returns the current floor for a given category. Floor prices are given in USD value.</p>
<blockquote>
<p>Request</p>
</blockquote>
<pre><code>GET /categories/floors/{category}
</code></pre>
<blockquote>
<p>Response</p>
</blockquote>
<pre><code class="language-json">{
  &quot;success&quot;: true,
  &quot;result&quot;: 21.839999628067016
}
</code></pre>
<h3 id="get-supply"><a class="header" href="#get-supply">Get supply</a></h3>
<p>This endpoint can be used to retrieve the number of registered and unregistered domains of a category.</p>
<blockquote>
<p>Request</p>
</blockquote>
<pre><code>GET /categories/supply
</code></pre>
<blockquote>
<p>Response</p>
</blockquote>
<pre><code class="language-json">{
  &quot;success&quot;: true,
  &quot;result&quot;: {
    &quot;0x999-club&quot;: {
      &quot;total&quot;: 1000,
      &quot;registered&quot;: 38,
      &quot;unregistered&quot;: 962
    }
    // ...
  }
}
</code></pre>
<h3 id="get-top-categories-by-volume"><a class="header" href="#get-top-categories-by-volume">Get top categories by volume</a></h3>
<p>This endpoint returns the top 10 categories by volume between <code>start_time</code> and <code>end_time</code>.</p>
<blockquote>
<p>Request</p>
</blockquote>
<pre><code>GET /categories/top?start_time={start_time}&amp;end_time={end_time}
</code></pre>
<blockquote>
<p>Response</p>
</blockquote>
<pre><code class="language-json">{
  &quot;success&quot;: true,
  &quot;result&quot;: [
    {
      &quot;category_name&quot;: &quot;10k-club&quot;,
      &quot;volume&quot;: 177737.16
    }
  ]
}
</code></pre>
<h2 id="get-owners"><a class="header" href="#get-owners">Get owners</a></h2>
<blockquote>
<p>Request</p>
</blockquote>
<p>This endpoint returns the public keys owning domains for a given category and the number of domains they own.</p>
<pre><code>GET /categories/owners/{category}
</code></pre>
<blockquote>
<p>Response</p>
</blockquote>
<pre><code class="language-json">{
  &quot;success&quot;: true,
  &quot;result&quot;: [
    {
      &quot;owner_key&quot;: &quot;1BWutmTvYPwDtmw9abTkS4Ssr8no61spGAvW1X6NDix&quot;,
      &quot;nb_domains&quot;: 38
    }
  ]
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="sales"><a class="header" href="#sales">Sales</a></h2>
<h3 id="last"><a class="header" href="#last">Last</a></h3>
<p>This endpoint can be used to retrieve the list of recent sales. The max <code>limit</code> parameter is 500.</p>
<blockquote>
<p>Request</p>
</blockquote>
<pre><code>GET /sales/last?limit={limit}
</code></pre>
<blockquote>
<p>Response</p>
</blockquote>
<pre><code class="language-json">{
  &quot;success&quot;: true,
  &quot;result&quot;: [
    {
      &quot;unix_timestamp&quot;: 1663824910,
      &quot;slot&quot;: 151782075,
      &quot;domain_name&quot;: &quot;wagb👌&quot;,
      &quot;domain_key&quot;: &quot;FqRocnogXTAwTnhYxRc4BA3uFkAChsDefed6nVWeD1Xe&quot;,
      &quot;domain_auction_key&quot;: &quot;GQJyiqBXq2HWnFXUWcp3pDmBYZEw3CjiYbkUJoZC6qT2&quot;,
      &quot;domain_token_mint&quot;: &quot;ESPZfWYWQZ3fJaxq7GjzkCzXKJPRMfnKc1dhkVQBZyt2&quot;,
      &quot;bidder_key&quot;: &quot;TG41WLDXx4ofZ52up4pEKQcDj1zQ4oX9LUop5qnUwQr&quot;,
      &quot;price&quot;: 1.55,
      &quot;quote_mint&quot;: &quot;So11111111111111111111111111111111111111112&quot;,
      &quot;usd_price&quot;: 47.999626,
      &quot;tx_signature&quot;: &quot;2WcrNobBtLrarFNrakkMad2eyVzfBTzCnHo2cJYgWdoUHmH9eMqZe9SzJr53m1A4BqPzmXL5WcExc4t4r5DmMTC3&quot;,
      &quot;platform_id&quot;: 1,
      &quot;successful&quot;: true
    }
    // ...
  ]
}
</code></pre>
<h3 id="registrations"><a class="header" href="#registrations">Registrations</a></h3>
<p>This endpoint can be used to retrieve registrations between <code>end_time</code> and <code>start_time</code>. The max <code>limit</code> is 500.</p>
<blockquote>
<p>Request</p>
</blockquote>
<pre><code>GET /sales/registrations?limit={limit}&amp;end_time={end_time}&amp;start_time={end_time}
</code></pre>
<blockquote>
<p>Response</p>
</blockquote>
<pre><code class="language-json">{
  &quot;success&quot;: true,
  &quot;result&quot;: [
    {
      &quot;unix_timestamp&quot;: 1663789595,
      &quot;slot&quot;: 151721528,
      &quot;tx_signature&quot;: &quot;2D9VPjN93j7YTx13oHN9sL2RDHbytLMfNmxTCBc8a57faomn4e2iF2QyUU1DLfdA9FYEJq1SzXmaC8p9FntLckUL&quot;,
      &quot;domain_name&quot;: &quot;meggadao&quot;,
      &quot;domain_key&quot;: &quot;FoidaZVWPYNCgRkthdJqnSQ82x7SLkSpBAypR7RVtFNU&quot;,
      &quot;domain_auction_key&quot;: &quot;HmGENkrhkA7ekmj9kKni4CJLJyifjzohPAV1wWTWuQFX&quot;,
      &quot;domain_token_mint&quot;: &quot;ExankJNcWwJoS4ZYe5Xuw8r7ioqAcg5XkbzWT6NJhsiA&quot;,
      &quot;price&quot;: 48.769577,
      &quot;quote_mint&quot;: &quot;EchesyfXePKdLtoiZSL8pBe8Myagyy8ZRqsACNCFGnvp&quot;,
      &quot;usd_price&quot;: 20.184021
    }
  ]
}
</code></pre>
<h3 id="leaderboard"><a class="header" href="#leaderboard">Leaderboard</a></h3>
<p>This endpoint returns the top 100 sales ever.</p>
<blockquote>
<p>Request</p>
</blockquote>
<pre><code>GET /sales/leaderboard
</code></pre>
<blockquote>
<p>Response</p>
</blockquote>
<pre><code class="language-json">{
  &quot;success&quot;: true,
  &quot;result&quot;: [
    {
      &quot;domain_name&quot;: &quot;53&quot;,
      &quot;usd_price&quot;: 15999.0
    }
    // ...
  ]
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="volumes"><a class="header" href="#volumes">Volumes</a></h2>
<h3 id="secondary-sales-volume"><a class="header" href="#secondary-sales-volume">Secondary sales volume</a></h3>
<p>This endpoint can be used to retrieve volumes for secondary sales accross all market places</p>
<blockquote>
<p>Request</p>
</blockquote>
<pre><code>GET /sales/volumes/sales?start_time={start_time}&amp;end_time={end_time}
</code></pre>
<blockquote>
<p>Response</p>
</blockquote>
<pre><code class="language-json">{
  &quot;success&quot;: true,
  &quot;result&quot;: [
    { &quot;day&quot;: 1667174400, &quot;volume&quot;: 115.98516 },
    { &quot;day&quot;: 1667088000, &quot;volume&quot;: 658.9297 }
  ]
}
</code></pre>
<h3 id="direct-registration-volume"><a class="header" href="#direct-registration-volume">Direct registration volume</a></h3>
<p>This endpoint can be used to retrieve direct registrations volume</p>
<blockquote>
<p>Request</p>
</blockquote>
<pre><code>GET /sales/volumes/registrations?start_time={start_time}&amp;end_time={end_time}
</code></pre>
<blockquote>
<p>Response</p>
</blockquote>
<pre><code class="language-json">{
  &quot;success&quot;: true,
  &quot;result&quot;: [
    { &quot;day&quot;: 1667174400, &quot;volume&quot;: 115.98516 },
    { &quot;day&quot;: 1667088000, &quot;volume&quot;: 658.9297 }
  ]
}
</code></pre>
<h3 id="aggregated-volume"><a class="header" href="#aggregated-volume">Aggregated volume</a></h3>
<p>This endpoint can be used to retrieve aggregated volume (secondary sales + direct registrations)</p>
<blockquote>
<p>Request</p>
</blockquote>
<pre><code>GET /sales/volumes/all?start_time={start_time}&amp;end_time={end_time}
</code></pre>
<blockquote>
<p>Response</p>
</blockquote>
<pre><code class="language-json">{
  &quot;success&quot;: true,
  &quot;result&quot;: [
    { &quot;day&quot;: 1667174400, &quot;volume&quot;: 115.98516 },
    { &quot;day&quot;: 1667088000, &quot;volume&quot;: 658.9297 }
  ]
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="owners"><a class="header" href="#owners">Owners</a></h2>
<h3 id="distribution"><a class="header" href="#distribution">Distribution</a></h3>
<p>This endpoint can be used to retrieve the domains distribution (includes escrow wallets)</p>
<pre><code>GET /owners/distribution
</code></pre>
<blockquote>
<p>Response</p>
</blockquote>
<pre><code class="language-json">{
  &quot;success&quot;: true,
  &quot;result&quot;: [
    { &quot;nb_owners&quot;: 1, &quot;nb_domains&quot;: 41896 }
    // ...
  ]
}
</code></pre>
<p>This endpoint can be used to retrieve the domains distribution (excludes escrow wallets)</p>
<pre><code>GET /owners/distribution-exclude-escrows
</code></pre>
<blockquote>
<p>Response</p>
</blockquote>
<pre><code class="language-json">{
  &quot;success&quot;: true,
  &quot;result&quot;: [
    { &quot;nb_owners&quot;: 1, &quot;nb_domains&quot;: 41896 }
    // ...
  ]
}
</code></pre>
<h3 id="domains-for-owner"><a class="header" href="#domains-for-owner">Domains for owner</a></h3>
<p>This endpoint can be used to retrieve the domain owned by a public key</p>
<pre><code>GET /owners/{owner_key}/domains
</code></pre>
<blockquote>
<p>Response</p>
</blockquote>
<pre><code class="language-json">{
  &quot;success&quot;: true,
  &quot;result&quot;: [
    &quot;pharmacy&quot;,
    &quot;softball&quot;,
    &quot;travelagent&quot;
    // ...
  ]
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sns-suggest-introduction---alpha"><a class="header" href="#sns-suggest-introduction---alpha">SNS Suggest Introduction - Alpha</a></h1>
<p>The SNS Suggest API can be used by applications looking to offer autocomplete or autosuggest for <code>.sol</code> domains. To get an API key please contact us on Twitter or Discord.</p>
<p>⚠️ This API is not meant to replace the blockchain as the source of truth. The blockchain should always be considered as the only source of truth. This API is only a snapshot of the blockchain at a certain point in time and might be stale by a few seconds/minutes.</p>
<p>⚠️ This feature is currently experimental and is subject to change</p>
<p>This API is using MeiliSearch under the hood, you can refer to its documentation for more details <a href="https://docs.meilisearch.com">https://docs.meilisearch.com</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="current-owner"><a class="header" href="#current-owner">Current owner</a></h2>
<p>The current owner endpoint will return the following information:</p>
<ul>
<li>Domain name (<code>String</code>)</li>
<li>Domain key (<code>String</code>)</li>
<li>Domain token mint: The mint of the NFT representing the domain if it is tokenized (<code>String</code>)</li>
<li>Domain auction key: The key of the auction state associated to the domain (<code>String</code>)</li>
<li>Owner key: The key of the current owner of the domain (<code>String</code>)</li>
<li>Availability ID: The enum described <a href="sns-suggest//sns-api/index.html">here</a> (<code>Option&lt;i16&gt;</code>)</li>
<li>Price: The price of the domain if the domain is available (<code>Option&lt;f32&gt;</code>)</li>
<li>Quote mint: The mint in which the domain is quoted if it is available</li>
<li>Fixed price key: The key of current fixed price offer if it exists (<code>Option&lt;String&gt;</code>)</li>
</ul>
<h3 id="search"><a class="header" href="#search">Search</a></h3>
<p>To search for domains that match a certain keywaord (e.g <code>00</code>):</p>
<pre><code>curl \
  -X POST 'https://sns-suggest-proxy.bonfida.com' \
  -H 'Content-Type: application/json' \
  --data-binary '{
    &quot;q&quot;: &quot;00&quot; &lt;- You keywords
  }'

</code></pre>
<pre><code class="language-json">{
  &quot;hits&quot;: [
    {
      &quot;domain_name&quot;: &quot;00&quot;,
      &quot;id&quot;: &quot;00&quot;,
      &quot;domain_key&quot;: &quot;4oZe4sxw1cSbm4KoiukMs6FSG6zW8rzKgkLDPQd5Gk6Q&quot;,
      &quot;domain_token_mint&quot;: &quot;HWDX6pDdb3mp2223PzLccezouex1m4LLEw9GTjV85Rkx&quot;,
      &quot;domain_auction_key&quot;: &quot;ctPQ35SSXvti38NmNYmwy9Lk4EtyxHMZViVNSZNTPUo&quot;,
      &quot;owner_key&quot;: &quot;5Aw5mkykrqMj8tbqzKVrgBW79w26ha1ELe3zj6ZKYz4b&quot;,
      &quot;availability_id&quot;: null,
      &quot;price&quot;: null,
      &quot;quote_mint&quot;: null,
      &quot;fixed_price_offer_account&quot;: null
    }
    //...
  ],
  &quot;query&quot;: &quot;&quot;,
  &quot;processingTimeMs&quot;: 0,
  &quot;limit&quot;: 20,
  &quot;offset&quot;: 0,
  &quot;estimatedTotalHits&quot;: 1000
}
</code></pre>
<p>The search feature is <strong>typo tolerent</strong></p>
<h3 id="simple-ui-integration"><a class="header" href="#simple-ui-integration">Simple UI integration</a></h3>
<p>Below is a simple React hook example</p>
<pre><code class="language-ts">import axios from &quot;axios&quot;;
import { useState, useEffect, useRef } from &quot;react&quot;;

export interface Item {
  domain_name: string;
  id: string;
  domain_key: string;
  domain_token_mint: string;
  domain_auction_key: string;
  owner_key: string | null | undefined;
  availability_id: number | null | undefined;
  price: number | null | undefined;
  quote_mint: string | null | undefined;
  fixed_price_offer_account: string | null | undefined;
}

export interface Result {
  hits: Item[];
  query: string;
  processingTimeMs: number;
  limit: number;
  offset: number;
  estimatedTotalHits: number;
}

const URL = &quot;https://sns-suggest-proxy.bonfida.com&quot;;

export const useDomainAutoSuggest = (domain: string) =&gt; {
  const [result, setResult] = useState&lt;Item[] | undefined&gt;(undefined);
  const mounted = useRef(true);

  useEffect(() =&gt; {
    const fn = async () =&gt; {
      const payload = { q: domain };

      const { data }: { data: Result } = await axios.post(URL, payload, {
        headers: {
          &quot;Content-type&quot;: &quot;application/json&quot;,
        },
      });

      if (mounted.current) {
        setResult(data.hits);
      }

      return () =&gt; (mounted.current = false);
    };
    fn().catch(console.error);
  }, [domain]);

  return result;
};
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
