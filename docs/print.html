<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Solana Name Service Guide</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="deployment.html"><strong aria-hidden="true">2.</strong> Deployment</a></li><li class="chapter-item expanded "><a href="installation.html"><strong aria-hidden="true">3.</strong> SNS Library</a></li><li class="chapter-item expanded "><a href="changelog.html"><strong aria-hidden="true">4.</strong> Changelog</a></li><li class="chapter-item expanded "><a href="faq.html"><strong aria-hidden="true">5.</strong> FAQ</a></li><li class="chapter-item expanded "><a href="registry.html"><strong aria-hidden="true">6.</strong> Name Registry</a></li><li class="chapter-item expanded "><a href="domain-name/index.html"><strong aria-hidden="true">7.</strong> Domain Name</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="domain-name/domain-tld.html"><strong aria-hidden="true">7.1.</strong> TLD</a></li><li class="chapter-item expanded "><a href="domain-name/domain-direct-lookup.html"><strong aria-hidden="true">7.2.</strong> Direct look up</a></li><li class="chapter-item expanded "><a href="domain-name/domain-reverse-lookup.html"><strong aria-hidden="true">7.3.</strong> Reverse look up</a></li><li class="chapter-item expanded "><a href="domain-name/subdomain-lookup.html"><strong aria-hidden="true">7.4.</strong> Subdomain look up</a></li><li class="chapter-item expanded "><a href="domain-name/domain-find-for-owner.html"><strong aria-hidden="true">7.5.</strong> Get all domains of a user</a></li><li class="chapter-item expanded "><a href="domain-name/all-domains.html"><strong aria-hidden="true">7.6.</strong> Get all domains</a></li><li class="chapter-item expanded "><a href="domain-name/records.html"><strong aria-hidden="true">7.7.</strong> Records</a></li><li class="chapter-item expanded "><a href="domain-name/edit-domain-content.html"><strong aria-hidden="true">7.8.</strong> Edit domain content</a></li><li class="chapter-item expanded "><a href="domain-name/transfer.html"><strong aria-hidden="true">7.9.</strong> Transfer domains</a></li><li class="chapter-item expanded "><a href="domain-name/favorite-domain.html"><strong aria-hidden="true">7.10.</strong> Favorite domain</a></li><li class="chapter-item expanded "><a href="domain-name/react-hooks/index.html"><strong aria-hidden="true">7.11.</strong> React hooks</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="domain-name/react-hooks/use-domains.html"><strong aria-hidden="true">7.11.1.</strong> useDomains</a></li><li class="chapter-item expanded "><a href="domain-name/react-hooks/use-domain-records.html"><strong aria-hidden="true">7.11.2.</strong> useDomainRecords</a></li><li class="chapter-item expanded "><a href="domain-name/react-hooks/use-domains-for-user.html"><strong aria-hidden="true">7.11.3.</strong> useDomainsForUser</a></li><li class="chapter-item expanded "><a href="domain-name/react-hooks/use-favorite-domain.html"><strong aria-hidden="true">7.11.4.</strong> useFavoriteDomain</a></li><li class="chapter-item expanded "><a href="domain-name/react-hooks/use-profile-pic.html"><strong aria-hidden="true">7.11.5.</strong> useProfilePic</a></li></ol></li><li class="chapter-item expanded "><a href="domain-name/tokenization.html"><strong aria-hidden="true">7.12.</strong> Tokenization</a></li><li class="chapter-item expanded "><a href="domain-name/registration.html"><strong aria-hidden="true">7.13.</strong> Registration</a></li></ol></li><li class="chapter-item expanded "><a href="twitter/index.html"><strong aria-hidden="true">8.</strong> Twitter</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="twitter/twitter-tld.html"><strong aria-hidden="true">8.1.</strong> TLD</a></li><li class="chapter-item expanded "><a href="twitter/register.html"><strong aria-hidden="true">8.2.</strong> Registration</a></li><li class="chapter-item expanded "><a href="twitter/twitter-direct-lookup.html"><strong aria-hidden="true">8.3.</strong> Direct look up</a></li><li class="chapter-item expanded "><a href="twitter/twitter-reverse-lookup.html"><strong aria-hidden="true">8.4.</strong> Reverse look up</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Solana Name Service Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p><img src="./assets/introduction.gif" alt="introduction" /></p>
<h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Welcome to the Solana Name Service (SNS). SNS has a simple mission of providing a decentralized and yet affordable way to map domain names (represented as .sol) to on-chain data. Where on-chain data can be anything from a Solana (SOL) address to IPFS CID, images, text, and more.
One of the clear benefits of the name service is a human-readable name that maps to a SOL address. Essentially, creating an identity for users in the metaverse.
Why does this matter you may ask? Well, wallet address formats can be a barrier to entry, and therefore having an identifiable address can facilitate payments and its efficiency.
Nonetheless, Solana domain names can have much broader applications than just payments. Most decentralized apps (dApps) have a single point of failure which is their centralized and censorable domain name. However, on-chain domain names cannot be censored or taken away! Thus a website hosted on IPFS (or Arweave) using a Solana domain name would be completely decentralized and very difficult to censor.</p>
<h2 id="twitter-handles--sol-domain-names"><a class="header" href="#twitter-handles--sol-domain-names">Twitter handles &amp; .sol domain names</a></h2>
<p>Both Twitter handles and .sol domain names are a part of SNS, yet are slightly different. A Twitter handle can only be claimed by the owner of the Twitter account. In order to guarantee this, the user needs to tweet the wallet address they want to associate with the account and then sign a transaction using the same wallet address. An oracle then verifies that the public key contained in the tweet matches with the signer. In practice, this means that Twitter names are already reserved. Twitter users just need to claim their public key by tweeting it.
Still, this has privacy implications that require you to have an identifiable Twitter account. This is where .sol domain names are useful. The domain names serve the same purpose as Twitter handles except they do not require you to reveal any personal information or a Twitter account.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deployment"><a class="header" href="#deployment">Deployment</a></h1>
<p>The Solana Name Service program is deployed on <a href="https://explorer.solana.com/address/namesLPneVptA9Z5rqUDD9tMTWEJwofgaYwp8cawRkX">Mainnet</a>, <a href="https://explorer.solana.com/address/namesLPneVptA9Z5rqUDD9tMTWEJwofgaYwp8cawRkX?cluster=devnet">Devnet</a> and <a href="https://explorer.solana.com/address/namesLPneVptA9Z5rqUDD9tMTWEJwofgaYwp8cawRkX?cluster=testnet">Testnet</a> at the following address:</p>
<pre><code>namesLPneVptA9Z5rqUDD9tMTWEJwofgaYwp8cawRkX
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<p>To install the JS library</p>
<pre><code class="language-js">npm i @bonfida/spl-name-service
</code></pre>
<p>or</p>
<pre><code class="language-js">yarn add @bonfida/spl-name-service
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="changelog"><a class="header" href="#changelog">Changelog</a></h1>
<ul>
<li><code>0.1.41</code>: add <code>getAllRegisteredDomains</code></li>
<li><code>0.1.40</code>: fix <code>performReverseLookupBatch</code></li>
<li><code>0.1.39</code>: add <code>Record</code> <code>enum</code> and records getter functions</li>
<li><code>0.1.38</code>: add <code>getFavoriteDomain</code>, <code>getDomainKey</code> and <code>getAllDomains</code></li>
<li>In version <code>0.1.26</code> the signature of <code>NameRegistryState.retrieve</code> changed, it is now returning an object of type <code>{ registry: NameRegistryState, nftOwner: PublicKey | undefined }</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="faq"><a class="header" href="#faq">FAQ</a></h1>
<h2 id="where-can-i-buy-a-domain"><a class="header" href="#where-can-i-buy-a-domain">Where can I buy a domain?</a></h2>
<p>You can buy a domain on <a href="https://naming.bonfida.com">Bonfida</a></p>
<h2 id="how-do-i-find-a-domain-if-i-only-know-its-public-key"><a class="header" href="#how-do-i-find-a-domain-if-i-only-know-its-public-key">How do I find a domain if I only know its public key?</a></h2>
<p>If you only know the public key of a domain you can do a reverse look up to find the associated domain. For example:</p>
<pre><code class="language-js">import { performReverseLookup } from &quot;@bonfida/spl-name-service&quot;;

// Public key of bonfida.sol
const domainKey = new PublicKey(&quot;Crf8hzfthWGbGbLTVCiqRqV5MVnbpHB1L9KQMd6gsinb&quot;);

const domainName = await performReverseLookup(connection, domainKey); // bonfida
</code></pre>
<h2 id="how-do-i-find-the-public-key-of-a-domain"><a class="header" href="#how-do-i-find-the-public-key-of-a-domain">How do I find the public key of a domain?</a></h2>
<p>If you want to find the public key of a domain you need to derive it:</p>
<pre><code class="language-js">import {
  getHashedName,
  getNameAccountKey,
  NameRegistryState,
} from &quot;@bonfida/spl-name-service&quot;;

const domainName = &quot;bonfida&quot;; // Without the .sol

// Step 1
const hashedName = await getHashedName(domainName);

// Step 2
const domainKey = await getNameAccountKey(
  hashedName,
  undefined,
  SOL_TLD_AUTHORITY
);
</code></pre>
<h2 id="how-can-i-find-the-content-of-a-domain"><a class="header" href="#how-can-i-find-the-content-of-a-domain">How can I find the content of a domain?</a></h2>
<p>You can access the content of a domain by retrieving its registry:</p>
<pre><code class="language-js">const { registry } = await NameRegistryState.retrieve(connection, domainKey);
const { parentName, owner, class, data } = registry;
</code></pre>
<h2 id="how-do-i-find-the-twitter-handle-of-a-public-key"><a class="header" href="#how-do-i-find-the-twitter-handle-of-a-public-key">How do I find the twitter handle of a public key?</a></h2>
<p>To find the twitter handle of a public key</p>
<pre><code class="language-js">import { getHandleAndRegistryKey } from &quot;@bonfida/spl-name-service&quot;;

const pubkey = new PublicKey(&quot;FidaeBkZkvDqi1GXNEwB8uWmj9Ngx2HXSS5nyGRuVFcZ&quot;);

const [handle] = await getHandleAndRegistryKey(connection, pubkey);
</code></pre>
<h2 id="how-do-i-find-the-public-key-of-a-twitter-handle"><a class="header" href="#how-do-i-find-the-public-key-of-a-twitter-handle">How do I find the public key of a twitter handle?</a></h2>
<p>To find the public key of a twitter handle</p>
<pre><code class="language-js">import { getTwitterRegistry } from &quot;@bonfida/spl-name-service&quot;;

const handle = &quot;bonfida&quot;;

const registry = await getTwitterRegistry(connection, handle);
</code></pre>
<h2 id="how-do-i-find-all-the-subdomains-of-a-domain"><a class="header" href="#how-do-i-find-all-the-subdomains-of-a-domain">How do I find all the subdomains of a domain?</a></h2>
<p>You can find all the subdomains using the following RPC filter:</p>
<pre><code class="language-js">const filters = [
  {
    memcmp: {
      offset: 32,
      bytes: userAccount.toBase58(),
    },
  },
  {
    memcmp: {
      offset: 0,
      bytes: parent_key.toBase58(),
    },
  },
];
</code></pre>
<h2 id="how-do-i-find-all-the-subdomains-of-a-user"><a class="header" href="#how-do-i-find-all-the-subdomains-of-a-user">How do I find all the subdomains of a user?</a></h2>
<p>You can find all the subdomains of a user by doing the following</p>
<ol>
<li>Retrieve all the domains of the user</li>
<li>Iterate over the domains and retrieve the subdomains for each</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="name-registry"><a class="header" href="#name-registry">Name Registry</a></h1>
<p>The registry stores information about the domain name. It is made of two things:</p>
<ul>
<li>The header</li>
<li>The data</li>
</ul>
<p>The data for a domain name is always prefixed by the header.</p>
<center>
<img src="assets/name-registry.png" alt="name-registry" />
</center>
<p>Below is the structure of the header in both Rust and JS:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// The layout of the remaining bytes in the account data are determined by the record `class`
#[derive(Clone, Debug, BorshSerialize, BorshDeserialize, PartialEq)]
pub struct NameRecordHeader {
    // Names are hierarchical.  `parent_name` contains the account address of the parent
    // name, or `Pubkey::default()` if no parent exists.
    pub parent_name: Pubkey,

    // The owner of this name
    pub owner: Pubkey,

    // The class of data this account represents (DNS record, twitter handle, SPL Token name/symbol, etc)
    //
    // If `Pubkey::default()` the data is unspecified.
    pub class: Pubkey,
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-js">export class NameRegistryState {
  parentName: PublicKey;
  owner: PublicKey;
  class: PublicKey;
  data: Buffer | undefined;

  static HEADER_LEN = 96;

  static schema: Schema = new Map([
    [
      NameRegistryState,
      {
        kind: &quot;struct&quot;,
        fields: [
          [&quot;parentName&quot;, [32]],
          [&quot;owner&quot;, [32]],
          [&quot;class&quot;, [32]],
        ],
      },
    ],
  ]);
  constructor(obj: {
    parentName: Uint8Array;
    owner: Uint8Array;
    class: Uint8Array;
  }) {
    this.parentName = new PublicKey(obj.parentName);
    this.owner = new PublicKey(obj.owner);
    this.class = new PublicKey(obj.class);
  }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="domain-names"><a class="header" href="#domain-names">Domain names</a></h1>
<p>This following sections provide information on the following:</p>
<ul>
<li><a href="domain-name/domain-tld.html">The domain names TLD</a></li>
<li><a href="domain-name/domain-direct-lookup.html">Direct look up</a></li>
<li><a href="domain-name/domain-reverse-lookup.html">Reverse look up</a></li>
<li><a href="domain-name/subdomain-lookup.html">Subdomain look up</a></li>
<li><a href="domain-name/domain-find-for-owner.html">Get all domains of a user</a></li>
<li><a href="domain-name/all-domains.html">Get all domains</a></li>
<li><a href="domain-name/records.html">Records</a></li>
<li><a href="domain-name/transfer.html">Transfer domains</a></li>
<li><a href="domain-name/edit-domain-content.html">Edit domain content</a></li>
<li><a href="domain-name/favorite-domains.html">Favorite domain</a></li>
<li><a href="domain-name/react-hooks">React hooks</a></li>
<li><a href="domain-name/tokenization.html">Domain name tokenization</a></li>
<li><a href="domain-name/registration.html">Domain registration</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tld"><a class="header" href="#tld">TLD</a></h1>
<p>Top Level Domains (TLDs) are required to resolve domain names.</p>
<p>The <code>.sol</code> TLD is</p>
<pre><code class="language-js">export const SOL_TLD_AUTHORITY = new PublicKey(
  &quot;58PwtjSDuFHuUkYjH9BYnnQKHfwo9reZhC2zMJv9JPkx&quot;
);
</code></pre>
<p>The <code>.sol</code> TLD is owned by the <code>root</code> TLD</p>
<pre><code class="language-js">export const ROOT_TLD_AUTHORITY = new PublicKey(
  &quot;ZoAhWEqTVqHVqupYmEanDobY7dee5YKbQox9BNASZzU&quot;
);
</code></pre>
<p>All <code>.sol</code> domains are subdomains of the <code>.sol</code> TLD</p>
<p><img src="domain-name/../assets/root-tld.png" alt="root-tld" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="direct-look-up"><a class="header" href="#direct-look-up">Direct look up</a></h1>
<p><img src="domain-name/../assets/direct-reverse.png" alt="direct-reverse" /></p>
<p>In order to get the information of a domain name you need to:</p>
<ol>
<li>Get the domain name public key</li>
<li>Retrieve the account info</li>
</ol>
<pre><code class="language-js">import { getDomainKey, NameRegistryState } from &quot;@bonfida/spl-name-service&quot;;

const domainName = &quot;bonfida&quot;; // With or without the .sol at the end

// Step 1
const { pubkey } = await getDomainKey(domainName);

// Step 2
// The registry object contains all the info about the domain name
// The NFT owner is of type PublicKey | undefined
const { registry, nftOwner } = await NameRegistryState.retrieve(
  connection,
  domainKey
);
</code></pre>
<p>The <code>retrieve</code> method returns an object made of two fields:</p>
<ul>
<li><code>registry</code> is of type <code>NameRegistryState</code></li>
<li><code>nftOwner</code> is of type <code>PublicKey | undefined</code>
<ul>
<li>When <code>nftOwner</code> is of type <code>PublicKey</code> it means that the domain is tokenized and the current NFT holder is <code>nftOwner</code>. When a domain is tokenized <code>registry.owner</code> is an escrow account that is program owner. Funds should be sent to <code>nftOwner</code></li>
<li>When <code>nftOwner</code> is of type <code>undefined</code> it means that the domain is not tokenized and funds should be sent to <code>registry.owner</code></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reverse-look-up"><a class="header" href="#reverse-look-up">Reverse look up</a></h1>
<p><img src="domain-name/../assets/direct-reverse.png" alt="direct-reverse" /></p>
<p>If you know the public key of a domain name registry and want to get the human readable name, you need to perform a <strong>reverse lookup</strong>.</p>
<p>The following code can be used to resolve the domain name from its public key:</p>
<pre><code class="language-js">import { performReverseLookup } from &quot;@bonfida/spl-name-service&quot;;

// Public key of bonfida.sol
const domainKey = new PublicKey(&quot;Crf8hzfthWGbGbLTVCiqRqV5MVnbpHB1L9KQMd6gsinb&quot;);

const domainName = await performReverseLookup(connection, domainKey); // bonfida
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="subdomain-look-up"><a class="header" href="#subdomain-look-up">Subdomain look up</a></h1>
<p>In order to resolve all subdomains of a parent domain:</p>
<pre><code class="language-js">import { findSubdomains } from &quot;@bonfida/spl-name-service&quot;;

// Public key of bonfida.sol
const parentKey = new PublicKey(&quot;Crf8hzfthWGbGbLTVCiqRqV5MVnbpHB1L9KQMd6gsinb&quot;);

// Assuming that bonfida.sol has the following subdomains
// - sub_1.bonfida.sol
// - sub_2.bonfida.sol

const subdomains: string[] = await findSubdomains(connection, parentKey); // [sub_1, sub_2]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="get-all-domains-of-a-user"><a class="header" href="#get-all-domains-of-a-user">Get all domains of a user</a></h1>
<p>You can retrieve all the domain names of a user with the following <code>MemcmpFilter</code></p>
<pre><code class="language-js">const filters = [
  {
    memcmp: {
      offset: 32,
      bytes: user.toBase58(),
    },
  },
  {
    memcmp: {
      offset: 0,
      bytes: SOL_TLD_AUTHORITY.toBase58(),
    },
  },
];
</code></pre>
<p>If you are using <code>@bonfida/spl-name-service</code> you can use the following code:</p>
<pre><code class="language-js">import { getAllDomains } from &quot;@bonfida/spl-name-service&quot;;

// ...

const domains = await getAllDomains(connection, user);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="get-all-domain-names"><a class="header" href="#get-all-domain-names">Get all domain names</a></h1>
<p>You can retrieve all the registered domain names using a <code>getProgramAccounts</code> request with the following RPC filter</p>
<pre><code class="language-js">const filters = [
  {
    memcmp: {
      offset: 0,
      bytes: SOL_TLD_AUTHORITY.toBase58(),
    },
  },
];
</code></pre>
<p>If you are using <code>@bonfida/spl-name-service</code> you can use the following code:</p>
<pre><code class="language-js">import { getAllRegisteredDomains } from &quot;@bonfida/spl-name-service&quot;;

// ...

const registeredDomains = await getAllRegisteredDomains(connection);
</code></pre>
<p>To avoid enormous payload response, <code>getAllRegisteredDomains</code> slices the data to only return the owner of the domain (i.e <code>dataSlice = { offset: 32, length: 32 }</code>)</p>
<pre><code class="language-js">/**
 * This function can be used to retrieve all the registered `.sol` domains.
 * The account data is sliced to avoid enormous payload and only the owner is returned
 * @param connection The Solana RPC connection object
 * @returns
 */
export const getAllRegisteredDomains = async (connection: Connection) =&gt; {
  const filters = [
    {
      memcmp: {
        offset: 0,
        bytes: ROOT_DOMAIN_ACCOUNT.toBase58(),
      },
    },
  ];
  const dataSlice = { offset: 32, length: 32 };

  const accounts = await connection.getProgramAccounts(NAME_PROGRAM_ID, {
    dataSlice,
    filters,
  });
  return accounts;
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="records"><a class="header" href="#records">Records</a></h1>
<p>In addition to typical DNS records (A, AAAA, TXT, MX, etc.), the Solana Name Service introduces brand new web3-specific types. The following table will be updated as new protocols are integrated.</p>
<table><thead><tr><th>Name</th><th>Value</th></tr></thead><tbody>
<tr><td>IPFS</td><td>An IPFS CID</td></tr>
<tr><td>ARWV</td><td>An Arweave address</td></tr>
<tr><td>ETH</td><td>An ETH public key</td></tr>
<tr><td>BTC</td><td>A BTC public key</td></tr>
<tr><td>LTC</td><td>An LTC public key</td></tr>
<tr><td>DOGE</td><td>A DOGE public key</td></tr>
<tr><td>email</td><td>An email address</td></tr>
<tr><td>url</td><td>A website URL</td></tr>
<tr><td>discord</td><td>A discord username</td></tr>
<tr><td>github</td><td>A github username</td></tr>
<tr><td>reddit</td><td>A reddit username</td></tr>
<tr><td>twitter</td><td>A twitter username</td></tr>
<tr><td>telegram</td><td>A telegram username</td></tr>
<tr><td>pic</td><td>A profile picture</td></tr>
</tbody></table>
<h2 id="record-enum"><a class="header" href="#record-enum">Record enum</a></h2>
<p>The following <code>enum</code> is exported from <code>@bonfida/spl-name-service</code></p>
<pre><code class="language-js">export enum Record {
  IPFS = &quot;IPFS&quot;,
  ARWV = &quot;ARWV&quot;,
  ETH = &quot;ETH&quot;,
  BTC = &quot;BTC&quot;,
  LTC = &quot;LTC&quot;,
  DOGE = &quot;DOGE&quot;,
  Email = &quot;email&quot;,
  Url = &quot;url&quot;,
  Discord = &quot;discord&quot;,
  Github = &quot;github&quot;,
  Reddit = &quot;reddit&quot;,
  Twitter = &quot;twitter&quot;,
  Telegram = &quot;telegram&quot;,
  Pic = &quot;pic&quot;
}
</code></pre>
<h2 id="resolving-records"><a class="header" href="#resolving-records">Resolving records</a></h2>
<p>The following resolving functions are exported:</p>
<ul>
<li><code>getIpfsRecord</code>: This function can be used to retrieve the IPFS record of a domain name</li>
<li><code>getArweaveRecord</code>: This function can be used to retrieve the Arweave record of a domain name</li>
<li><code>getEthRecord</code>: This function can be used to retrieve the ETH record of a domain name</li>
<li><code>getBtcRecord</code>: This function can be used to retrieve the BTC record of a domain name</li>
<li><code>getLtcRecord</code>: This function can be used to retrieve the LTC record of a domain name</li>
<li><code>getDogeRecord</code>: This function can be used to retrieve the DOGE record of a domain name</li>
<li><code>getEmailRecord</code>: This function can be used to retrieve the email record of a domain name</li>
<li><code>getUrlRecord</code>: This function can be used to retrieve the URL record of a domain name</li>
<li><code>getDiscordRecord</code>: This function can be used to retrieve the Discord record of a domain name</li>
<li><code>getGithubRecord</code>: This function can be used to retrieve the Github record of a domain name</li>
<li><code>getRedditRecord</code>: This function can be used to retrieve the Reddit record of a domain name</li>
<li><code>getTwitterRecord</code>: This function can be used to retrieve the Twitter record of a domain name</li>
<li><code>getTelegramRecord</code>: This function can be used to retrieve the Telegram record of a domain name</li>
</ul>
<p>All functions have the following signature</p>
<pre><code class="language-js">(connection: Connection, domain: string) =&gt; Promise&lt;NameRegistryState&gt;
</code></pre>
<p>A more generic resolving function <code>getRecord</code> is also exported with the following signature</p>
<pre><code class="language-js">(connection: Connection, domain: string, record: Record) =&gt; Promise&lt;NameRegistryState&gt;
</code></pre>
<h2 id="difference-between-records-and-subdomains"><a class="header" href="#difference-between-records-and-subdomains">Difference between records and subdomains</a></h2>
<p>In practice, let us consider the name <code>foo.sol</code> . If we want to find the domain's A record, containing an associated IPv4 address, then we can find it by querying <code>\1A.foo.sol</code>, with \1 the character of code value 1. The specification makes use of this prefix in order to differentiate between actual domains and records, which means that it is still possible to use the <code>A.foo.sol</code> subdomain with no collision.
In addition to this, the special <code>\1.foo.sol</code> is reserved to hold the list of all currently initialized records for a given subdomain</p>
<blockquote>
<p><strong>Note:</strong> <code>\0</code> and <code>\1</code> are convenient notations for:</p>
<ul>
<li><code>\0 = \x00</code>.</li>
<li><code>\1 = \x01</code>.</li>
</ul>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="edit-domain-content"><a class="header" href="#edit-domain-content">Edit domain content</a></h1>
<p>To write data in a domain registry you can use the following code:</p>
<pre><code class="language-js">import {
  updateNameRegistryData,
  ROOT_DOMAIN_ACCOUNT,
} from &quot;@bonfida/spl-name-service&quot;;

const data = Buffer.from(&quot;Hello, world!&quot;);

// The offset to which the data should be written into the registry, usually 0
const offset = 0;

const ix = await updateNameRegistryData(
  connection,
  name,
  offset,
  data,
  undefined,
  ROOT_DOMAIN_ACCOUNT
);

// sign and send instruction
</code></pre>
<p>If the data is too large to fit in a single transaction, you will have to update the domain in several transaction by slicing the buffer and increasing the offset accordingly.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="transfer-domain"><a class="header" href="#transfer-domain">Transfer domain</a></h1>
<p>Domain names can be transfered using the <code>transferNameOwnership</code> instruction:</p>
<pre><code class="language-js">import {
  transferNameOwnership,
  NameRegistryState,
  SOL_TLD_AUTHORITY,
} from &quot;@bonfida/spl-name-service&quot;;

// ..

// Domain name to transfer
const domain = &quot;bonfida&quot;;

// New owner of the domain
const newOwner = new PublicKey(&quot;...&quot;);

const ix = await transferNameOwnership(
  connection,
  domain,
  newOwner,
  undefined,
  SOL_TLD_AUTHORITY
);

// sign and send instruction
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="favorite-domain"><a class="header" href="#favorite-domain">Favorite domain</a></h1>
<p>Users have the possibility to select a domain name as their favorite one. If you are a developper and want to integrate SNS to your DApp it's recommended to always use the favorite domain name to replace the user's public key.</p>
<p>The favorite domain name can be retrieved with the following code</p>
<pre><code class="language-js">import { getFavoriteDomain } from &quot;@bonfida/spl-name-service&quot;;

// ...

const { domain, reverse } = await getFavoriteDomain(connection, user);
</code></pre>
<p><code>getFavoriteDomain</code> returns the following:</p>
<ul>
<li><code>domain</code>: The public key of the domain name</li>
<li><code>reverse</code>: The reverse look up of the account</li>
</ul>
<p>For instance for <a href="https://naming.bonfida.org/profile/FidaeBkZkvDqi1GXNEwB8uWmj9Ngx2HXSS5nyGRuVFcZ">FidaeBkZkvDqi1GXNEwB8uWmj9Ngx2HXSS5nyGRuVFcZ</a>:</p>
<ul>
<li><code>domain = Crf8hzfthWGbGbLTVCiqRqV5MVnbpHB1L9KQMd6gsinb</code></li>
<li><code>reverse = bonfida</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="react-hooks"><a class="header" href="#react-hooks">React hooks</a></h1>
<p>Below is a list of simple React hooks.</p>
<p><strong>For production it's recommended to use <a href="https://react-query.tanstack.com/">React Query</a> or <a href="https://ahooks.js.org/">ahooks</a></strong></p>
<ol>
<li><a href="domain-name/react-hooks//domain-name/react-hooks/use-domains.html">useDomains</a></li>
<li><a href="domain-name/react-hooks//domain-name/react-hooks/use-domain-records.html">useDomainRecords</a></li>
<li><a href="domain-name/react-hooks//domain-name/react-hooks/use-domains-for-user.html">useDomainsForUser</a></li>
<li><a href="domain-name/react-hooks//domain-name/react-hooks/use-favorite-domain.html">useFavoriteDomain</a></li>
<li><a href="domain-name/react-hooks//domain-name/react-hooks/use-profile-pic.html">useProfilePic</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="usedomains"><a class="header" href="#usedomains">useDomains</a></h1>
<p>This hook can be used to resolve several domain names:</p>
<pre><code class="language-ts">import { getDomainKey, NameRegistryState } from &quot;@bonfida/spl-name-service&quot;;
import { useEffect, useState, useRef } from &quot;react&quot;;

type Result = (NameRegistryState | undefined)[] | undefined;

/**
 * This hook can be used to resolve several domain names
 * @param domains List of domains to resolve e.g [&quot;bonfida&quot;, &quot;serum&quot;]
 * @returns
 */
export const useDomains = (domains: string[]) =&gt; {
  const { connection } = useConnection();
  const [result, setResult] = useState&lt;Result&gt;(undefined);
  const mounted = useRef(true);

  useEffect(() =&gt; {
    const fn = async () =&gt; {
      const keys = await Promise.all(domains.map((e) =&gt; getDomainKey(e)));

      const registries = await NameRegistryState.retrieveBatch(
        connection,
        keys.map((e) =&gt; e.pubkey)
      );

      if (mounted.current) {
        setResult(registries);
      }

      return () =&gt; (mounted.current = false);
    };

    fn().catch(console.error);
  }, [...domains]);

  return result;
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="usedomainrecords"><a class="header" href="#usedomainrecords">useDomainRecords</a></h1>
<p>This hook can be used to retrieve all the records of a domain:</p>
<pre><code class="language-ts">type Result = (string | undefined)[] | undefined;

/**
 * This hook can be used to retrieve all the records of a domain
 * @param domains Domains to resolve records for e.g &quot;bonfida&quot;
 * @returns
 */
export const useRecords = (domain: string) =&gt; {
  const { connection } = useConnection();
  const [result, setResult] = useState&lt;Result&gt;(undefined);
  const mounted = useRef(true);

  useEffect(() =&gt; {
    const fn = async () =&gt; {
      const recordsKeys = Object.keys(Record).map((e) =&gt; Record[e]);

      const keys = await Promise.all(
        recordsKeys.map((e) =&gt; getDomainKey(e + &quot;.&quot; + domain, true))
      );

      const registries = await NameRegistryState.retrieveBatch(
        connection,
        keys.map((e) =&gt; e.pubkey)
      );

      // Remove trailling 0s
      const records = registries.map((e) =&gt; {
        if (e?.data) {
          const idx = e.data?.indexOf(0x00);
          e.data = e.data?.slice(0, idx);

          return e.data.toString();
        }
        // Record is not defined
        return undefined;
      });

      if (mounted.current) {
        setResult(records);
      }

      return () =&gt; (mounted.current = false);
    };

    fn().catch(console.error);
  }, [domain]);

  return result;
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="usedomainsforuser"><a class="header" href="#usedomainsforuser">useDomainsForUser</a></h1>
<p>This hook can be used to retrieve all the domains owned by a user:</p>
<pre><code class="language-ts">interface Result {
  pubkey: PublicKey;
  registry: NameRegistryState;
  reverse: string;
}

/**
 * This hook can be used to retrieve all the domains of a user
 * @param user The user to search domains for
 * @returns
 */
export const useDomainsForUser = (user: PublicKey) =&gt; {
  const { connection } = useConnection();
  const [result, setResult] = useState&lt;Result[] | undefined&gt;(undefined);
  const mounted = useRef(true);

  useEffect(() =&gt; {
    const fn = async () =&gt; {
      const domains = await getAllDomains(connection, user);
      const registries = await NameRegistryState.retrieveBatch(connection, [
        ...domains,
      ]);
      const reverses = await performReverseLookupBatch(connection, [
        ...domains,
      ]);
      const _result: Result[] = [];
      for (let i = 0; i &lt; domains.length; i++) {
        _result.push({
          pubkey: domains[i],
          registry: registries[i]!,
          reverse: reverses[i]!,
        });
      }
      if (mounted.current) {
        setResult(_result);
      }

      return () =&gt; (mounted.current = false);
    };

    fn().catch(console.error);
  }, [user.toBase58()]);

  return result;
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="usefavoritedomain"><a class="header" href="#usefavoritedomain">useFavoriteDomain</a></h1>
<p>Favorite domains allow users who own several domains to select one of them as their default identity.</p>
<p><strong>This favorite domain should be used by default by dApps.</strong></p>
<pre><code class="language-ts">import { useEffect, useRef, useState } from &quot;react&quot;;
import { useConnection } from &quot;@solana/wallet-adapter-react&quot;;
import { PublicKey } from &quot;@solana/web3.js&quot;;
import { performReverseLookup } from &quot;@bonfida/spl-name-service&quot;;
import { FavouriteDomain, NAME_OFFERS_ID } from &quot;@bonfida/name-offers&quot;;

type Result = string | undefined;

export const useFavoriteDomain = (user: PublicKey) =&gt; {
  const { connection } = useConnection();
  const [result, setResult] = useState&lt;Result&gt;(undefined);
  const mounted = useRef(true);

  useEffect(() =&gt; {
    const fn = async () =&gt; {
      const [favKey] = await FavouriteDomain.getKey(NAME_OFFERS_ID, user);
      const favourite = await FavouriteDomain.retrieve(connection, favKey);

      const reverse = await performReverseLookup(
        connection,
        favourite.nameAccount
      );

      if (mounted.current) {
        setResult(reverse);
      }

      return () =&gt; (mounted.current = false);
    };

    fn().catch(console.error);
  }, [user.toBase58()]);

  return result;
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="useprofilepic"><a class="header" href="#useprofilepic">useProfilePic</a></h1>
<p>Users can set a profile picture using the <code>pic</code> record of their favorite domain name. This record holds the URI to their profile picture.</p>
<pre><code class="language-ts">import { useEffect, useRef, useState } from &quot;react&quot;;
import { useConnection } from &quot;@solana/wallet-adapter-react&quot;;
import { PublicKey } from &quot;@solana/web3.js&quot;;
import { getDomainKey, NameRegistryState } from &quot;@bonfida/spl-name-service&quot;;

export const useProfilePic = (user: PublicKey) =&gt; {
  const { connection } = useConnection();
  const favorite = useFavoriteDomain(user);
  const [result, setResult] = useState&lt;Result&gt;(undefined);
  const mounted = useRef(true);

  useEffect(() =&gt; {
    const fn = async () =&gt; {
      if (!favorite) {
        return setResult(undefined);
      }

      const registry = await getPicRecord(connection, favorite.toBase58());

      if (!registry.data) {
        return setResult(undefined);
      }

      if (mounted.current) {
        setResult(registry.data.toString(&quot;utf-8&quot;));
      }

      return () =&gt; (mounted.current = false);
    };

    fn().catch(console.error);
  }, [user.toBase58(), favorite]);

  return result;
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tokenization"><a class="header" href="#tokenization">Tokenization</a></h1>
<p>Domain names are <strong>not</strong> SPL tokens, however, they can be tokenized in NFTs that follow the Metaplex standard. It's only recommended to tokenize your domain if you want to resell your domain on an NFT market place like <a href="https://magiceden.io/marketplace/bonfida">Magic Eden</a></p>
<p>To retrieve all the tokenized domain names</p>
<pre><code class="language-js">import { retrieveNfts } from &quot;@bonfida/spl-name-service&quot;;

// nfts is of type PublicKey[] and contains all the mints of the tokenized domain names
const nfts = await retrieveNfts(connection);
</code></pre>
<p>To retrieve the owner of the NFT that represent a tokenized domain name</p>
<pre><code class="language-js">import { retrieveNftOwner } from &quot;@bonfida/spl-name-service&quot;;

const owner = await retrieveNftOwner(connection, nameKey);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="registration"><a class="header" href="#registration">Registration</a></h1>
<p>Registration instructions can be created either via SDK or API, both methods are equivalent. To register a domain you will have to specify the following:</p>
<ul>
<li>Domain names</li>
<li>Space (between 1kb and 10kb)</li>
<li>The public key of the buyer</li>
</ul>
<h2 id="sdk"><a class="header" href="#sdk">SDK</a></h2>
<p>Unregistered domains can be registered using the SDK <code>@bonfida/spl-name-service</code> with the following instructions:</p>
<pre><code class="language-js">import { registerDomainName } from &quot;@bonfida/spl-name-service&quot;;

const name = &quot;bonfida&quot;; // We want to register bonfida.sol
const space = 1 * 1_000; // We want a 1kB sized domain (max 10kB)

const buyer = new PublicKey(&quot;...&quot;); // Publickey of the buyer
const buyerTokenAccount = new PublicKey(&quot;...&quot;); // Publickey of the FIDA token account of the buyer

const [, ix] = await registerDomainName(name, space, buyer, buyerTokenAccount);

// sign and send the instruction
</code></pre>
<h2 id="api"><a class="header" href="#api">API</a></h2>
<p>Registration instructions can also be created via API (equivalent to using the SDK):</p>
<pre><code>POST https://naming-api.bonfida.com/registrar/new-domain
</code></pre>
<p>With the following request body</p>
<pre><code class="language-json">{
  &quot;domain&quot;: &quot;domain_to_register&quot;,
  &quot;pubkey&quot;: &quot;pubkey_of_the_user&quot;,
  &quot;space&quot;: &quot;domain_space&quot;, // Between 1_000 and 10_000
  &quot;language&quot;: &quot;0&quot;
}
</code></pre>
<p>Response:</p>
<pre><code class="language-json">{
  &quot;success&quot;: true,
  &quot;data&quot;: {
    &quot;keys&quot;: [
      {
        &quot;pubkey&quot;: &quot;SysvarRent111111111111111111111111111111111&quot;,
        &quot;isSigner&quot;: false,
        &quot;isWritable&quot;: false
      },
      // ...
      {
        &quot;pubkey&quot;: &quot;62pexKUPWncYECF7DMtENjKbwZnrJoMpvDkrrtceC8Ee&quot;,
        &quot;isSigner&quot;: false,
        &quot;isWritable&quot;: false
      }
    ],
    &quot;programId&quot;: &quot;jCebN34bUfdeUYJT13J1yG16XWQpt5PDx6Mse9GUqhR&quot;,
    &quot;data&quot;: [
      9,
      // ...
      0
    ]
  }
}
</code></pre>
<p>More details about direct registration can be found <a href="https://docs.bonfida.org/collection/how-to-create-a-solana-domain-name/purchasing-a-domain-name/direct-registration">here</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="twitter"><a class="header" href="#twitter">Twitter</a></h1>
<p>This following sections provide information on the following:</p>
<ul>
<li><a href="twitter/twitter-tld.html">The twitter TLD</a></li>
<li><a href="twitter/register.html">How to register a twitter handle</a></li>
<li><a href="twitter/twitter-direct-lookup.html">How to perform a direct look up</a></li>
<li><a href="twitter/twitter-reverse-lookup.html">How to perform a reverse look up</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tld-1"><a class="header" href="#tld-1">TLD</a></h1>
<p>The Twitter handle TLD is</p>
<pre><code class="language-js">export const TWITTER_ROOT_PARENT_REGISTRY_KEY = new PublicKey(
  &quot;4YcexoW3r78zz16J2aqmukBLRwGq6rAvWzJpkYAXqebv&quot;
);
</code></pre>
<p>The <code>.twitter</code> TLD is owned by the <code>root</code> TLD and all twitter handles are subdomains of the <code>.twitter</code> TLD</p>
<p><img src="twitter/../assets/twitter-tld.png" alt="twitter-tld" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="twitter-handle-registration"><a class="header" href="#twitter-handle-registration">Twitter handle registration</a></h1>
<p>Twitter handles can be registered <a href="https://naming.bonfida.org/twitter">here</a> and a detailed guide can be found <a href="https://docs.bonfida.org/collection/solana-name-service-twitter">on the Community Help Center</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="direct-look-up-1"><a class="header" href="#direct-look-up-1">Direct look up</a></h1>
<p><img src="twitter/../assets/twitter-direct-reverse.png" alt="direct-reverse" /></p>
<p>To find the Twitter handle associated to a public key</p>
<pre><code class="language-js">import { getHandleAndRegistryKey } from &quot;@bonfida/spl-name-service&quot;;

const pubkey = new PublicKey(&quot;FidaeBkZkvDqi1GXNEwB8uWmj9Ngx2HXSS5nyGRuVFcZ&quot;);

const [handle] = await getHandleAndRegistryKey(connection, pubkey);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reverse-look-up-1"><a class="header" href="#reverse-look-up-1">Reverse look up</a></h1>
<p><img src="twitter/../assets/twitter-direct-reverse.png" alt="direct-reverse" /></p>
<p>To find the public key associated to a Twitter handle</p>
<pre><code class="language-js">import { getTwitterRegistry } from &quot;@bonfida/spl-name-service&quot;;

const handle = &quot;bonfida&quot;;

const registry = await getTwitterRegistry(connection, handle);
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
